require "json"
require "time"

module AwsSdk
  module Glue
    module Types

      # Access to a resource was denied.

      struct AccessDeniedException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Defines an action to be initiated by a trigger.

      struct Action
        include JSON::Serializable

        # The job arguments used when this trigger fires. For this job run, they replace the default arguments
        # set in the job definition itself. You can specify arguments here that your own job-execution script
        # consumes, as well as arguments that Glue itself consumes. For information about how to specify and
        # consume your own Job arguments, see the Calling Glue APIs in Python topic in the developer guide.
        # For information about the key-value pairs that Glue consumes to set up your job, see the Special
        # Parameters Used by Glue topic in the developer guide.

        @[JSON::Field(key: "Arguments")]
        getter arguments : Hash(String, String)?

        # The name of the crawler to be used with this action.

        @[JSON::Field(key: "CrawlerName")]
        getter crawler_name : String?

        # The name of a job to be run.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # Specifies configuration properties of a job run notification.

        @[JSON::Field(key: "NotificationProperty")]
        getter notification_property : Types::NotificationProperty?

        # The name of the SecurityConfiguration structure to be used with this action.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before
        # it is terminated and enters TIMEOUT status. This overrides the timeout value set in the parent job.
        # Jobs must have timeout values less than 7 days or 10080 minutes. Otherwise, the jobs will throw an
        # exception. When the value is left blank, the timeout is defaulted to 2880 minutes. Any existing Glue
        # jobs that had a timeout value greater than 7 days will be defaulted to 7 days. For instance if you
        # have specified a timeout of 20 days for a batch job, it will be stopped on the 7th day. For
        # streaming jobs, if you have set up a maintenance window, it will be restarted during the maintenance
        # window after 7 days.

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        def initialize(
          @arguments : Hash(String, String)? = nil,
          @crawler_name : String? = nil,
          @job_name : String? = nil,
          @notification_property : Types::NotificationProperty? = nil,
          @security_configuration : String? = nil,
          @timeout : Int32? = nil
        )
        end
      end

      # Specifies a transform that groups rows by chosen fields and computes the aggregated value by
      # specified function.

      struct Aggregate
        include JSON::Serializable

        # Specifies the aggregate functions to be performed on specified fields.

        @[JSON::Field(key: "Aggs")]
        getter aggs : Array(Types::AggregateOperation)

        # Specifies the fields to group by.

        @[JSON::Field(key: "Groups")]
        getter groups : Array(Array(String))

        # Specifies the fields and rows to use as inputs for the aggregate transform.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @aggs : Array(Types::AggregateOperation),
          @groups : Array(Array(String)),
          @inputs : Array(String),
          @name : String
        )
        end
      end

      # Specifies the set of parameters needed to perform aggregation in the aggregate transform.

      struct AggregateOperation
        include JSON::Serializable

        # Specifies the aggregation function to apply. Possible aggregation functions include: avg
        # countDistinct, count, first, last, kurtosis, max, min, skewness, stddev_samp, stddev_pop, sum,
        # sumDistinct, var_samp, var_pop

        @[JSON::Field(key: "AggFunc")]
        getter agg_func : String

        # Specifies the column on the data set on which the aggregation function will be applied.

        @[JSON::Field(key: "Column")]
        getter column : Array(String)

        def initialize(
          @agg_func : String,
          @column : Array(String)
        )
        end
      end

      # An object representing a value allowed for a property.

      struct AllowedValue
        include JSON::Serializable

        # The value allowed for the property.

        @[JSON::Field(key: "Value")]
        getter value : String

        # A description of the allowed value.

        @[JSON::Field(key: "Description")]
        getter description : String?

        def initialize(
          @value : String,
          @description : String? = nil
        )
        end
      end

      # A resource to be created or added already exists.

      struct AlreadyExistsException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Specifies an optional value when connecting to the Redshift cluster.

      struct AmazonRedshiftAdvancedOption
        include JSON::Serializable

        # The key for the additional connection option.

        @[JSON::Field(key: "Key")]
        getter key : String?

        # The value for the additional connection option.

        @[JSON::Field(key: "Value")]
        getter value : String?

        def initialize(
          @key : String? = nil,
          @value : String? = nil
        )
        end
      end

      # Specifies an Amazon Redshift node.

      struct AmazonRedshiftNodeData
        include JSON::Serializable

        # The access type for the Redshift connection. Can be a direct connection or catalog connections.

        @[JSON::Field(key: "AccessType")]
        getter access_type : String?

        # Specifies how writing to a Redshift cluser will occur.

        @[JSON::Field(key: "Action")]
        getter action : String?

        # Optional values when connecting to the Redshift cluster.

        @[JSON::Field(key: "AdvancedOptions")]
        getter advanced_options : Array(Types::AmazonRedshiftAdvancedOption)?

        # The name of the Glue Data Catalog database when working with a data catalog.

        @[JSON::Field(key: "CatalogDatabase")]
        getter catalog_database : Types::Option?

        # The Redshift schema name when working with a data catalog.

        @[JSON::Field(key: "CatalogRedshiftSchema")]
        getter catalog_redshift_schema : String?

        # The database table to read from.

        @[JSON::Field(key: "CatalogRedshiftTable")]
        getter catalog_redshift_table : String?

        # The Glue Data Catalog table name when working with a data catalog.

        @[JSON::Field(key: "CatalogTable")]
        getter catalog_table : Types::Option?

        # The Glue connection to the Redshift cluster.

        @[JSON::Field(key: "Connection")]
        getter connection : Types::Option?

        # Specifies the name of the connection that is associated with the catalog table used.

        @[JSON::Field(key: "CrawlerConnection")]
        getter crawler_connection : String?

        # Optional. The role name use when connection to S3. The IAM role ill default to the role on the job
        # when left blank.

        @[JSON::Field(key: "IamRole")]
        getter iam_role : Types::Option?

        # The action used when to detemine how a MERGE in a Redshift sink will be handled.

        @[JSON::Field(key: "MergeAction")]
        getter merge_action : String?

        # The SQL used in a custom merge to deal with matching records.

        @[JSON::Field(key: "MergeClause")]
        getter merge_clause : String?

        # The action used when to detemine how a MERGE in a Redshift sink will be handled when an existing
        # record matches a new record.

        @[JSON::Field(key: "MergeWhenMatched")]
        getter merge_when_matched : String?

        # The action used when to detemine how a MERGE in a Redshift sink will be handled when an existing
        # record doesn't match a new record.

        @[JSON::Field(key: "MergeWhenNotMatched")]
        getter merge_when_not_matched : String?

        # The SQL used before a MERGE or APPEND with upsert is run.

        @[JSON::Field(key: "PostAction")]
        getter post_action : String?

        # The SQL used before a MERGE or APPEND with upsert is run.

        @[JSON::Field(key: "PreAction")]
        getter pre_action : String?

        # The SQL used to fetch the data from a Redshift sources when the SourceType is 'query'.

        @[JSON::Field(key: "SampleQuery")]
        getter sample_query : String?

        # The Redshift schema name when working with a direct connection.

        @[JSON::Field(key: "Schema")]
        getter schema : Types::Option?

        # The list of column names used to determine a matching record when doing a MERGE or APPEND with
        # upsert.

        @[JSON::Field(key: "SelectedColumns")]
        getter selected_columns : Array(Types::Option)?

        # The source type to specify whether a specific table is the source or a custom query.

        @[JSON::Field(key: "SourceType")]
        getter source_type : String?

        # The name of the temporary staging table that is used when doing a MERGE or APPEND with upsert.

        @[JSON::Field(key: "StagingTable")]
        getter staging_table : String?

        # The Redshift table name when working with a direct connection.

        @[JSON::Field(key: "Table")]
        getter table : Types::Option?

        # Specifies the prefix to a table.

        @[JSON::Field(key: "TablePrefix")]
        getter table_prefix : String?

        # The array of schema output for a given node.

        @[JSON::Field(key: "TableSchema")]
        getter table_schema : Array(Types::Option)?

        # The Amazon S3 path where temporary data can be staged when copying out of the database.

        @[JSON::Field(key: "TempDir")]
        getter temp_dir : String?

        # The action used on Redshift sinks when doing an APPEND.

        @[JSON::Field(key: "Upsert")]
        getter upsert : Bool?

        def initialize(
          @access_type : String? = nil,
          @action : String? = nil,
          @advanced_options : Array(Types::AmazonRedshiftAdvancedOption)? = nil,
          @catalog_database : Types::Option? = nil,
          @catalog_redshift_schema : String? = nil,
          @catalog_redshift_table : String? = nil,
          @catalog_table : Types::Option? = nil,
          @connection : Types::Option? = nil,
          @crawler_connection : String? = nil,
          @iam_role : Types::Option? = nil,
          @merge_action : String? = nil,
          @merge_clause : String? = nil,
          @merge_when_matched : String? = nil,
          @merge_when_not_matched : String? = nil,
          @post_action : String? = nil,
          @pre_action : String? = nil,
          @sample_query : String? = nil,
          @schema : Types::Option? = nil,
          @selected_columns : Array(Types::Option)? = nil,
          @source_type : String? = nil,
          @staging_table : String? = nil,
          @table : Types::Option? = nil,
          @table_prefix : String? = nil,
          @table_schema : Array(Types::Option)? = nil,
          @temp_dir : String? = nil,
          @upsert : Bool? = nil
        )
        end
      end

      # Specifies an Amazon Redshift source.

      struct AmazonRedshiftSource
        include JSON::Serializable

        # Specifies the data of the Amazon Reshift source node.

        @[JSON::Field(key: "Data")]
        getter data : Types::AmazonRedshiftNodeData?

        # The name of the Amazon Redshift source.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @data : Types::AmazonRedshiftNodeData? = nil,
          @name : String? = nil
        )
        end
      end

      # Specifies an Amazon Redshift target.

      struct AmazonRedshiftTarget
        include JSON::Serializable

        # Specifies the data of the Amazon Redshift target node.

        @[JSON::Field(key: "Data")]
        getter data : Types::AmazonRedshiftNodeData?

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)?

        # The name of the Amazon Redshift target.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @data : Types::AmazonRedshiftNodeData? = nil,
          @inputs : Array(String)? = nil,
          @name : String? = nil
        )
        end
      end

      # A failed annotation.

      struct AnnotationError
        include JSON::Serializable

        # The reason why the annotation failed.

        @[JSON::Field(key: "FailureReason")]
        getter failure_reason : String?

        # The Profile ID for the failed annotation.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String?

        # The Statistic ID for the failed annotation.

        @[JSON::Field(key: "StatisticId")]
        getter statistic_id : String?

        def initialize(
          @failure_reason : String? = nil,
          @profile_id : String? = nil,
          @statistic_id : String? = nil
        )
        end
      end

      # Specifies a transform that maps data property keys in the data source to data property keys in the
      # data target. You can rename keys, modify the data types for keys, and choose which keys to drop from
      # the dataset.

      struct ApplyMapping
        include JSON::Serializable

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # Specifies the mapping of data property keys in the data source to data property keys in the data
        # target.

        @[JSON::Field(key: "Mapping")]
        getter mapping : Array(Types::Mapping)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @inputs : Array(String),
          @mapping : Array(Types::Mapping),
          @name : String
        )
        end
      end

      # Specifies a connector to an Amazon Athena data source.

      struct AthenaConnectorSource
        include JSON::Serializable

        # The name of the connection that is associated with the connector.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String

        # The type of connection, such as marketplace.athena or custom.athena, designating a connection to an
        # Amazon Athena data store.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        # The name of a connector that assists with accessing the data store in Glue Studio.

        @[JSON::Field(key: "ConnectorName")]
        getter connector_name : String

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the Cloudwatch log group to read from. For example, /aws-glue/jobs/output .

        @[JSON::Field(key: "SchemaName")]
        getter schema_name : String

        # The name of the table in the data source.

        @[JSON::Field(key: "ConnectionTable")]
        getter connection_table : String?

        # Specifies the data schema for the custom Athena source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @connection_name : String,
          @connection_type : String,
          @connector_name : String,
          @name : String,
          @schema_name : String,
          @connection_table : String? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # A structure containing the Lake Formation audit context.

      struct AuditContext
        include JSON::Serializable

        # A string containing the additional audit context information.

        @[JSON::Field(key: "AdditionalAuditContext")]
        getter additional_audit_context : String?

        # All columns request for audit.

        @[JSON::Field(key: "AllColumnsRequested")]
        getter all_columns_requested : Bool?

        # The requested columns for audit.

        @[JSON::Field(key: "RequestedColumns")]
        getter requested_columns : Array(String)?

        def initialize(
          @additional_audit_context : String? = nil,
          @all_columns_requested : Bool? = nil,
          @requested_columns : Array(String)? = nil
        )
        end
      end

      # The authentication configuration for a connection returned by the DescribeConnectionType API.

      struct AuthConfiguration
        include JSON::Serializable

        # The type of authentication for a connection.

        @[JSON::Field(key: "AuthenticationType")]
        getter authentication_type : Types::Property

        # A map of key-value pairs for the OAuth2 properties. Each value is a a Property object.

        @[JSON::Field(key: "BasicAuthenticationProperties")]
        getter basic_authentication_properties : Hash(String, Types::Property)?

        # A map of key-value pairs for the custom authentication properties. Each value is a a Property
        # object.

        @[JSON::Field(key: "CustomAuthenticationProperties")]
        getter custom_authentication_properties : Hash(String, Types::Property)?

        # A map of key-value pairs for the OAuth2 properties. Each value is a a Property object.

        @[JSON::Field(key: "OAuth2Properties")]
        getter o_auth2_properties : Hash(String, Types::Property)?

        # The Amazon Resource Name (ARN) for the Secrets Manager.

        @[JSON::Field(key: "SecretArn")]
        getter secret_arn : Types::Property?

        def initialize(
          @authentication_type : Types::Property,
          @basic_authentication_properties : Hash(String, Types::Property)? = nil,
          @custom_authentication_properties : Hash(String, Types::Property)? = nil,
          @o_auth2_properties : Hash(String, Types::Property)? = nil,
          @secret_arn : Types::Property? = nil
        )
        end
      end

      # A structure containing the authentication configuration.

      struct AuthenticationConfiguration
        include JSON::Serializable

        # A structure containing the authentication configuration.

        @[JSON::Field(key: "AuthenticationType")]
        getter authentication_type : String?

        # The Amazon Resource Name (ARN) of the KMS key used to encrypt sensitive authentication information.
        # This key is used to protect credentials and other sensitive data stored within the authentication
        # configuration.

        @[JSON::Field(key: "KmsKeyArn")]
        getter kms_key_arn : String?

        # The properties for OAuth2 authentication.

        @[JSON::Field(key: "OAuth2Properties")]
        getter o_auth2_properties : Types::OAuth2Properties?

        # The secret manager ARN to store credentials.

        @[JSON::Field(key: "SecretArn")]
        getter secret_arn : String?

        def initialize(
          @authentication_type : String? = nil,
          @kms_key_arn : String? = nil,
          @o_auth2_properties : Types::OAuth2Properties? = nil,
          @secret_arn : String? = nil
        )
        end
      end

      # A structure containing the authentication configuration in the CreateConnection request.

      struct AuthenticationConfigurationInput
        include JSON::Serializable

        # A structure containing the authentication configuration in the CreateConnection request.

        @[JSON::Field(key: "AuthenticationType")]
        getter authentication_type : String?

        # The credentials used when the authentication type is basic authentication.

        @[JSON::Field(key: "BasicAuthenticationCredentials")]
        getter basic_authentication_credentials : Types::BasicAuthenticationCredentials?

        # The credentials used when the authentication type is custom authentication.

        @[JSON::Field(key: "CustomAuthenticationCredentials")]
        getter custom_authentication_credentials : Hash(String, String)?

        # The ARN of the KMS key used to encrypt the connection. Only taken an as input in the request and
        # stored in the Secret Manager.

        @[JSON::Field(key: "KmsKeyArn")]
        getter kms_key_arn : String?

        # The properties for OAuth2 authentication in the CreateConnection request.

        @[JSON::Field(key: "OAuth2Properties")]
        getter o_auth2_properties : Types::OAuth2PropertiesInput?

        # The secret manager ARN to store credentials in the CreateConnection request.

        @[JSON::Field(key: "SecretArn")]
        getter secret_arn : String?

        def initialize(
          @authentication_type : String? = nil,
          @basic_authentication_credentials : Types::BasicAuthenticationCredentials? = nil,
          @custom_authentication_credentials : Hash(String, String)? = nil,
          @kms_key_arn : String? = nil,
          @o_auth2_properties : Types::OAuth2PropertiesInput? = nil,
          @secret_arn : String? = nil
        )
        end
      end

      # The set of properties required for the the OAuth2 AUTHORIZATION_CODE grant type workflow.

      struct AuthorizationCodeProperties
        include JSON::Serializable

        # An authorization code to be used in the third leg of the AUTHORIZATION_CODE grant workflow. This is
        # a single-use code which becomes invalid once exchanged for an access token, thus it is acceptable to
        # have this value as a request parameter.

        @[JSON::Field(key: "AuthorizationCode")]
        getter authorization_code : String?

        # The redirect URI where the user gets redirected to by authorization server when issuing an
        # authorization code. The URI is subsequently used when the authorization code is exchanged for an
        # access token.

        @[JSON::Field(key: "RedirectUri")]
        getter redirect_uri : String?

        def initialize(
          @authorization_code : String? = nil,
          @redirect_uri : String? = nil
        )
        end
      end

      # Specifies configuration options for automatic data quality evaluation in Glue jobs. This structure
      # enables automated data quality checks and monitoring during ETL operations, helping to ensure data
      # integrity and reliability without manual intervention.

      struct AutoDataQuality
        include JSON::Serializable

        # The evaluation context for the automatic data quality checks. This defines the scope and parameters
        # for the data quality evaluation.

        @[JSON::Field(key: "EvaluationContext")]
        getter evaluation_context : String?

        # Specifies whether automatic data quality evaluation is enabled. When set to true , data quality
        # checks are performed automatically.

        @[JSON::Field(key: "IsEnabled")]
        getter is_enabled : Bool?

        def initialize(
          @evaluation_context : String? = nil,
          @is_enabled : Bool? = nil
        )
        end
      end

      # A list of errors that can occur when registering partition indexes for an existing table. These
      # errors give the details about why an index registration failed and provide a limited number of
      # partitions in the response, so that you can fix the partitions at fault and try registering the
      # index again. The most common set of errors that can occur are categorized as follows:
      # EncryptedPartitionError: The partitions are encrypted. InvalidPartitionTypeDataError: The partition
      # value doesn't match the data type for that partition column. MissingPartitionValueError: The
      # partitions are encrypted. UnsupportedPartitionCharacterError: Characters inside the partition value
      # are not supported. For example: U+0000 , U+0001, U+0002. InternalError: Any error which does not
      # belong to other error codes.

      struct BackfillError
        include JSON::Serializable

        # The error code for an error that occurred when registering partition indexes for an existing table.

        @[JSON::Field(key: "Code")]
        getter code : String?

        # A list of a limited number of partitions in the response.

        @[JSON::Field(key: "Partitions")]
        getter partitions : Array(Types::PartitionValueList)?

        def initialize(
          @code : String? = nil,
          @partitions : Array(Types::PartitionValueList)? = nil
        )
        end
      end

      # For supplying basic auth credentials when not providing a SecretArn value.

      struct BasicAuthenticationCredentials
        include JSON::Serializable

        # The password to connect to the data source.

        @[JSON::Field(key: "Password")]
        getter password : String?

        # The username to connect to the data source.

        @[JSON::Field(key: "Username")]
        getter username : String?

        def initialize(
          @password : String? = nil,
          @username : String? = nil
        )
        end
      end

      # Specifies a target that uses a Glue Data Catalog table.

      struct BasicCatalogTarget
        include JSON::Serializable

        # The database that contains the table you want to use as the target. This database must already exist
        # in the Data Catalog.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of your data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The table that defines the schema of your output data. This table must already exist in the Data
        # Catalog.

        @[JSON::Field(key: "Table")]
        getter table : String

        # The partition keys used to distribute data across multiple partitions or shards based on a specific
        # key or set of key.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        def initialize(
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String,
          @partition_keys : Array(Array(String))? = nil
        )
        end
      end


      struct BatchCreatePartitionRequest
        include JSON::Serializable

        # The name of the metadata database in which the partition is to be created.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A list of PartitionInput structures that define the partitions to be created.

        @[JSON::Field(key: "PartitionInputList")]
        getter partition_input_list : Array(Types::PartitionInput)

        # The name of the metadata table in which the partition is to be created.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the catalog in which the partition is to be created. Currently, this should be the Amazon
        # Web Services account ID.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @partition_input_list : Array(Types::PartitionInput),
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct BatchCreatePartitionResponse
        include JSON::Serializable

        # The errors encountered when trying to create the requested partitions.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::PartitionError)?

        def initialize(
          @errors : Array(Types::PartitionError)? = nil
        )
        end
      end


      struct BatchDeleteConnectionRequest
        include JSON::Serializable

        # A list of names of the connections to delete.

        @[JSON::Field(key: "ConnectionNameList")]
        getter connection_name_list : Array(String)

        # The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @connection_name_list : Array(String),
          @catalog_id : String? = nil
        )
        end
      end


      struct BatchDeleteConnectionResponse
        include JSON::Serializable

        # A map of the names of connections that were not successfully deleted to error details.

        @[JSON::Field(key: "Errors")]
        getter errors : Hash(String, Types::ErrorDetail)?

        # A list of names of the connection definitions that were successfully deleted.

        @[JSON::Field(key: "Succeeded")]
        getter succeeded : Array(String)?

        def initialize(
          @errors : Hash(String, Types::ErrorDetail)? = nil,
          @succeeded : Array(String)? = nil
        )
        end
      end


      struct BatchDeletePartitionRequest
        include JSON::Serializable

        # The name of the catalog database in which the table in question resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A list of PartitionInput structures that define the partitions to be deleted.

        @[JSON::Field(key: "PartitionsToDelete")]
        getter partitions_to_delete : Array(Types::PartitionValueList)

        # The name of the table that contains the partitions to be deleted.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partition to be deleted resides. If none is provided, the
        # Amazon Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @partitions_to_delete : Array(Types::PartitionValueList),
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct BatchDeletePartitionResponse
        include JSON::Serializable

        # The errors encountered when trying to delete the requested partitions.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::PartitionError)?

        def initialize(
          @errors : Array(Types::PartitionError)? = nil
        )
        end
      end


      struct BatchDeleteTableRequest
        include JSON::Serializable

        # The name of the catalog database in which the tables to delete reside. For Hive compatibility, this
        # name is entirely lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A list of the table to delete.

        @[JSON::Field(key: "TablesToDelete")]
        getter tables_to_delete : Array(String)

        # The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The transaction ID at which to delete the table contents.

        @[JSON::Field(key: "TransactionId")]
        getter transaction_id : String?

        def initialize(
          @database_name : String,
          @tables_to_delete : Array(String),
          @catalog_id : String? = nil,
          @transaction_id : String? = nil
        )
        end
      end


      struct BatchDeleteTableResponse
        include JSON::Serializable

        # A list of errors encountered in attempting to delete the specified tables.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::TableError)?

        def initialize(
          @errors : Array(Types::TableError)? = nil
        )
        end
      end


      struct BatchDeleteTableVersionRequest
        include JSON::Serializable

        # The database in the catalog in which the table resides. For Hive compatibility, this name is
        # entirely lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table. For Hive compatibility, this name is entirely lowercase.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # A list of the IDs of versions to be deleted. A VersionId is a string representation of an integer.
        # Each version is incremented by 1.

        @[JSON::Field(key: "VersionIds")]
        getter version_ids : Array(String)

        # The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @version_ids : Array(String),
          @catalog_id : String? = nil
        )
        end
      end


      struct BatchDeleteTableVersionResponse
        include JSON::Serializable

        # A list of errors encountered while trying to delete the specified table versions.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::TableVersionError)?

        def initialize(
          @errors : Array(Types::TableVersionError)? = nil
        )
        end
      end


      struct BatchGetBlueprintsRequest
        include JSON::Serializable

        # A list of blueprint names.

        @[JSON::Field(key: "Names")]
        getter names : Array(String)

        # Specifies whether or not to include the blueprint in the response.

        @[JSON::Field(key: "IncludeBlueprint")]
        getter include_blueprint : Bool?

        # Specifies whether or not to include the parameters, as a JSON string, for the blueprint in the
        # response.

        @[JSON::Field(key: "IncludeParameterSpec")]
        getter include_parameter_spec : Bool?

        def initialize(
          @names : Array(String),
          @include_blueprint : Bool? = nil,
          @include_parameter_spec : Bool? = nil
        )
        end
      end


      struct BatchGetBlueprintsResponse
        include JSON::Serializable

        # Returns a list of blueprint as a Blueprints object.

        @[JSON::Field(key: "Blueprints")]
        getter blueprints : Array(Types::Blueprint)?

        # Returns a list of BlueprintNames that were not found.

        @[JSON::Field(key: "MissingBlueprints")]
        getter missing_blueprints : Array(String)?

        def initialize(
          @blueprints : Array(Types::Blueprint)? = nil,
          @missing_blueprints : Array(String)? = nil
        )
        end
      end


      struct BatchGetCrawlersRequest
        include JSON::Serializable

        # A list of crawler names, which might be the names returned from the ListCrawlers operation.

        @[JSON::Field(key: "CrawlerNames")]
        getter crawler_names : Array(String)

        def initialize(
          @crawler_names : Array(String)
        )
        end
      end


      struct BatchGetCrawlersResponse
        include JSON::Serializable

        # A list of crawler definitions.

        @[JSON::Field(key: "Crawlers")]
        getter crawlers : Array(Types::Crawler)?

        # A list of names of crawlers that were not found.

        @[JSON::Field(key: "CrawlersNotFound")]
        getter crawlers_not_found : Array(String)?

        def initialize(
          @crawlers : Array(Types::Crawler)? = nil,
          @crawlers_not_found : Array(String)? = nil
        )
        end
      end


      struct BatchGetCustomEntityTypesRequest
        include JSON::Serializable

        # A list of names of the custom patterns that you want to retrieve.

        @[JSON::Field(key: "Names")]
        getter names : Array(String)

        def initialize(
          @names : Array(String)
        )
        end
      end


      struct BatchGetCustomEntityTypesResponse
        include JSON::Serializable

        # A list of CustomEntityType objects representing the custom patterns that have been created.

        @[JSON::Field(key: "CustomEntityTypes")]
        getter custom_entity_types : Array(Types::CustomEntityType)?

        # A list of the names of custom patterns that were not found.

        @[JSON::Field(key: "CustomEntityTypesNotFound")]
        getter custom_entity_types_not_found : Array(String)?

        def initialize(
          @custom_entity_types : Array(Types::CustomEntityType)? = nil,
          @custom_entity_types_not_found : Array(String)? = nil
        )
        end
      end


      struct BatchGetDataQualityResultRequest
        include JSON::Serializable

        # A list of unique result IDs for the data quality results.

        @[JSON::Field(key: "ResultIds")]
        getter result_ids : Array(String)

        def initialize(
          @result_ids : Array(String)
        )
        end
      end


      struct BatchGetDataQualityResultResponse
        include JSON::Serializable

        # A list of DataQualityResult objects representing the data quality results.

        @[JSON::Field(key: "Results")]
        getter results : Array(Types::DataQualityResult)

        # A list of result IDs for which results were not found.

        @[JSON::Field(key: "ResultsNotFound")]
        getter results_not_found : Array(String)?

        def initialize(
          @results : Array(Types::DataQualityResult),
          @results_not_found : Array(String)? = nil
        )
        end
      end


      struct BatchGetDevEndpointsRequest
        include JSON::Serializable

        # The list of DevEndpoint names, which might be the names returned from the ListDevEndpoint operation.

        @[JSON::Field(key: "DevEndpointNames")]
        getter dev_endpoint_names : Array(String)

        def initialize(
          @dev_endpoint_names : Array(String)
        )
        end
      end


      struct BatchGetDevEndpointsResponse
        include JSON::Serializable

        # A list of DevEndpoint definitions.

        @[JSON::Field(key: "DevEndpoints")]
        getter dev_endpoints : Array(Types::DevEndpoint)?

        # A list of DevEndpoints not found.

        @[JSON::Field(key: "DevEndpointsNotFound")]
        getter dev_endpoints_not_found : Array(String)?

        def initialize(
          @dev_endpoints : Array(Types::DevEndpoint)? = nil,
          @dev_endpoints_not_found : Array(String)? = nil
        )
        end
      end


      struct BatchGetJobsRequest
        include JSON::Serializable

        # A list of job names, which might be the names returned from the ListJobs operation.

        @[JSON::Field(key: "JobNames")]
        getter job_names : Array(String)

        def initialize(
          @job_names : Array(String)
        )
        end
      end


      struct BatchGetJobsResponse
        include JSON::Serializable

        # A list of job definitions.

        @[JSON::Field(key: "Jobs")]
        getter jobs : Array(Types::Job)?

        # A list of names of jobs not found.

        @[JSON::Field(key: "JobsNotFound")]
        getter jobs_not_found : Array(String)?

        def initialize(
          @jobs : Array(Types::Job)? = nil,
          @jobs_not_found : Array(String)? = nil
        )
        end
      end


      struct BatchGetPartitionRequest
        include JSON::Serializable

        # The name of the catalog database where the partitions reside.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A list of partition values identifying the partitions to retrieve.

        @[JSON::Field(key: "PartitionsToGet")]
        getter partitions_to_get : Array(Types::PartitionValueList)

        # The name of the partitions' table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @partitions_to_get : Array(Types::PartitionValueList),
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct BatchGetPartitionResponse
        include JSON::Serializable

        # A list of the requested partitions.

        @[JSON::Field(key: "Partitions")]
        getter partitions : Array(Types::Partition)?

        # A list of the partition values in the request for which partitions were not returned.

        @[JSON::Field(key: "UnprocessedKeys")]
        getter unprocessed_keys : Array(Types::PartitionValueList)?

        def initialize(
          @partitions : Array(Types::Partition)? = nil,
          @unprocessed_keys : Array(Types::PartitionValueList)? = nil
        )
        end
      end

      # Represents a table optimizer to retrieve in the BatchGetTableOptimizer operation.

      struct BatchGetTableOptimizerEntry
        include JSON::Serializable

        # The Catalog ID of the table.

        @[JSON::Field(key: "catalogId")]
        getter catalog_id : String?

        # The name of the database in the catalog in which the table resides.

        @[JSON::Field(key: "databaseName")]
        getter database_name : String?

        # The name of the table.

        @[JSON::Field(key: "tableName")]
        getter table_name : String?

        # The type of table optimizer.

        @[JSON::Field(key: "type")]
        getter type : String?

        def initialize(
          @catalog_id : String? = nil,
          @database_name : String? = nil,
          @table_name : String? = nil,
          @type : String? = nil
        )
        end
      end

      # Contains details on one of the errors in the error list returned by the BatchGetTableOptimizer
      # operation.

      struct BatchGetTableOptimizerError
        include JSON::Serializable

        # The Catalog ID of the table.

        @[JSON::Field(key: "catalogId")]
        getter catalog_id : String?

        # The name of the database in the catalog in which the table resides.

        @[JSON::Field(key: "databaseName")]
        getter database_name : String?

        # An ErrorDetail object containing code and message details about the error.

        @[JSON::Field(key: "error")]
        getter error : Types::ErrorDetail?

        # The name of the table.

        @[JSON::Field(key: "tableName")]
        getter table_name : String?

        # The type of table optimizer.

        @[JSON::Field(key: "type")]
        getter type : String?

        def initialize(
          @catalog_id : String? = nil,
          @database_name : String? = nil,
          @error : Types::ErrorDetail? = nil,
          @table_name : String? = nil,
          @type : String? = nil
        )
        end
      end


      struct BatchGetTableOptimizerRequest
        include JSON::Serializable

        # A list of BatchGetTableOptimizerEntry objects specifying the table optimizers to retrieve.

        @[JSON::Field(key: "Entries")]
        getter entries : Array(Types::BatchGetTableOptimizerEntry)

        def initialize(
          @entries : Array(Types::BatchGetTableOptimizerEntry)
        )
        end
      end


      struct BatchGetTableOptimizerResponse
        include JSON::Serializable

        # A list of errors from the operation.

        @[JSON::Field(key: "Failures")]
        getter failures : Array(Types::BatchGetTableOptimizerError)?

        # A list of BatchTableOptimizer objects.

        @[JSON::Field(key: "TableOptimizers")]
        getter table_optimizers : Array(Types::BatchTableOptimizer)?

        def initialize(
          @failures : Array(Types::BatchGetTableOptimizerError)? = nil,
          @table_optimizers : Array(Types::BatchTableOptimizer)? = nil
        )
        end
      end


      struct BatchGetTriggersRequest
        include JSON::Serializable

        # A list of trigger names, which may be the names returned from the ListTriggers operation.

        @[JSON::Field(key: "TriggerNames")]
        getter trigger_names : Array(String)

        def initialize(
          @trigger_names : Array(String)
        )
        end
      end


      struct BatchGetTriggersResponse
        include JSON::Serializable

        # A list of trigger definitions.

        @[JSON::Field(key: "Triggers")]
        getter triggers : Array(Types::Trigger)?

        # A list of names of triggers not found.

        @[JSON::Field(key: "TriggersNotFound")]
        getter triggers_not_found : Array(String)?

        def initialize(
          @triggers : Array(Types::Trigger)? = nil,
          @triggers_not_found : Array(String)? = nil
        )
        end
      end


      struct BatchGetWorkflowsRequest
        include JSON::Serializable

        # A list of workflow names, which may be the names returned from the ListWorkflows operation.

        @[JSON::Field(key: "Names")]
        getter names : Array(String)

        # Specifies whether to include a graph when returning the workflow resource metadata.

        @[JSON::Field(key: "IncludeGraph")]
        getter include_graph : Bool?

        def initialize(
          @names : Array(String),
          @include_graph : Bool? = nil
        )
        end
      end


      struct BatchGetWorkflowsResponse
        include JSON::Serializable

        # A list of names of workflows not found.

        @[JSON::Field(key: "MissingWorkflows")]
        getter missing_workflows : Array(String)?

        # A list of workflow resource metadata.

        @[JSON::Field(key: "Workflows")]
        getter workflows : Array(Types::Workflow)?

        def initialize(
          @missing_workflows : Array(String)? = nil,
          @workflows : Array(Types::Workflow)? = nil
        )
        end
      end


      struct BatchPutDataQualityStatisticAnnotationRequest
        include JSON::Serializable

        # A list of DatapointInclusionAnnotation 's. The InclusionAnnotations must contain a profileId and
        # statisticId. If there are multiple InclusionAnnotations, the list must refer to a single statisticId
        # across multiple profileIds.

        @[JSON::Field(key: "InclusionAnnotations")]
        getter inclusion_annotations : Array(Types::DatapointInclusionAnnotation)

        # Client Token.

        @[JSON::Field(key: "ClientToken")]
        getter client_token : String?

        def initialize(
          @inclusion_annotations : Array(Types::DatapointInclusionAnnotation),
          @client_token : String? = nil
        )
        end
      end


      struct BatchPutDataQualityStatisticAnnotationResponse
        include JSON::Serializable

        # A list of AnnotationError 's.

        @[JSON::Field(key: "FailedInclusionAnnotations")]
        getter failed_inclusion_annotations : Array(Types::AnnotationError)?

        def initialize(
          @failed_inclusion_annotations : Array(Types::AnnotationError)? = nil
        )
        end
      end

      # Records an error that occurred when attempting to stop a specified job run.

      struct BatchStopJobRunError
        include JSON::Serializable

        # Specifies details about the error that was encountered.

        @[JSON::Field(key: "ErrorDetail")]
        getter error_detail : Types::ErrorDetail?

        # The name of the job definition that is used in the job run in question.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # The JobRunId of the job run in question.

        @[JSON::Field(key: "JobRunId")]
        getter job_run_id : String?

        def initialize(
          @error_detail : Types::ErrorDetail? = nil,
          @job_name : String? = nil,
          @job_run_id : String? = nil
        )
        end
      end


      struct BatchStopJobRunRequest
        include JSON::Serializable

        # The name of the job definition for which to stop job runs.

        @[JSON::Field(key: "JobName")]
        getter job_name : String

        # A list of the JobRunIds that should be stopped for that job definition.

        @[JSON::Field(key: "JobRunIds")]
        getter job_run_ids : Array(String)

        def initialize(
          @job_name : String,
          @job_run_ids : Array(String)
        )
        end
      end


      struct BatchStopJobRunResponse
        include JSON::Serializable

        # A list of the errors that were encountered in trying to stop JobRuns , including the JobRunId for
        # which each error was encountered and details about the error.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::BatchStopJobRunError)?

        # A list of the JobRuns that were successfully submitted for stopping.

        @[JSON::Field(key: "SuccessfulSubmissions")]
        getter successful_submissions : Array(Types::BatchStopJobRunSuccessfulSubmission)?

        def initialize(
          @errors : Array(Types::BatchStopJobRunError)? = nil,
          @successful_submissions : Array(Types::BatchStopJobRunSuccessfulSubmission)? = nil
        )
        end
      end

      # Records a successful request to stop a specified JobRun .

      struct BatchStopJobRunSuccessfulSubmission
        include JSON::Serializable

        # The name of the job definition used in the job run that was stopped.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # The JobRunId of the job run that was stopped.

        @[JSON::Field(key: "JobRunId")]
        getter job_run_id : String?

        def initialize(
          @job_name : String? = nil,
          @job_run_id : String? = nil
        )
        end
      end

      # Contains details for one of the table optimizers returned by the BatchGetTableOptimizer operation.

      struct BatchTableOptimizer
        include JSON::Serializable

        # The Catalog ID of the table.

        @[JSON::Field(key: "catalogId")]
        getter catalog_id : String?

        # The name of the database in the catalog in which the table resides.

        @[JSON::Field(key: "databaseName")]
        getter database_name : String?

        # The name of the table.

        @[JSON::Field(key: "tableName")]
        getter table_name : String?

        # A TableOptimizer object that contains details on the configuration and last run of a table
        # optimizer.

        @[JSON::Field(key: "tableOptimizer")]
        getter table_optimizer : Types::TableOptimizer?

        def initialize(
          @catalog_id : String? = nil,
          @database_name : String? = nil,
          @table_name : String? = nil,
          @table_optimizer : Types::TableOptimizer? = nil
        )
        end
      end

      # Contains information about a batch update partition error.

      struct BatchUpdatePartitionFailureEntry
        include JSON::Serializable

        # The details about the batch update partition error.

        @[JSON::Field(key: "ErrorDetail")]
        getter error_detail : Types::ErrorDetail?

        # A list of values defining the partitions.

        @[JSON::Field(key: "PartitionValueList")]
        getter partition_value_list : Array(String)?

        def initialize(
          @error_detail : Types::ErrorDetail? = nil,
          @partition_value_list : Array(String)? = nil
        )
        end
      end


      struct BatchUpdatePartitionRequest
        include JSON::Serializable

        # The name of the metadata database in which the partition is to be updated.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A list of up to 100 BatchUpdatePartitionRequestEntry objects to update.

        @[JSON::Field(key: "Entries")]
        getter entries : Array(Types::BatchUpdatePartitionRequestEntry)

        # The name of the metadata table in which the partition is to be updated.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the catalog in which the partition is to be updated. Currently, this should be the Amazon
        # Web Services account ID.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @entries : Array(Types::BatchUpdatePartitionRequestEntry),
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end

      # A structure that contains the values and structure used to update a partition.

      struct BatchUpdatePartitionRequestEntry
        include JSON::Serializable

        # The structure used to update a partition.

        @[JSON::Field(key: "PartitionInput")]
        getter partition_input : Types::PartitionInput

        # A list of values defining the partitions.

        @[JSON::Field(key: "PartitionValueList")]
        getter partition_value_list : Array(String)

        def initialize(
          @partition_input : Types::PartitionInput,
          @partition_value_list : Array(String)
        )
        end
      end


      struct BatchUpdatePartitionResponse
        include JSON::Serializable

        # The errors encountered when trying to update the requested partitions. A list of
        # BatchUpdatePartitionFailureEntry objects.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::BatchUpdatePartitionFailureEntry)?

        def initialize(
          @errors : Array(Types::BatchUpdatePartitionFailureEntry)? = nil
        )
        end
      end

      # Defines column statistics supported for bit sequence data values.

      struct BinaryColumnStatisticsData
        include JSON::Serializable

        # The average bit sequence length in the column.

        @[JSON::Field(key: "AverageLength")]
        getter average_length : Float64

        # The size of the longest bit sequence in the column.

        @[JSON::Field(key: "MaximumLength")]
        getter maximum_length : Int64

        # The number of null values in the column.

        @[JSON::Field(key: "NumberOfNulls")]
        getter number_of_nulls : Int64

        def initialize(
          @average_length : Float64,
          @maximum_length : Int64,
          @number_of_nulls : Int64
        )
        end
      end

      # The details of a blueprint.

      struct Blueprint
        include JSON::Serializable

        # Specifies the path in Amazon S3 where the blueprint is published.

        @[JSON::Field(key: "BlueprintLocation")]
        getter blueprint_location : String?

        # Specifies a path in Amazon S3 where the blueprint is copied when you call
        # CreateBlueprint/UpdateBlueprint to register the blueprint in Glue.

        @[JSON::Field(key: "BlueprintServiceLocation")]
        getter blueprint_service_location : String?

        # The date and time the blueprint was registered.

        @[JSON::Field(key: "CreatedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_on : Time?

        # The description of the blueprint.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # An error message.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # When there are multiple versions of a blueprint and the latest version has some errors, this
        # attribute indicates the last successful blueprint definition that is available with the service.

        @[JSON::Field(key: "LastActiveDefinition")]
        getter last_active_definition : Types::LastActiveDefinition?

        # The date and time the blueprint was last modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The name of the blueprint.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # A JSON string that indicates the list of parameter specifications for the blueprint.

        @[JSON::Field(key: "ParameterSpec")]
        getter parameter_spec : String?

        # The status of the blueprint registration. Creating  The blueprint registration is in progress.
        # Active  The blueprint has been successfully registered. Updating  An update to the blueprint
        # registration is in progress. Failed  The blueprint registration failed.

        @[JSON::Field(key: "Status")]
        getter status : String?

        def initialize(
          @blueprint_location : String? = nil,
          @blueprint_service_location : String? = nil,
          @created_on : Time? = nil,
          @description : String? = nil,
          @error_message : String? = nil,
          @last_active_definition : Types::LastActiveDefinition? = nil,
          @last_modified_on : Time? = nil,
          @name : String? = nil,
          @parameter_spec : String? = nil,
          @status : String? = nil
        )
        end
      end

      # The details of a blueprint.

      struct BlueprintDetails
        include JSON::Serializable

        # The name of the blueprint.

        @[JSON::Field(key: "BlueprintName")]
        getter blueprint_name : String?

        # The run ID for this blueprint.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        def initialize(
          @blueprint_name : String? = nil,
          @run_id : String? = nil
        )
        end
      end

      # The details of a blueprint run.

      struct BlueprintRun
        include JSON::Serializable

        # The name of the blueprint.

        @[JSON::Field(key: "BlueprintName")]
        getter blueprint_name : String?

        # The date and time that the blueprint run completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # Indicates any errors that are seen while running the blueprint.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # The blueprint parameters as a string. You will have to provide a value for each key that is required
        # from the parameter spec that is defined in the Blueprint$ParameterSpec .

        @[JSON::Field(key: "Parameters")]
        getter parameters : String?

        # The role ARN. This role will be assumed by the Glue service and will be used to create the workflow
        # and other entities of a workflow.

        @[JSON::Field(key: "RoleArn")]
        getter role_arn : String?

        # If there are any errors while creating the entities of a workflow, we try to roll back the created
        # entities until that point and delete them. This attribute indicates the errors seen while trying to
        # delete the entities that are created.

        @[JSON::Field(key: "RollbackErrorMessage")]
        getter rollback_error_message : String?

        # The run ID for this blueprint run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        # The date and time that the blueprint run started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # The state of the blueprint run. Possible values are: Running  The blueprint run is in progress.
        # Succeeded  The blueprint run completed successfully. Failed  The blueprint run failed and rollback
        # is complete. Rolling Back  The blueprint run failed and rollback is in progress.

        @[JSON::Field(key: "State")]
        getter state : String?

        # The name of a workflow that is created as a result of a successful blueprint run. If a blueprint run
        # has an error, there will not be a workflow created.

        @[JSON::Field(key: "WorkflowName")]
        getter workflow_name : String?

        def initialize(
          @blueprint_name : String? = nil,
          @completed_on : Time? = nil,
          @error_message : String? = nil,
          @parameters : String? = nil,
          @role_arn : String? = nil,
          @rollback_error_message : String? = nil,
          @run_id : String? = nil,
          @started_on : Time? = nil,
          @state : String? = nil,
          @workflow_name : String? = nil
        )
        end
      end

      # Defines column statistics supported for Boolean data columns.

      struct BooleanColumnStatisticsData
        include JSON::Serializable

        # The number of false values in the column.

        @[JSON::Field(key: "NumberOfFalses")]
        getter number_of_falses : Int64

        # The number of null values in the column.

        @[JSON::Field(key: "NumberOfNulls")]
        getter number_of_nulls : Int64

        # The number of true values in the column.

        @[JSON::Field(key: "NumberOfTrues")]
        getter number_of_trues : Int64

        def initialize(
          @number_of_falses : Int64,
          @number_of_nulls : Int64,
          @number_of_trues : Int64
        )
        end
      end


      struct CancelDataQualityRuleRecommendationRunRequest
        include JSON::Serializable

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        def initialize(
          @run_id : String
        )
        end
      end


      struct CancelDataQualityRuleRecommendationRunResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CancelDataQualityRulesetEvaluationRunRequest
        include JSON::Serializable

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        def initialize(
          @run_id : String
        )
        end
      end


      struct CancelDataQualityRulesetEvaluationRunResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CancelMLTaskRunRequest
        include JSON::Serializable

        # A unique identifier for the task run.

        @[JSON::Field(key: "TaskRunId")]
        getter task_run_id : String

        # The unique identifier of the machine learning transform.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String

        def initialize(
          @task_run_id : String,
          @transform_id : String
        )
        end
      end


      struct CancelMLTaskRunResponse
        include JSON::Serializable

        # The status for this run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The unique identifier for the task run.

        @[JSON::Field(key: "TaskRunId")]
        getter task_run_id : String?

        # The unique identifier of the machine learning transform.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String?

        def initialize(
          @status : String? = nil,
          @task_run_id : String? = nil,
          @transform_id : String? = nil
        )
        end
      end


      struct CancelStatementRequest
        include JSON::Serializable

        # The ID of the statement to be cancelled.

        @[JSON::Field(key: "Id")]
        getter id : Int32

        # The Session ID of the statement to be cancelled.

        @[JSON::Field(key: "SessionId")]
        getter session_id : String

        # The origin of the request to cancel the statement.

        @[JSON::Field(key: "RequestOrigin")]
        getter request_origin : String?

        def initialize(
          @id : Int32,
          @session_id : String,
          @request_origin : String? = nil
        )
        end
      end


      struct CancelStatementResponse
        include JSON::Serializable

        def initialize
        end
      end

      # Specifies the supported authentication types returned by the DescribeConnectionType API.

      struct Capabilities
        include JSON::Serializable

        # A list of supported authentication types.

        @[JSON::Field(key: "SupportedAuthenticationTypes")]
        getter supported_authentication_types : Array(String)

        # A list of supported compute environments.

        @[JSON::Field(key: "SupportedComputeEnvironments")]
        getter supported_compute_environments : Array(String)

        # A list of supported data operations.

        @[JSON::Field(key: "SupportedDataOperations")]
        getter supported_data_operations : Array(String)

        def initialize(
          @supported_authentication_types : Array(String),
          @supported_compute_environments : Array(String),
          @supported_data_operations : Array(String)
        )
        end
      end

      # The catalog object represents a logical grouping of databases in the Glue Data Catalog or a
      # federated source. You can now create a Redshift-federated catalog or a catalog containing resource
      # links to Redshift databases in another account or region.

      struct Catalog
        include JSON::Serializable

        # The name of the catalog. Cannot be the same as the account ID.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Allows third-party engines to access data in Amazon S3 locations that are registered with Lake
        # Formation.

        @[JSON::Field(key: "AllowFullTableExternalDataAccess")]
        getter allow_full_table_external_data_access : String?

        # The ID of the catalog. To grant access to the default catalog, this field should not be provided.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # A CatalogProperties object that specifies data lake access properties and other custom properties.

        @[JSON::Field(key: "CatalogProperties")]
        getter catalog_properties : Types::CatalogPropertiesOutput?

        # An array of PrincipalPermissions objects. Creates a set of default permissions on the database(s)
        # for principals. Used by Amazon Web Services Lake Formation. Not used in the normal course of Glue
        # operations.

        @[JSON::Field(key: "CreateDatabaseDefaultPermissions")]
        getter create_database_default_permissions : Array(Types::PrincipalPermissions)?

        # An array of PrincipalPermissions objects. Creates a set of default permissions on the table(s) for
        # principals. Used by Amazon Web Services Lake Formation. Not used in the normal course of Glue
        # operations.

        @[JSON::Field(key: "CreateTableDefaultPermissions")]
        getter create_table_default_permissions : Array(Types::PrincipalPermissions)?

        # The time at which the catalog was created.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time?

        # Description string, not more than 2048 bytes long, matching the URI address multi-line string
        # pattern. A description of the catalog.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A FederatedCatalog object that points to an entity outside the Glue Data Catalog.

        @[JSON::Field(key: "FederatedCatalog")]
        getter federated_catalog : Types::FederatedCatalog?

        # A map array of key-value pairs that define parameters and properties of the catalog.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # The Amazon Resource Name (ARN) assigned to the catalog resource.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String?

        # A TargetRedshiftCatalog object that describes a target catalog for database resource linking.

        @[JSON::Field(key: "TargetRedshiftCatalog")]
        getter target_redshift_catalog : Types::TargetRedshiftCatalog?

        # The time at which the catalog was last updated.

        @[JSON::Field(key: "UpdateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter update_time : Time?

        def initialize(
          @name : String,
          @allow_full_table_external_data_access : String? = nil,
          @catalog_id : String? = nil,
          @catalog_properties : Types::CatalogPropertiesOutput? = nil,
          @create_database_default_permissions : Array(Types::PrincipalPermissions)? = nil,
          @create_table_default_permissions : Array(Types::PrincipalPermissions)? = nil,
          @create_time : Time? = nil,
          @description : String? = nil,
          @federated_catalog : Types::FederatedCatalog? = nil,
          @parameters : Hash(String, String)? = nil,
          @resource_arn : String? = nil,
          @target_redshift_catalog : Types::TargetRedshiftCatalog? = nil,
          @update_time : Time? = nil
        )
        end
      end

      # Specifies a Delta Lake data source that is registered in the Glue Data Catalog.

      struct CatalogDeltaSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the Delta Lake data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalDeltaOptions")]
        getter additional_delta_options : Hash(String, String)?

        # Specifies the data schema for the Delta Lake source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @additional_delta_options : Hash(String, String)? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies a table definition in the Glue Data Catalog.

      struct CatalogEntry
        include JSON::Serializable

        # The database in which the table metadata resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table in question.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        def initialize(
          @database_name : String,
          @table_name : String
        )
        end
      end

      # Specifies a Hudi data source that is registered in the Glue Data Catalog.

      struct CatalogHudiSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the Hudi data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalHudiOptions")]
        getter additional_hudi_options : Hash(String, String)?

        # Specifies the data schema for the Hudi source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @additional_hudi_options : Hash(String, String)? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies an Apache Iceberg data source that is registered in the Glue Data Catalog.

      struct CatalogIcebergSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the Iceberg data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options for the Iceberg data source.

        @[JSON::Field(key: "AdditionalIcebergOptions")]
        getter additional_iceberg_options : Hash(String, String)?

        # Specifies the data schema for the Iceberg source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @additional_iceberg_options : Hash(String, String)? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # A structure containing migration status information.

      struct CatalogImportStatus
        include JSON::Serializable

        # True if the migration has completed, or False otherwise.

        @[JSON::Field(key: "ImportCompleted")]
        getter import_completed : Bool?

        # The time that the migration was started.

        @[JSON::Field(key: "ImportTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter import_time : Time?

        # The name of the person who initiated the migration.

        @[JSON::Field(key: "ImportedBy")]
        getter imported_by : String?

        def initialize(
          @import_completed : Bool? = nil,
          @import_time : Time? = nil,
          @imported_by : String? = nil
        )
        end
      end

      # A structure that describes catalog properties.

      struct CatalogInput
        include JSON::Serializable

        # Allows third-party engines to access data in Amazon S3 locations that are registered with Lake
        # Formation.

        @[JSON::Field(key: "AllowFullTableExternalDataAccess")]
        getter allow_full_table_external_data_access : String?

        # A CatalogProperties object that specifies data lake access properties and other custom properties.

        @[JSON::Field(key: "CatalogProperties")]
        getter catalog_properties : Types::CatalogProperties?

        # An array of PrincipalPermissions objects. Creates a set of default permissions on the database(s)
        # for principals. Used by Amazon Web Services Lake Formation. Typically should be explicitly set as an
        # empty list.

        @[JSON::Field(key: "CreateDatabaseDefaultPermissions")]
        getter create_database_default_permissions : Array(Types::PrincipalPermissions)?

        # An array of PrincipalPermissions objects. Creates a set of default permissions on the table(s) for
        # principals. Used by Amazon Web Services Lake Formation. Typically should be explicitly set as an
        # empty list.

        @[JSON::Field(key: "CreateTableDefaultPermissions")]
        getter create_table_default_permissions : Array(Types::PrincipalPermissions)?

        # Description string, not more than 2048 bytes long, matching the URI address multi-line string
        # pattern. A description of the catalog.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A FederatedCatalog object. A FederatedCatalog structure that references an entity outside the Glue
        # Data Catalog, for example a Redshift database.

        @[JSON::Field(key: "FederatedCatalog")]
        getter federated_catalog : Types::FederatedCatalog?

        # A map array of key-value pairs that define the parameters and properties of the catalog.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # A TargetRedshiftCatalog object that describes a target catalog for resource linking.

        @[JSON::Field(key: "TargetRedshiftCatalog")]
        getter target_redshift_catalog : Types::TargetRedshiftCatalog?

        def initialize(
          @allow_full_table_external_data_access : String? = nil,
          @catalog_properties : Types::CatalogProperties? = nil,
          @create_database_default_permissions : Array(Types::PrincipalPermissions)? = nil,
          @create_table_default_permissions : Array(Types::PrincipalPermissions)? = nil,
          @description : String? = nil,
          @federated_catalog : Types::FederatedCatalog? = nil,
          @parameters : Hash(String, String)? = nil,
          @target_redshift_catalog : Types::TargetRedshiftCatalog? = nil
        )
        end
      end

      # Specifies an Apache Kafka data store in the Data Catalog.

      struct CatalogKafkaSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data store.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies options related to data preview for viewing a sample of your data.

        @[JSON::Field(key: "DataPreviewOptions")]
        getter data_preview_options : Types::StreamingDataPreviewOptions?

        # Whether to automatically determine the schema from the incoming data.

        @[JSON::Field(key: "DetectSchema")]
        getter detect_schema : Bool?

        # Specifies the streaming options.

        @[JSON::Field(key: "StreamingOptions")]
        getter streaming_options : Types::KafkaStreamingSourceOptions?

        # The amount of time to spend processing each micro batch.

        @[JSON::Field(key: "WindowSize")]
        getter window_size : Int32?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @data_preview_options : Types::StreamingDataPreviewOptions? = nil,
          @detect_schema : Bool? = nil,
          @streaming_options : Types::KafkaStreamingSourceOptions? = nil,
          @window_size : Int32? = nil
        )
        end
      end

      # Specifies a Kinesis data source in the Glue Data Catalog.

      struct CatalogKinesisSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Additional options for data preview.

        @[JSON::Field(key: "DataPreviewOptions")]
        getter data_preview_options : Types::StreamingDataPreviewOptions?

        # Whether to automatically determine the schema from the incoming data.

        @[JSON::Field(key: "DetectSchema")]
        getter detect_schema : Bool?

        # Additional options for the Kinesis streaming data source.

        @[JSON::Field(key: "StreamingOptions")]
        getter streaming_options : Types::KinesisStreamingSourceOptions?

        # The amount of time to spend processing each micro batch.

        @[JSON::Field(key: "WindowSize")]
        getter window_size : Int32?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @data_preview_options : Types::StreamingDataPreviewOptions? = nil,
          @detect_schema : Bool? = nil,
          @streaming_options : Types::KinesisStreamingSourceOptions? = nil,
          @window_size : Int32? = nil
        )
        end
      end

      # A structure that specifies data lake access properties and other custom properties.

      struct CatalogProperties
        include JSON::Serializable

        # Additional key-value properties for the catalog, such as column statistics optimizations.

        @[JSON::Field(key: "CustomProperties")]
        getter custom_properties : Hash(String, String)?

        # A DataLakeAccessProperties object that specifies properties to configure data lake access for your
        # catalog resource in the Glue Data Catalog.

        @[JSON::Field(key: "DataLakeAccessProperties")]
        getter data_lake_access_properties : Types::DataLakeAccessProperties?

        # A structure that specifies Iceberg table optimization properties for the catalog. This includes
        # configuration for compaction, retention, and orphan file deletion operations that can be applied to
        # Iceberg tables in this catalog.

        @[JSON::Field(key: "IcebergOptimizationProperties")]
        getter iceberg_optimization_properties : Types::IcebergOptimizationProperties?

        def initialize(
          @custom_properties : Hash(String, String)? = nil,
          @data_lake_access_properties : Types::DataLakeAccessProperties? = nil,
          @iceberg_optimization_properties : Types::IcebergOptimizationProperties? = nil
        )
        end
      end

      # Property attributes that include configuration properties for the catalog resource.

      struct CatalogPropertiesOutput
        include JSON::Serializable

        # Additional key-value properties for the catalog, such as column statistics optimizations.

        @[JSON::Field(key: "CustomProperties")]
        getter custom_properties : Hash(String, String)?

        # A DataLakeAccessProperties object with input properties to configure data lake access for your
        # catalog resource in the Glue Data Catalog.

        @[JSON::Field(key: "DataLakeAccessProperties")]
        getter data_lake_access_properties : Types::DataLakeAccessPropertiesOutput?

        # An IcebergOptimizationPropertiesOutput object that specifies Iceberg table optimization settings for
        # the catalog, including configurations for compaction, retention, and orphan file deletion
        # operations.

        @[JSON::Field(key: "IcebergOptimizationProperties")]
        getter iceberg_optimization_properties : Types::IcebergOptimizationPropertiesOutput?

        def initialize(
          @custom_properties : Hash(String, String)? = nil,
          @data_lake_access_properties : Types::DataLakeAccessPropertiesOutput? = nil,
          @iceberg_optimization_properties : Types::IcebergOptimizationPropertiesOutput? = nil
        )
        end
      end

      # A policy that specifies update behavior for the crawler.

      struct CatalogSchemaChangePolicy
        include JSON::Serializable

        # Whether to use the specified update behavior when the crawler finds a changed schema.

        @[JSON::Field(key: "EnableUpdateCatalog")]
        getter enable_update_catalog : Bool?

        # The update behavior when the crawler finds a changed schema.

        @[JSON::Field(key: "UpdateBehavior")]
        getter update_behavior : String?

        def initialize(
          @enable_update_catalog : Bool? = nil,
          @update_behavior : String? = nil
        )
        end
      end

      # Specifies a data store in the Glue Data Catalog.

      struct CatalogSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data store.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies the data schema for the catalog source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # Partitions satisfying this predicate are deleted. Files within the retention period in these
        # partitions are not deleted.

        @[JSON::Field(key: "PartitionPredicate")]
        getter partition_predicate : String?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @partition_predicate : String? = nil
        )
        end
      end

      # Specifies an Glue Data Catalog target.

      struct CatalogTarget
        include JSON::Serializable

        # The name of the database to be synchronized.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A list of the tables to be synchronized.

        @[JSON::Field(key: "Tables")]
        getter tables : Array(String)

        # The name of the connection for an Amazon S3-backed Data Catalog table to be a target of the crawl
        # when using a Catalog connection type paired with a NETWORK Connection type.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # A valid Amazon dead-letter SQS ARN. For example, arn:aws:sqs:region:account:deadLetterQueue .

        @[JSON::Field(key: "DlqEventQueueArn")]
        getter dlq_event_queue_arn : String?

        # A valid Amazon SQS ARN. For example, arn:aws:sqs:region:account:sqs .

        @[JSON::Field(key: "EventQueueArn")]
        getter event_queue_arn : String?

        def initialize(
          @database_name : String,
          @tables : Array(String),
          @connection_name : String? = nil,
          @dlq_event_queue_arn : String? = nil,
          @event_queue_arn : String? = nil
        )
        end
      end


      struct CheckSchemaVersionValidityInput
        include JSON::Serializable

        # The data format of the schema definition. Currently AVRO , JSON and PROTOBUF are supported.

        @[JSON::Field(key: "DataFormat")]
        getter data_format : String

        # The definition of the schema that has to be validated.

        @[JSON::Field(key: "SchemaDefinition")]
        getter schema_definition : String

        def initialize(
          @data_format : String,
          @schema_definition : String
        )
        end
      end


      struct CheckSchemaVersionValidityResponse
        include JSON::Serializable

        # A validation failure error message.

        @[JSON::Field(key: "Error")]
        getter error : String?

        # Return true, if the schema is valid and false otherwise.

        @[JSON::Field(key: "Valid")]
        getter valid : Bool?

        def initialize(
          @error : String? = nil,
          @valid : Bool? = nil
        )
        end
      end

      # Classifiers are triggered during a crawl task. A classifier checks whether a given file is in a
      # format it can handle. If it is, the classifier creates a schema in the form of a StructType object
      # that matches that data format. You can use the standard classifiers that Glue provides, or you can
      # write your own classifiers to best categorize your data sources and specify the appropriate schemas
      # to use for them. A classifier can be a grok classifier, an XML classifier, a JSON classifier, or a
      # custom CSV classifier, as specified in one of the fields in the Classifier object.

      struct Classifier
        include JSON::Serializable

        # A classifier for comma-separated values (CSV).

        @[JSON::Field(key: "CsvClassifier")]
        getter csv_classifier : Types::CsvClassifier?

        # A classifier that uses grok .

        @[JSON::Field(key: "GrokClassifier")]
        getter grok_classifier : Types::GrokClassifier?

        # A classifier for JSON content.

        @[JSON::Field(key: "JsonClassifier")]
        getter json_classifier : Types::JsonClassifier?

        # A classifier for XML content.

        @[JSON::Field(key: "XMLClassifier")]
        getter xml_classifier : Types::XMLClassifier?

        def initialize(
          @csv_classifier : Types::CsvClassifier? = nil,
          @grok_classifier : Types::GrokClassifier? = nil,
          @json_classifier : Types::JsonClassifier? = nil,
          @xml_classifier : Types::XMLClassifier? = nil
        )
        end
      end

      # Specifies how Amazon CloudWatch data should be encrypted.

      struct CloudWatchEncryption
        include JSON::Serializable

        # The encryption mode to use for CloudWatch data.

        @[JSON::Field(key: "CloudWatchEncryptionMode")]
        getter cloud_watch_encryption_mode : String?

        # The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.

        @[JSON::Field(key: "KmsKeyArn")]
        getter kms_key_arn : String?

        def initialize(
          @cloud_watch_encryption_mode : String? = nil,
          @kms_key_arn : String? = nil
        )
        end
      end

      # CodeGenConfigurationNode enumerates all valid Node types. One and only one of its member variables
      # can be populated.

      struct CodeGenConfigurationNode
        include JSON::Serializable

        # Specifies a transform that groups rows by chosen fields and computes the aggregated value by
        # specified function.

        @[JSON::Field(key: "Aggregate")]
        getter aggregate : Types::Aggregate?

        # Specifies a target that writes to a data source in Amazon Redshift.

        @[JSON::Field(key: "AmazonRedshiftSource")]
        getter amazon_redshift_source : Types::AmazonRedshiftSource?

        # Specifies a target that writes to a data target in Amazon Redshift.

        @[JSON::Field(key: "AmazonRedshiftTarget")]
        getter amazon_redshift_target : Types::AmazonRedshiftTarget?

        # Specifies a transform that maps data property keys in the data source to data property keys in the
        # data target. You can rename keys, modify the data types for keys, and choose which keys to drop from
        # the dataset.

        @[JSON::Field(key: "ApplyMapping")]
        getter apply_mapping : Types::ApplyMapping?

        # Specifies a connector to an Amazon Athena data source.

        @[JSON::Field(key: "AthenaConnectorSource")]
        getter athena_connector_source : Types::AthenaConnectorSource?

        # Specifies a Delta Lake data source that is registered in the Glue Data Catalog.

        @[JSON::Field(key: "CatalogDeltaSource")]
        getter catalog_delta_source : Types::CatalogDeltaSource?

        # Specifies a Hudi data source that is registered in the Glue Data Catalog.

        @[JSON::Field(key: "CatalogHudiSource")]
        getter catalog_hudi_source : Types::CatalogHudiSource?

        # Specifies an Apache Iceberg data source that is registered in the Glue Data Catalog.

        @[JSON::Field(key: "CatalogIcebergSource")]
        getter catalog_iceberg_source : Types::CatalogIcebergSource?

        # Specifies an Apache Kafka data store in the Data Catalog.

        @[JSON::Field(key: "CatalogKafkaSource")]
        getter catalog_kafka_source : Types::CatalogKafkaSource?

        # Specifies a Kinesis data source in the Glue Data Catalog.

        @[JSON::Field(key: "CatalogKinesisSource")]
        getter catalog_kinesis_source : Types::CatalogKinesisSource?

        # Specifies a data store in the Glue Data Catalog.

        @[JSON::Field(key: "CatalogSource")]
        getter catalog_source : Types::CatalogSource?

        # Specifies a target that uses a Glue Data Catalog table.

        @[JSON::Field(key: "CatalogTarget")]
        getter catalog_target : Types::BasicCatalogTarget?

        # Specifies a source generated with standard connection options.

        @[JSON::Field(key: "ConnectorDataSource")]
        getter connector_data_source : Types::ConnectorDataSource?

        # Specifies a target generated with standard connection options.

        @[JSON::Field(key: "ConnectorDataTarget")]
        getter connector_data_target : Types::ConnectorDataTarget?

        # Specifies a transform that uses custom code you provide to perform the data transformation. The
        # output is a collection of DynamicFrames.

        @[JSON::Field(key: "CustomCode")]
        getter custom_code : Types::CustomCode?


        @[JSON::Field(key: "DirectJDBCSource")]
        getter direct_jdbc_source : Types::DirectJDBCSource?

        # Specifies an Apache Kafka data store.

        @[JSON::Field(key: "DirectKafkaSource")]
        getter direct_kafka_source : Types::DirectKafkaSource?

        # Specifies a direct Amazon Kinesis data source.

        @[JSON::Field(key: "DirectKinesisSource")]
        getter direct_kinesis_source : Types::DirectKinesisSource?

        # Specifies a transform that removes rows of repeating data from a data set.

        @[JSON::Field(key: "DropDuplicates")]
        getter drop_duplicates : Types::DropDuplicates?

        # Specifies a transform that chooses the data property keys that you want to drop.

        @[JSON::Field(key: "DropFields")]
        getter drop_fields : Types::DropFields?

        # Specifies a transform that removes columns from the dataset if all values in the column are 'null'.
        # By default, Glue Studio will recognize null objects, but some values such as empty strings, strings
        # that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized
        # as nulls.

        @[JSON::Field(key: "DropNullFields")]
        getter drop_null_fields : Types::DropNullFields?

        # Specifies a custom visual transform created by a user.

        @[JSON::Field(key: "DynamicTransform")]
        getter dynamic_transform : Types::DynamicTransform?

        # Specifies a DynamoDBC Catalog data store in the Glue Data Catalog.

        @[JSON::Field(key: "DynamoDBCatalogSource")]
        getter dynamo_db_catalog_source : Types::DynamoDBCatalogSource?

        # Specifies a DynamoDB ELT connector source for extracting data from DynamoDB tables.

        @[JSON::Field(key: "DynamoDBELTConnectorSource")]
        getter dynamo_dbelt_connector_source : Types::DynamoDBELTConnectorSource?

        # Specifies your data quality evaluation criteria.

        @[JSON::Field(key: "EvaluateDataQuality")]
        getter evaluate_data_quality : Types::EvaluateDataQuality?

        # Specifies your data quality evaluation criteria. Allows multiple input data and returns a collection
        # of Dynamic Frames.

        @[JSON::Field(key: "EvaluateDataQualityMultiFrame")]
        getter evaluate_data_quality_multi_frame : Types::EvaluateDataQualityMultiFrame?

        # Specifies a transform that locates records in the dataset that have missing values and adds a new
        # field with a value determined by imputation. The input data set is used to train the machine
        # learning model that determines what the missing value should be.

        @[JSON::Field(key: "FillMissingValues")]
        getter fill_missing_values : Types::FillMissingValues?

        # Specifies a transform that splits a dataset into two, based on a filter condition.

        @[JSON::Field(key: "Filter")]
        getter filter : Types::Filter?

        # Specifies a data source in a goverened Data Catalog.

        @[JSON::Field(key: "GovernedCatalogSource")]
        getter governed_catalog_source : Types::GovernedCatalogSource?

        # Specifies a data target that writes to a goverened catalog.

        @[JSON::Field(key: "GovernedCatalogTarget")]
        getter governed_catalog_target : Types::GovernedCatalogTarget?

        # Specifies a connector to a JDBC data source.

        @[JSON::Field(key: "JDBCConnectorSource")]
        getter jdbc_connector_source : Types::JDBCConnectorSource?

        # Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.

        @[JSON::Field(key: "JDBCConnectorTarget")]
        getter jdbc_connector_target : Types::JDBCConnectorTarget?

        # Specifies a transform that joins two datasets into one dataset using a comparison phrase on the
        # specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.

        @[JSON::Field(key: "Join")]
        getter join : Types::Join?

        # Specifies a transform that merges a DynamicFrame with a staging DynamicFrame based on the specified
        # primary keys to identify records. Duplicate records (records with the same primary keys) are not
        # de-duplicated.

        @[JSON::Field(key: "Merge")]
        getter merge : Types::Merge?

        # Specifies a Microsoft SQL server data source in the Glue Data Catalog.

        @[JSON::Field(key: "MicrosoftSQLServerCatalogSource")]
        getter microsoft_sql_server_catalog_source : Types::MicrosoftSQLServerCatalogSource?

        # Specifies a target that uses Microsoft SQL.

        @[JSON::Field(key: "MicrosoftSQLServerCatalogTarget")]
        getter microsoft_sql_server_catalog_target : Types::MicrosoftSQLServerCatalogTarget?

        # Specifies a MySQL data source in the Glue Data Catalog.

        @[JSON::Field(key: "MySQLCatalogSource")]
        getter my_sql_catalog_source : Types::MySQLCatalogSource?

        # Specifies a target that uses MySQL.

        @[JSON::Field(key: "MySQLCatalogTarget")]
        getter my_sql_catalog_target : Types::MySQLCatalogTarget?

        # Specifies an Oracle data source in the Glue Data Catalog.

        @[JSON::Field(key: "OracleSQLCatalogSource")]
        getter oracle_sql_catalog_source : Types::OracleSQLCatalogSource?

        # Specifies a target that uses Oracle SQL.

        @[JSON::Field(key: "OracleSQLCatalogTarget")]
        getter oracle_sql_catalog_target : Types::OracleSQLCatalogTarget?

        # Specifies a transform that identifies, removes or masks PII data.

        @[JSON::Field(key: "PIIDetection")]
        getter pii_detection : Types::PIIDetection?

        # Specifies a PostgresSQL data source in the Glue Data Catalog.

        @[JSON::Field(key: "PostgreSQLCatalogSource")]
        getter postgre_sql_catalog_source : Types::PostgreSQLCatalogSource?

        # Specifies a target that uses Postgres SQL.

        @[JSON::Field(key: "PostgreSQLCatalogTarget")]
        getter postgre_sql_catalog_target : Types::PostgreSQLCatalogTarget?

        # Specifies a Glue DataBrew recipe node.

        @[JSON::Field(key: "Recipe")]
        getter recipe : Types::Recipe?

        # Specifies an Amazon Redshift data store.

        @[JSON::Field(key: "RedshiftSource")]
        getter redshift_source : Types::RedshiftSource?

        # Specifies a target that uses Amazon Redshift.

        @[JSON::Field(key: "RedshiftTarget")]
        getter redshift_target : Types::RedshiftTarget?

        # Specifies a relational catalog data store in the Glue Data Catalog.

        @[JSON::Field(key: "RelationalCatalogSource")]
        getter relational_catalog_source : Types::RelationalCatalogSource?

        # Specifies a transform that renames a single data property key.

        @[JSON::Field(key: "RenameField")]
        getter rename_field : Types::RenameField?

        # Specifies a route node that directs data to different output paths based on defined filtering
        # conditions.

        @[JSON::Field(key: "Route")]
        getter route : Types::Route?

        # Specifies a Delta Lake data source that is registered in the Glue Data Catalog. The data source must
        # be stored in Amazon S3.

        @[JSON::Field(key: "S3CatalogDeltaSource")]
        getter s3_catalog_delta_source : Types::S3CatalogDeltaSource?

        # Specifies a Hudi data source that is registered in the Glue Data Catalog. The data source must be
        # stored in Amazon S3.

        @[JSON::Field(key: "S3CatalogHudiSource")]
        getter s3_catalog_hudi_source : Types::S3CatalogHudiSource?

        # Specifies an Apache Iceberg data source that is registered in the Glue Data Catalog. The Iceberg
        # data source must be stored in Amazon S3.

        @[JSON::Field(key: "S3CatalogIcebergSource")]
        getter s3_catalog_iceberg_source : Types::S3CatalogIcebergSource?

        # Specifies an Amazon S3 data store in the Glue Data Catalog.

        @[JSON::Field(key: "S3CatalogSource")]
        getter s3_catalog_source : Types::S3CatalogSource?

        # Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.

        @[JSON::Field(key: "S3CatalogTarget")]
        getter s3_catalog_target : Types::S3CatalogTarget?

        # Specifies a command-separated value (CSV) data store stored in Amazon S3.

        @[JSON::Field(key: "S3CsvSource")]
        getter s3_csv_source : Types::S3CsvSource?

        # Specifies a target that writes to a Delta Lake data source in the Glue Data Catalog.

        @[JSON::Field(key: "S3DeltaCatalogTarget")]
        getter s3_delta_catalog_target : Types::S3DeltaCatalogTarget?

        # Specifies a target that writes to a Delta Lake data source in Amazon S3.

        @[JSON::Field(key: "S3DeltaDirectTarget")]
        getter s3_delta_direct_target : Types::S3DeltaDirectTarget?

        # Specifies a Delta Lake data source stored in Amazon S3.

        @[JSON::Field(key: "S3DeltaSource")]
        getter s3_delta_source : Types::S3DeltaSource?

        # Specifies a data target that writes to Amazon S3.

        @[JSON::Field(key: "S3DirectTarget")]
        getter s3_direct_target : Types::S3DirectTarget?

        # Defines configuration parameters for reading Excel files from Amazon S3.

        @[JSON::Field(key: "S3ExcelSource")]
        getter s3_excel_source : Types::S3ExcelSource?

        # Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.

        @[JSON::Field(key: "S3GlueParquetTarget")]
        getter s3_glue_parquet_target : Types::S3GlueParquetTarget?

        # Specifies a target that writes to a Hudi data source in the Glue Data Catalog.

        @[JSON::Field(key: "S3HudiCatalogTarget")]
        getter s3_hudi_catalog_target : Types::S3HudiCatalogTarget?

        # Specifies a target that writes to a Hudi data source in Amazon S3.

        @[JSON::Field(key: "S3HudiDirectTarget")]
        getter s3_hudi_direct_target : Types::S3HudiDirectTarget?

        # Specifies a Hudi data source stored in Amazon S3.

        @[JSON::Field(key: "S3HudiSource")]
        getter s3_hudi_source : Types::S3HudiSource?

        # Defines configuration parameters for writing data to Amazon S3 using HyperDirect optimization.

        @[JSON::Field(key: "S3HyperDirectTarget")]
        getter s3_hyper_direct_target : Types::S3HyperDirectTarget?

        # Specifies an Apache Iceberg catalog target that writes data to Amazon S3 and registers the table in
        # the Glue Data Catalog.

        @[JSON::Field(key: "S3IcebergCatalogTarget")]
        getter s3_iceberg_catalog_target : Types::S3IcebergCatalogTarget?

        # Defines configuration parameters for writing data to Amazon S3 as an Apache Iceberg table.

        @[JSON::Field(key: "S3IcebergDirectTarget")]
        getter s3_iceberg_direct_target : Types::S3IcebergDirectTarget?

        # Specifies a JSON data store stored in Amazon S3.

        @[JSON::Field(key: "S3JsonSource")]
        getter s3_json_source : Types::S3JsonSource?

        # Specifies an Apache Parquet data store stored in Amazon S3.

        @[JSON::Field(key: "S3ParquetSource")]
        getter s3_parquet_source : Types::S3ParquetSource?

        # Specifies a transform that chooses the data property keys that you want to keep.

        @[JSON::Field(key: "SelectFields")]
        getter select_fields : Types::SelectFields?

        # Specifies a transform that chooses one DynamicFrame from a collection of DynamicFrames . The output
        # is the selected DynamicFrame

        @[JSON::Field(key: "SelectFromCollection")]
        getter select_from_collection : Types::SelectFromCollection?

        # Specifies a Snowflake data source.

        @[JSON::Field(key: "SnowflakeSource")]
        getter snowflake_source : Types::SnowflakeSource?

        # Specifies a target that writes to a Snowflake data source.

        @[JSON::Field(key: "SnowflakeTarget")]
        getter snowflake_target : Types::SnowflakeTarget?

        # Specifies a connector to an Apache Spark data source.

        @[JSON::Field(key: "SparkConnectorSource")]
        getter spark_connector_source : Types::SparkConnectorSource?

        # Specifies a target that uses an Apache Spark connector.

        @[JSON::Field(key: "SparkConnectorTarget")]
        getter spark_connector_target : Types::SparkConnectorTarget?

        # Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The
        # output is a single DynamicFrame .

        @[JSON::Field(key: "SparkSQL")]
        getter spark_sql : Types::SparkSQL?

        # Specifies a transform that writes samples of the data to an Amazon S3 bucket.

        @[JSON::Field(key: "Spigot")]
        getter spigot : Types::Spigot?

        # Specifies a transform that splits data property keys into two DynamicFrames . The output is a
        # collection of DynamicFrames : one with selected data property keys, and one with the remaining data
        # property keys.

        @[JSON::Field(key: "SplitFields")]
        getter split_fields : Types::SplitFields?

        # Specifies a transform that combines the rows from two or more datasets into a single result.

        @[JSON::Field(key: "Union")]
        getter union : Types::Union?

        def initialize(
          @aggregate : Types::Aggregate? = nil,
          @amazon_redshift_source : Types::AmazonRedshiftSource? = nil,
          @amazon_redshift_target : Types::AmazonRedshiftTarget? = nil,
          @apply_mapping : Types::ApplyMapping? = nil,
          @athena_connector_source : Types::AthenaConnectorSource? = nil,
          @catalog_delta_source : Types::CatalogDeltaSource? = nil,
          @catalog_hudi_source : Types::CatalogHudiSource? = nil,
          @catalog_iceberg_source : Types::CatalogIcebergSource? = nil,
          @catalog_kafka_source : Types::CatalogKafkaSource? = nil,
          @catalog_kinesis_source : Types::CatalogKinesisSource? = nil,
          @catalog_source : Types::CatalogSource? = nil,
          @catalog_target : Types::BasicCatalogTarget? = nil,
          @connector_data_source : Types::ConnectorDataSource? = nil,
          @connector_data_target : Types::ConnectorDataTarget? = nil,
          @custom_code : Types::CustomCode? = nil,
          @direct_jdbc_source : Types::DirectJDBCSource? = nil,
          @direct_kafka_source : Types::DirectKafkaSource? = nil,
          @direct_kinesis_source : Types::DirectKinesisSource? = nil,
          @drop_duplicates : Types::DropDuplicates? = nil,
          @drop_fields : Types::DropFields? = nil,
          @drop_null_fields : Types::DropNullFields? = nil,
          @dynamic_transform : Types::DynamicTransform? = nil,
          @dynamo_db_catalog_source : Types::DynamoDBCatalogSource? = nil,
          @dynamo_dbelt_connector_source : Types::DynamoDBELTConnectorSource? = nil,
          @evaluate_data_quality : Types::EvaluateDataQuality? = nil,
          @evaluate_data_quality_multi_frame : Types::EvaluateDataQualityMultiFrame? = nil,
          @fill_missing_values : Types::FillMissingValues? = nil,
          @filter : Types::Filter? = nil,
          @governed_catalog_source : Types::GovernedCatalogSource? = nil,
          @governed_catalog_target : Types::GovernedCatalogTarget? = nil,
          @jdbc_connector_source : Types::JDBCConnectorSource? = nil,
          @jdbc_connector_target : Types::JDBCConnectorTarget? = nil,
          @join : Types::Join? = nil,
          @merge : Types::Merge? = nil,
          @microsoft_sql_server_catalog_source : Types::MicrosoftSQLServerCatalogSource? = nil,
          @microsoft_sql_server_catalog_target : Types::MicrosoftSQLServerCatalogTarget? = nil,
          @my_sql_catalog_source : Types::MySQLCatalogSource? = nil,
          @my_sql_catalog_target : Types::MySQLCatalogTarget? = nil,
          @oracle_sql_catalog_source : Types::OracleSQLCatalogSource? = nil,
          @oracle_sql_catalog_target : Types::OracleSQLCatalogTarget? = nil,
          @pii_detection : Types::PIIDetection? = nil,
          @postgre_sql_catalog_source : Types::PostgreSQLCatalogSource? = nil,
          @postgre_sql_catalog_target : Types::PostgreSQLCatalogTarget? = nil,
          @recipe : Types::Recipe? = nil,
          @redshift_source : Types::RedshiftSource? = nil,
          @redshift_target : Types::RedshiftTarget? = nil,
          @relational_catalog_source : Types::RelationalCatalogSource? = nil,
          @rename_field : Types::RenameField? = nil,
          @route : Types::Route? = nil,
          @s3_catalog_delta_source : Types::S3CatalogDeltaSource? = nil,
          @s3_catalog_hudi_source : Types::S3CatalogHudiSource? = nil,
          @s3_catalog_iceberg_source : Types::S3CatalogIcebergSource? = nil,
          @s3_catalog_source : Types::S3CatalogSource? = nil,
          @s3_catalog_target : Types::S3CatalogTarget? = nil,
          @s3_csv_source : Types::S3CsvSource? = nil,
          @s3_delta_catalog_target : Types::S3DeltaCatalogTarget? = nil,
          @s3_delta_direct_target : Types::S3DeltaDirectTarget? = nil,
          @s3_delta_source : Types::S3DeltaSource? = nil,
          @s3_direct_target : Types::S3DirectTarget? = nil,
          @s3_excel_source : Types::S3ExcelSource? = nil,
          @s3_glue_parquet_target : Types::S3GlueParquetTarget? = nil,
          @s3_hudi_catalog_target : Types::S3HudiCatalogTarget? = nil,
          @s3_hudi_direct_target : Types::S3HudiDirectTarget? = nil,
          @s3_hudi_source : Types::S3HudiSource? = nil,
          @s3_hyper_direct_target : Types::S3HyperDirectTarget? = nil,
          @s3_iceberg_catalog_target : Types::S3IcebergCatalogTarget? = nil,
          @s3_iceberg_direct_target : Types::S3IcebergDirectTarget? = nil,
          @s3_json_source : Types::S3JsonSource? = nil,
          @s3_parquet_source : Types::S3ParquetSource? = nil,
          @select_fields : Types::SelectFields? = nil,
          @select_from_collection : Types::SelectFromCollection? = nil,
          @snowflake_source : Types::SnowflakeSource? = nil,
          @snowflake_target : Types::SnowflakeTarget? = nil,
          @spark_connector_source : Types::SparkConnectorSource? = nil,
          @spark_connector_target : Types::SparkConnectorTarget? = nil,
          @spark_sql : Types::SparkSQL? = nil,
          @spigot : Types::Spigot? = nil,
          @split_fields : Types::SplitFields? = nil,
          @union : Types::Union? = nil
        )
        end
      end

      # Represents a directional edge in a directed acyclic graph (DAG).

      struct CodeGenEdge
        include JSON::Serializable

        # The ID of the node at which the edge starts.

        @[JSON::Field(key: "Source")]
        getter source : String

        # The ID of the node at which the edge ends.

        @[JSON::Field(key: "Target")]
        getter target : String

        # The target of the edge.

        @[JSON::Field(key: "TargetParameter")]
        getter target_parameter : String?

        def initialize(
          @source : String,
          @target : String,
          @target_parameter : String? = nil
        )
        end
      end

      # Represents a node in a directed acyclic graph (DAG)

      struct CodeGenNode
        include JSON::Serializable

        # Properties of the node, in the form of name-value pairs.

        @[JSON::Field(key: "Args")]
        getter args : Array(Types::CodeGenNodeArg)

        # A node identifier that is unique within the node's graph.

        @[JSON::Field(key: "Id")]
        getter id : String

        # The type of node that this is.

        @[JSON::Field(key: "NodeType")]
        getter node_type : String

        # The line number of the node.

        @[JSON::Field(key: "LineNumber")]
        getter line_number : Int32?

        def initialize(
          @args : Array(Types::CodeGenNodeArg),
          @id : String,
          @node_type : String,
          @line_number : Int32? = nil
        )
        end
      end

      # An argument or property of a node.

      struct CodeGenNodeArg
        include JSON::Serializable

        # The name of the argument or property.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The value of the argument or property.

        @[JSON::Field(key: "Value")]
        getter value : String

        # True if the value is used as a parameter.

        @[JSON::Field(key: "Param")]
        getter param : Bool?

        def initialize(
          @name : String,
          @value : String,
          @param : Bool? = nil
        )
        end
      end

      # A column in a Table .

      struct Column
        include JSON::Serializable

        # The name of the Column .

        @[JSON::Field(key: "Name")]
        getter name : String

        # A free-form text comment.

        @[JSON::Field(key: "Comment")]
        getter comment : String?

        # These key-value pairs define properties associated with the column.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # The data type of the Column .

        @[JSON::Field(key: "Type")]
        getter type : String?

        def initialize(
          @name : String,
          @comment : String? = nil,
          @parameters : Hash(String, String)? = nil,
          @type : String? = nil
        )
        end
      end

      # Encapsulates a column name that failed and the reason for failure.

      struct ColumnError
        include JSON::Serializable

        # The name of the column that failed.

        @[JSON::Field(key: "ColumnName")]
        getter column_name : String?

        # An error message with the reason for the failure of an operation.

        @[JSON::Field(key: "Error")]
        getter error : Types::ErrorDetail?

        def initialize(
          @column_name : String? = nil,
          @error : Types::ErrorDetail? = nil
        )
        end
      end

      # A structure containing the column name and column importance score for a column. Column importance
      # helps you understand how columns contribute to your model, by identifying which columns in your
      # records are more important than others.

      struct ColumnImportance
        include JSON::Serializable

        # The name of a column.

        @[JSON::Field(key: "ColumnName")]
        getter column_name : String?

        # The column importance score for the column, as a decimal.

        @[JSON::Field(key: "Importance")]
        getter importance : Float64?

        def initialize(
          @column_name : String? = nil,
          @importance : Float64? = nil
        )
        end
      end

      # A filter that uses both column-level and row-level filtering.

      struct ColumnRowFilter
        include JSON::Serializable

        # A string containing the name of the column.

        @[JSON::Field(key: "ColumnName")]
        getter column_name : String?

        # A string containing the row-level filter expression.

        @[JSON::Field(key: "RowFilterExpression")]
        getter row_filter_expression : String?

        def initialize(
          @column_name : String? = nil,
          @row_filter_expression : String? = nil
        )
        end
      end

      # Represents the generated column-level statistics for a table or partition.

      struct ColumnStatistics
        include JSON::Serializable

        # The timestamp of when column statistics were generated.

        @[JSON::Field(key: "AnalyzedTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter analyzed_time : Time

        # Name of column which statistics belong to.

        @[JSON::Field(key: "ColumnName")]
        getter column_name : String

        # The data type of the column.

        @[JSON::Field(key: "ColumnType")]
        getter column_type : String

        # A ColumnStatisticData object that contains the statistics data values.

        @[JSON::Field(key: "StatisticsData")]
        getter statistics_data : Types::ColumnStatisticsData

        def initialize(
          @analyzed_time : Time,
          @column_name : String,
          @column_type : String,
          @statistics_data : Types::ColumnStatisticsData
        )
        end
      end

      # Contains the individual types of column statistics data. Only one data object should be set and
      # indicated by the Type attribute.

      struct ColumnStatisticsData
        include JSON::Serializable

        # The type of column statistics data.

        @[JSON::Field(key: "Type")]
        getter type : String

        # Binary column statistics data.

        @[JSON::Field(key: "BinaryColumnStatisticsData")]
        getter binary_column_statistics_data : Types::BinaryColumnStatisticsData?

        # Boolean column statistics data.

        @[JSON::Field(key: "BooleanColumnStatisticsData")]
        getter boolean_column_statistics_data : Types::BooleanColumnStatisticsData?

        # Date column statistics data.

        @[JSON::Field(key: "DateColumnStatisticsData")]
        getter date_column_statistics_data : Types::DateColumnStatisticsData?

        # Decimal column statistics data. UnscaledValues within are Base64-encoded binary objects storing
        # big-endian, two's complement representations of the decimal's unscaled value.

        @[JSON::Field(key: "DecimalColumnStatisticsData")]
        getter decimal_column_statistics_data : Types::DecimalColumnStatisticsData?

        # Double column statistics data.

        @[JSON::Field(key: "DoubleColumnStatisticsData")]
        getter double_column_statistics_data : Types::DoubleColumnStatisticsData?

        # Long column statistics data.

        @[JSON::Field(key: "LongColumnStatisticsData")]
        getter long_column_statistics_data : Types::LongColumnStatisticsData?

        # String column statistics data.

        @[JSON::Field(key: "StringColumnStatisticsData")]
        getter string_column_statistics_data : Types::StringColumnStatisticsData?

        def initialize(
          @type : String,
          @binary_column_statistics_data : Types::BinaryColumnStatisticsData? = nil,
          @boolean_column_statistics_data : Types::BooleanColumnStatisticsData? = nil,
          @date_column_statistics_data : Types::DateColumnStatisticsData? = nil,
          @decimal_column_statistics_data : Types::DecimalColumnStatisticsData? = nil,
          @double_column_statistics_data : Types::DoubleColumnStatisticsData? = nil,
          @long_column_statistics_data : Types::LongColumnStatisticsData? = nil,
          @string_column_statistics_data : Types::StringColumnStatisticsData? = nil
        )
        end
      end

      # Encapsulates a ColumnStatistics object that failed and the reason for failure.

      struct ColumnStatisticsError
        include JSON::Serializable

        # The ColumnStatistics of the column.

        @[JSON::Field(key: "ColumnStatistics")]
        getter column_statistics : Types::ColumnStatistics?

        # An error message with the reason for the failure of an operation.

        @[JSON::Field(key: "Error")]
        getter error : Types::ErrorDetail?

        def initialize(
          @column_statistics : Types::ColumnStatistics? = nil,
          @error : Types::ErrorDetail? = nil
        )
        end
      end

      # An exception thrown when you try to stop a task run when there is no task running.

      struct ColumnStatisticsTaskNotRunningException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The object that shows the details of the column stats run.

      struct ColumnStatisticsTaskRun
        include JSON::Serializable

        # The ID of the Data Catalog where the table resides. If none is supplied, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogID")]
        getter catalog_id : String?

        # A list of the column names. If none is supplied, all column names for the table will be used by
        # default.

        @[JSON::Field(key: "ColumnNameList")]
        getter column_name_list : Array(String)?

        # The identifier for the particular column statistics task run.

        @[JSON::Field(key: "ColumnStatisticsTaskRunId")]
        getter column_statistics_task_run_id : String?

        # The type of column statistics computation.

        @[JSON::Field(key: "ComputationType")]
        getter computation_type : String?

        # The time that this task was created.

        @[JSON::Field(key: "CreationTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter creation_time : Time?

        # The Amazon Web Services account ID.

        @[JSON::Field(key: "CustomerId")]
        getter customer_id : String?

        # The calculated DPU usage in seconds for all autoscaled workers.

        @[JSON::Field(key: "DPUSeconds")]
        getter dpu_seconds : Float64?

        # The database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # The end time of the task.

        @[JSON::Field(key: "EndTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter end_time : Time?

        # The error message for the job.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # The last point in time when this task was modified.

        @[JSON::Field(key: "LastUpdated", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_updated : Time?

        # The number of workers used to generate column statistics. The job is preconfigured to autoscale up
        # to 25 instances.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The IAM role that the service assumes to generate statistics.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # The percentage of rows used to generate statistics. If none is supplied, the entire table will be
        # used to generate stats.

        @[JSON::Field(key: "SampleSize")]
        getter sample_size : Float64?

        # Name of the security configuration that is used to encrypt CloudWatch logs for the column stats task
        # run.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The start time of the task.

        @[JSON::Field(key: "StartTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter start_time : Time?

        # The status of the task run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The name of the table for which column statistics is generated.

        @[JSON::Field(key: "TableName")]
        getter table_name : String?

        # The type of workers being used for generating stats. The default is g.1x .

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @catalog_id : String? = nil,
          @column_name_list : Array(String)? = nil,
          @column_statistics_task_run_id : String? = nil,
          @computation_type : String? = nil,
          @creation_time : Time? = nil,
          @customer_id : String? = nil,
          @dpu_seconds : Float64? = nil,
          @database_name : String? = nil,
          @end_time : Time? = nil,
          @error_message : String? = nil,
          @last_updated : Time? = nil,
          @number_of_workers : Int32? = nil,
          @role : String? = nil,
          @sample_size : Float64? = nil,
          @security_configuration : String? = nil,
          @start_time : Time? = nil,
          @status : String? = nil,
          @table_name : String? = nil,
          @worker_type : String? = nil
        )
        end
      end

      # An exception thrown when you try to start another job while running a column stats generation job.

      struct ColumnStatisticsTaskRunningException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The settings for a column statistics task.

      struct ColumnStatisticsTaskSettings
        include JSON::Serializable

        # The ID of the Data Catalog in which the database resides.

        @[JSON::Field(key: "CatalogID")]
        getter catalog_id : String?

        # A list of column names for which to run statistics.

        @[JSON::Field(key: "ColumnNameList")]
        getter column_name_list : Array(String)?

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # The last ExecutionAttempt for the column statistics task run.

        @[JSON::Field(key: "LastExecutionAttempt")]
        getter last_execution_attempt : Types::ExecutionAttempt?

        # The role used for running the column statistics.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # The percentage of data to sample.

        @[JSON::Field(key: "SampleSize")]
        getter sample_size : Float64?

        # A schedule for running the column statistics, specified in CRON syntax.

        @[JSON::Field(key: "Schedule")]
        getter schedule : Types::Schedule?

        # The type of schedule for a column statistics task. Possible values may be CRON or AUTO .

        @[JSON::Field(key: "ScheduleType")]
        getter schedule_type : String?

        # Name of the security configuration that is used to encrypt CloudWatch logs.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The source of setting the column statistics task. Possible values may be CATALOG or TABLE .

        @[JSON::Field(key: "SettingSource")]
        getter setting_source : String?

        # The name of the table for which to generate column statistics.

        @[JSON::Field(key: "TableName")]
        getter table_name : String?

        def initialize(
          @catalog_id : String? = nil,
          @column_name_list : Array(String)? = nil,
          @database_name : String? = nil,
          @last_execution_attempt : Types::ExecutionAttempt? = nil,
          @role : String? = nil,
          @sample_size : Float64? = nil,
          @schedule : Types::Schedule? = nil,
          @schedule_type : String? = nil,
          @security_configuration : String? = nil,
          @setting_source : String? = nil,
          @table_name : String? = nil
        )
        end
      end

      # An exception thrown when you try to stop a task run.

      struct ColumnStatisticsTaskStoppingException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The configuration for a compaction optimizer. This configuration defines how data files in your
      # table will be compacted to improve query performance and reduce storage costs.

      struct CompactionConfiguration
        include JSON::Serializable

        # The configuration for an Iceberg compaction optimizer.

        @[JSON::Field(key: "icebergConfiguration")]
        getter iceberg_configuration : Types::IcebergCompactionConfiguration?

        def initialize(
          @iceberg_configuration : Types::IcebergCompactionConfiguration? = nil
        )
        end
      end

      # A structure that contains compaction metrics for the optimizer run.

      struct CompactionMetrics
        include JSON::Serializable

        # A structure containing the Iceberg compaction metrics for the optimizer run.

        @[JSON::Field(key: "IcebergMetrics")]
        getter iceberg_metrics : Types::IcebergCompactionMetrics?

        def initialize(
          @iceberg_metrics : Types::IcebergCompactionMetrics? = nil
        )
        end
      end

      # An object containing configuration for a compute environment (such as Spark, Python or Athena)
      # returned by the DescribeConnectionType API.

      struct ComputeEnvironmentConfiguration
        include JSON::Serializable

        # The type of compute environment.

        @[JSON::Field(key: "ComputeEnvironment")]
        getter compute_environment : String

        # The connection option name overrides for the compute environment.

        @[JSON::Field(key: "ConnectionOptionNameOverrides")]
        getter connection_option_name_overrides : Hash(String, String)

        # The parameters used as connection options for the compute environment.

        @[JSON::Field(key: "ConnectionOptions")]
        getter connection_options : Hash(String, Types::Property)

        # The connection properties that are required as overrides for the compute environment.

        @[JSON::Field(key: "ConnectionPropertiesRequiredOverrides")]
        getter connection_properties_required_overrides : Array(String)

        # The connection property name overrides for the compute environment.

        @[JSON::Field(key: "ConnectionPropertyNameOverrides")]
        getter connection_property_name_overrides : Hash(String, String)

        # A description of the compute environment.

        @[JSON::Field(key: "Description")]
        getter description : String

        # A name for the compute environment configuration.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The supported authentication types for the compute environment.

        @[JSON::Field(key: "SupportedAuthenticationTypes")]
        getter supported_authentication_types : Array(String)

        # Indicates whether PhysicalConnectionProperties are required for the compute environment.

        @[JSON::Field(key: "PhysicalConnectionPropertiesRequired")]
        getter physical_connection_properties_required : Bool?

        def initialize(
          @compute_environment : String,
          @connection_option_name_overrides : Hash(String, String),
          @connection_options : Hash(String, Types::Property),
          @connection_properties_required_overrides : Array(String),
          @connection_property_name_overrides : Hash(String, String),
          @description : String,
          @name : String,
          @supported_authentication_types : Array(String),
          @physical_connection_properties_required : Bool? = nil
        )
        end
      end

      # Two processes are trying to modify a resource simultaneously.

      struct ConcurrentModificationException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Too many jobs are being run concurrently.

      struct ConcurrentRunsExceededException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Defines a condition under which a trigger fires.

      struct Condition
        include JSON::Serializable

        # The state of the crawler to which this condition applies.

        @[JSON::Field(key: "CrawlState")]
        getter crawl_state : String?

        # The name of the crawler to which this condition applies.

        @[JSON::Field(key: "CrawlerName")]
        getter crawler_name : String?

        # The name of the job whose JobRuns this condition applies to, and on which this trigger waits.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # A logical operator.

        @[JSON::Field(key: "LogicalOperator")]
        getter logical_operator : String?

        # The condition state. Currently, the only job states that a trigger can listen for are SUCCEEDED ,
        # STOPPED , FAILED , and TIMEOUT . The only crawler states that a trigger can listen for are SUCCEEDED
        # , FAILED , and CANCELLED .

        @[JSON::Field(key: "State")]
        getter state : String?

        def initialize(
          @crawl_state : String? = nil,
          @crawler_name : String? = nil,
          @job_name : String? = nil,
          @logical_operator : String? = nil,
          @state : String? = nil
        )
        end
      end

      # A specified condition was not satisfied.

      struct ConditionCheckFailureException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Condition expression defined in the Glue Studio data preparation recipe node.

      struct ConditionExpression
        include JSON::Serializable

        # The condition of the condition expression.

        @[JSON::Field(key: "Condition")]
        getter condition : String

        # The target column of the condition expressions.

        @[JSON::Field(key: "TargetColumn")]
        getter target_column : String

        # The value of the condition expression.

        @[JSON::Field(key: "Value")]
        getter value : String?

        def initialize(
          @condition : String,
          @target_column : String,
          @value : String? = nil
        )
        end
      end

      # Specifies the values that an admin sets for each job or session parameter configured in a Glue usage
      # profile.

      struct ConfigurationObject
        include JSON::Serializable

        # A list of allowed values for the parameter.

        @[JSON::Field(key: "AllowedValues")]
        getter allowed_values : Array(String)?

        # A default value for the parameter.

        @[JSON::Field(key: "DefaultValue")]
        getter default_value : String?

        # A maximum allowed value for the parameter.

        @[JSON::Field(key: "MaxValue")]
        getter max_value : String?

        # A minimum allowed value for the parameter.

        @[JSON::Field(key: "MinValue")]
        getter min_value : String?

        def initialize(
          @allowed_values : Array(String)? = nil,
          @default_value : String? = nil,
          @max_value : String? = nil,
          @min_value : String? = nil
        )
        end
      end

      # The CreatePartitions API was called on a table that has indexes enabled.

      struct ConflictException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The confusion matrix shows you what your transform is predicting accurately and what types of errors
      # it is making. For more information, see Confusion matrix in Wikipedia.

      struct ConfusionMatrix
        include JSON::Serializable

        # The number of matches in the data that the transform didn't find, in the confusion matrix for your
        # transform.

        @[JSON::Field(key: "NumFalseNegatives")]
        getter num_false_negatives : Int64?

        # The number of nonmatches in the data that the transform incorrectly classified as a match, in the
        # confusion matrix for your transform.

        @[JSON::Field(key: "NumFalsePositives")]
        getter num_false_positives : Int64?

        # The number of nonmatches in the data that the transform correctly rejected, in the confusion matrix
        # for your transform.

        @[JSON::Field(key: "NumTrueNegatives")]
        getter num_true_negatives : Int64?

        # The number of matches in the data that the transform correctly found, in the confusion matrix for
        # your transform.

        @[JSON::Field(key: "NumTruePositives")]
        getter num_true_positives : Int64?

        def initialize(
          @num_false_negatives : Int64? = nil,
          @num_false_positives : Int64? = nil,
          @num_true_negatives : Int64? = nil,
          @num_true_positives : Int64? = nil
        )
        end
      end

      # Defines a connection to a data source.

      struct Connection
        include JSON::Serializable

        # Connection properties specific to the Athena compute environment.

        @[JSON::Field(key: "AthenaProperties")]
        getter athena_properties : Hash(String, String)?

        # The authentication properties of the connection.

        @[JSON::Field(key: "AuthenticationConfiguration")]
        getter authentication_configuration : Types::AuthenticationConfiguration?

        # A list of compute environments compatible with the connection.

        @[JSON::Field(key: "CompatibleComputeEnvironments")]
        getter compatible_compute_environments : Array(String)?

        # These key-value pairs define parameters for the connection when using the version 1 Connection
        # schema: HOST - The host URI: either the fully qualified domain name (FQDN) or the IPv4 address of
        # the database host. PORT - The port number, between 1024 and 65535, of the port on which the database
        # host is listening for database connections. USER_NAME - The name under which to log in to the
        # database. The value string for USER_NAME is " USERNAME ". PASSWORD - A password, if one is used, for
        # the user name. ENCRYPTED_PASSWORD - When you enable connection password protection by setting
        # ConnectionPasswordEncryption in the Data Catalog encryption settings, this field stores the
        # encrypted password. JDBC_DRIVER_JAR_URI - The Amazon Simple Storage Service (Amazon S3) path of the
        # JAR file that contains the JDBC driver to use. JDBC_DRIVER_CLASS_NAME - The class name of the JDBC
        # driver to use. JDBC_ENGINE - The name of the JDBC engine to use. JDBC_ENGINE_VERSION - The version
        # of the JDBC engine to use. CONFIG_FILES - (Reserved for future use.) INSTANCE_ID - The instance ID
        # to use. JDBC_CONNECTION_URL - The URL for connecting to a JDBC data source. JDBC_ENFORCE_SSL - A
        # case-insensitive Boolean string (true, false) specifying whether Secure Sockets Layer (SSL) with
        # hostname matching is enforced for the JDBC connection on the client. The default is false.
        # CUSTOM_JDBC_CERT - An Amazon S3 location specifying the customer's root certificate. Glue uses this
        # root certificate to validate the customers certificate when connecting to the customer database.
        # Glue only handles X.509 certificates. The certificate provided must be DER-encoded and supplied in
        # Base64 encoding PEM format. SKIP_CUSTOM_JDBC_CERT_VALIDATION - By default, this is false . Glue
        # validates the Signature algorithm and Subject Public Key Algorithm for the customer certificate. The
        # only permitted algorithms for the Signature algorithm are SHA256withRSA, SHA384withRSA or
        # SHA512withRSA. For the Subject Public Key Algorithm, the key length must be at least 2048. You can
        # set the value of this property to true to skip Glues validation of the customer certificate.
        # CUSTOM_JDBC_CERT_STRING - A custom JDBC certificate string which is used for domain match or
        # distinguished name match to prevent a man-in-the-middle attack. In Oracle database, this is used as
        # the SSL_SERVER_CERT_DN ; in Microsoft SQL Server, this is used as the hostNameInCertificate .
        # CONNECTION_URL - The URL for connecting to a general (non-JDBC) data source. SECRET_ID - The secret
        # ID used for the secret manager of credentials. CONNECTOR_URL - The connector URL for a MARKETPLACE
        # or CUSTOM connection. CONNECTOR_TYPE - The connector type for a MARKETPLACE or CUSTOM connection.
        # CONNECTOR_CLASS_NAME - The connector class name for a MARKETPLACE or CUSTOM connection.
        # KAFKA_BOOTSTRAP_SERVERS - A comma-separated list of host and port pairs that are the addresses of
        # the Apache Kafka brokers in a Kafka cluster to which a Kafka client will connect to and bootstrap
        # itself. KAFKA_SSL_ENABLED - Whether to enable or disable SSL on an Apache Kafka connection. Default
        # value is "true". KAFKA_CUSTOM_CERT - The Amazon S3 URL for the private CA cert file (.pem format).
        # The default is an empty string. KAFKA_SKIP_CUSTOM_CERT_VALIDATION - Whether to skip the validation
        # of the CA cert file or not. Glue validates for three algorithms: SHA256withRSA, SHA384withRSA and
        # SHA512withRSA. Default value is "false". KAFKA_CLIENT_KEYSTORE - The Amazon S3 location of the
        # client keystore file for Kafka client side authentication (Optional). KAFKA_CLIENT_KEYSTORE_PASSWORD
        # - The password to access the provided keystore (Optional). KAFKA_CLIENT_KEY_PASSWORD - A keystore
        # can consist of multiple keys, so this is the password to access the client key to be used with the
        # Kafka server side key (Optional). ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD - The encrypted version
        # of the Kafka client keystore password (if the user has the Glue encrypt passwords setting selected).
        # ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD - The encrypted version of the Kafka client key password (if the
        # user has the Glue encrypt passwords setting selected). KAFKA_SASL_MECHANISM - "SCRAM-SHA-512" ,
        # "GSSAPI" , "AWS_MSK_IAM" , or "PLAIN" . These are the supported SASL Mechanisms .
        # KAFKA_SASL_PLAIN_USERNAME - A plaintext username used to authenticate with the "PLAIN" mechanism.
        # KAFKA_SASL_PLAIN_PASSWORD - A plaintext password used to authenticate with the "PLAIN" mechanism.
        # ENCRYPTED_KAFKA_SASL_PLAIN_PASSWORD - The encrypted version of the Kafka SASL PLAIN password (if the
        # user has the Glue encrypt passwords setting selected). KAFKA_SASL_SCRAM_USERNAME - A plaintext
        # username used to authenticate with the "SCRAM-SHA-512" mechanism. KAFKA_SASL_SCRAM_PASSWORD - A
        # plaintext password used to authenticate with the "SCRAM-SHA-512" mechanism.
        # ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD - The encrypted version of the Kafka SASL SCRAM password (if the
        # user has the Glue encrypt passwords setting selected). KAFKA_SASL_SCRAM_SECRETS_ARN - The Amazon
        # Resource Name of a secret in Amazon Web Services Secrets Manager. KAFKA_SASL_GSSAPI_KEYTAB - The S3
        # location of a Kerberos keytab file. A keytab stores long-term keys for one or more principals. For
        # more information, see MIT Kerberos Documentation: Keytab . KAFKA_SASL_GSSAPI_KRB5_CONF - The S3
        # location of a Kerberos krb5.conf file. A krb5.conf stores Kerberos configuration information, such
        # as the location of the KDC server. For more information, see MIT Kerberos Documentation: krb5.conf .
        # KAFKA_SASL_GSSAPI_SERVICE - The Kerberos service name, as set with sasl.kerberos.service.name in
        # your Kafka Configuration . KAFKA_SASL_GSSAPI_PRINCIPAL - The name of the Kerberos princial used by
        # Glue. For more information, see Kafka Documentation: Configuring Kafka Brokers . ROLE_ARN - The role
        # to be used for running queries. REGION - The Amazon Web Services Region where queries will be run.
        # WORKGROUP_NAME - The name of an Amazon Redshift serverless workgroup or Amazon Athena workgroup in
        # which queries will run. CLUSTER_IDENTIFIER - The cluster identifier of an Amazon Redshift cluster in
        # which queries will run. DATABASE - The Amazon Redshift database that you are connecting to.

        @[JSON::Field(key: "ConnectionProperties")]
        getter connection_properties : Hash(String, String)?

        # The version of the connection schema for this connection. Version 2 supports properties for specific
        # compute environments.

        @[JSON::Field(key: "ConnectionSchemaVersion")]
        getter connection_schema_version : Int32?

        # The type of the connection. Currently, SFTP is not supported.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String?

        # The timestamp of the time that this connection definition was created.

        @[JSON::Field(key: "CreationTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter creation_time : Time?

        # The description of the connection.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A timestamp of the time this connection was last validated.

        @[JSON::Field(key: "LastConnectionValidationTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_connection_validation_time : Time?

        # The user, group, or role that last updated this connection definition.

        @[JSON::Field(key: "LastUpdatedBy")]
        getter last_updated_by : String?

        # The timestamp of the last time the connection definition was updated.

        @[JSON::Field(key: "LastUpdatedTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_updated_time : Time?

        # A list of criteria that can be used in selecting this connection.

        @[JSON::Field(key: "MatchCriteria")]
        getter match_criteria : Array(String)?

        # The name of the connection definition.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # The physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup , that
        # are needed to make this connection successfully.

        @[JSON::Field(key: "PhysicalConnectionRequirements")]
        getter physical_connection_requirements : Types::PhysicalConnectionRequirements?

        # Connection properties specific to the Python compute environment.

        @[JSON::Field(key: "PythonProperties")]
        getter python_properties : Hash(String, String)?

        # Connection properties specific to the Spark compute environment.

        @[JSON::Field(key: "SparkProperties")]
        getter spark_properties : Hash(String, String)?

        # The status of the connection. Can be one of: READY , IN_PROGRESS , or FAILED .

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The reason for the connection status.

        @[JSON::Field(key: "StatusReason")]
        getter status_reason : String?

        def initialize(
          @athena_properties : Hash(String, String)? = nil,
          @authentication_configuration : Types::AuthenticationConfiguration? = nil,
          @compatible_compute_environments : Array(String)? = nil,
          @connection_properties : Hash(String, String)? = nil,
          @connection_schema_version : Int32? = nil,
          @connection_type : String? = nil,
          @creation_time : Time? = nil,
          @description : String? = nil,
          @last_connection_validation_time : Time? = nil,
          @last_updated_by : String? = nil,
          @last_updated_time : Time? = nil,
          @match_criteria : Array(String)? = nil,
          @name : String? = nil,
          @physical_connection_requirements : Types::PhysicalConnectionRequirements? = nil,
          @python_properties : Hash(String, String)? = nil,
          @spark_properties : Hash(String, String)? = nil,
          @status : String? = nil,
          @status_reason : String? = nil
        )
        end
      end

      # A structure that is used to specify a connection to create or update.

      struct ConnectionInput
        include JSON::Serializable

        # These key-value pairs define parameters for the connection.

        @[JSON::Field(key: "ConnectionProperties")]
        getter connection_properties : Hash(String, String)

        # The type of the connection. Currently, these types are supported: JDBC - Designates a connection to
        # a database through Java Database Connectivity (JDBC). JDBC Connections use the following
        # ConnectionParameters. Required: All of ( HOST , PORT , JDBC_ENGINE ) or JDBC_CONNECTION_URL .
        # Required: All of ( USERNAME , PASSWORD ) or SECRET_ID . Optional: JDBC_ENFORCE_SSL ,
        # CUSTOM_JDBC_CERT , CUSTOM_JDBC_CERT_STRING , SKIP_CUSTOM_JDBC_CERT_VALIDATION . These parameters are
        # used to configure SSL with JDBC. KAFKA - Designates a connection to an Apache Kafka streaming
        # platform. KAFKA Connections use the following ConnectionParameters. Required:
        # KAFKA_BOOTSTRAP_SERVERS . Optional: KAFKA_SSL_ENABLED , KAFKA_CUSTOM_CERT ,
        # KAFKA_SKIP_CUSTOM_CERT_VALIDATION . These parameters are used to configure SSL with KAFKA .
        # Optional: KAFKA_CLIENT_KEYSTORE , KAFKA_CLIENT_KEYSTORE_PASSWORD , KAFKA_CLIENT_KEY_PASSWORD ,
        # ENCRYPTED_KAFKA_CLIENT_KEYSTORE_PASSWORD , ENCRYPTED_KAFKA_CLIENT_KEY_PASSWORD . These parameters
        # are used to configure TLS client configuration with SSL in KAFKA . Optional: KAFKA_SASL_MECHANISM .
        # Can be specified as SCRAM-SHA-512 , GSSAPI , or AWS_MSK_IAM . Optional: KAFKA_SASL_SCRAM_USERNAME ,
        # KAFKA_SASL_SCRAM_PASSWORD , ENCRYPTED_KAFKA_SASL_SCRAM_PASSWORD . These parameters are used to
        # configure SASL/SCRAM-SHA-512 authentication with KAFKA . Optional: KAFKA_SASL_GSSAPI_KEYTAB ,
        # KAFKA_SASL_GSSAPI_KRB5_CONF , KAFKA_SASL_GSSAPI_SERVICE , KAFKA_SASL_GSSAPI_PRINCIPAL . These
        # parameters are used to configure SASL/GSSAPI authentication with KAFKA . MONGODB - Designates a
        # connection to a MongoDB document database. MONGODB Connections use the following
        # ConnectionParameters. Required: CONNECTION_URL . Required: All of ( USERNAME , PASSWORD ) or
        # SECRET_ID . VIEW_VALIDATION_REDSHIFT - Designates a connection used for view validation by Amazon
        # Redshift. VIEW_VALIDATION_ATHENA - Designates a connection used for view validation by Amazon
        # Athena. NETWORK - Designates a network connection to a data source within an Amazon Virtual Private
        # Cloud environment (Amazon VPC). NETWORK Connections do not require ConnectionParameters. Instead,
        # provide a PhysicalConnectionRequirements. MARKETPLACE - Uses configuration settings contained in a
        # connector purchased from Amazon Web Services Marketplace to read from and write to data stores that
        # are not natively supported by Glue. MARKETPLACE Connections use the following ConnectionParameters.
        # Required: CONNECTOR_TYPE , CONNECTOR_URL , CONNECTOR_CLASS_NAME , CONNECTION_URL . Required for JDBC
        # CONNECTOR_TYPE connections: All of ( USERNAME , PASSWORD ) or SECRET_ID . CUSTOM - Uses
        # configuration settings contained in a custom connector to read from and write to data stores that
        # are not natively supported by Glue. For more information on the connection parameters needed for a
        # particular connector, see the documentation for the connector in Adding an Glue connection in the
        # Glue User Guide. SFTP is not supported. For more information about how optional ConnectionProperties
        # are used to configure features in Glue, consult Glue connection properties . For more information
        # about how optional ConnectionProperties are used to configure features in Glue Studio, consult Using
        # connectors and connections .

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        # The name of the connection.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Connection properties specific to the Athena compute environment.

        @[JSON::Field(key: "AthenaProperties")]
        getter athena_properties : Hash(String, String)?

        # The authentication properties of the connection.

        @[JSON::Field(key: "AuthenticationConfiguration")]
        getter authentication_configuration : Types::AuthenticationConfigurationInput?

        # The description of the connection.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A list of criteria that can be used in selecting this connection.

        @[JSON::Field(key: "MatchCriteria")]
        getter match_criteria : Array(String)?

        # The physical connection requirements, such as virtual private cloud (VPC) and SecurityGroup , that
        # are needed to successfully make this connection.

        @[JSON::Field(key: "PhysicalConnectionRequirements")]
        getter physical_connection_requirements : Types::PhysicalConnectionRequirements?

        # Connection properties specific to the Python compute environment.

        @[JSON::Field(key: "PythonProperties")]
        getter python_properties : Hash(String, String)?

        # Connection properties specific to the Spark compute environment.

        @[JSON::Field(key: "SparkProperties")]
        getter spark_properties : Hash(String, String)?

        # A flag to validate the credentials during create connection. Default is true.

        @[JSON::Field(key: "ValidateCredentials")]
        getter validate_credentials : Bool?

        # The compute environments that the specified connection properties are validated against.

        @[JSON::Field(key: "ValidateForComputeEnvironments")]
        getter validate_for_compute_environments : Array(String)?

        def initialize(
          @connection_properties : Hash(String, String),
          @connection_type : String,
          @name : String,
          @athena_properties : Hash(String, String)? = nil,
          @authentication_configuration : Types::AuthenticationConfigurationInput? = nil,
          @description : String? = nil,
          @match_criteria : Array(String)? = nil,
          @physical_connection_requirements : Types::PhysicalConnectionRequirements? = nil,
          @python_properties : Hash(String, String)? = nil,
          @spark_properties : Hash(String, String)? = nil,
          @validate_credentials : Bool? = nil,
          @validate_for_compute_environments : Array(String)? = nil
        )
        end
      end

      # The data structure used by the Data Catalog to encrypt the password as part of CreateConnection or
      # UpdateConnection and store it in the ENCRYPTED_PASSWORD field in the connection properties. You can
      # enable catalog encryption or only password encryption. When a CreationConnection request arrives
      # containing a password, the Data Catalog first encrypts the password using your KMS key. It then
      # encrypts the whole connection object again if catalog encryption is also enabled. This encryption
      # requires that you set KMS key permissions to enable or restrict access on the password key according
      # to your security requirements. For example, you might want only administrators to have decrypt
      # permission on the password key.

      struct ConnectionPasswordEncryption
        include JSON::Serializable

        # When the ReturnConnectionPasswordEncrypted flag is set to "true", passwords remain encrypted in the
        # responses of GetConnection and GetConnections . This encryption takes effect independently from
        # catalog encryption.

        @[JSON::Field(key: "ReturnConnectionPasswordEncrypted")]
        getter return_connection_password_encrypted : Bool

        # An KMS key that is used to encrypt the connection password. If connection password protection is
        # enabled, the caller of CreateConnection and UpdateConnection needs at least kms:Encrypt permission
        # on the specified KMS key, to encrypt passwords before storing them in the Data Catalog. You can set
        # the decrypt permission to enable or restrict access on the password key according to your security
        # requirements.

        @[JSON::Field(key: "AwsKmsKeyId")]
        getter aws_kms_key_id : String?

        def initialize(
          @return_connection_password_encrypted : Bool,
          @aws_kms_key_id : String? = nil
        )
        end
      end

      # Brief information about a supported connection type returned by the ListConnectionTypes API.

      struct ConnectionTypeBrief
        include JSON::Serializable

        # The supported authentication types, data interface types (compute environments), and data operations
        # of the connector.

        @[JSON::Field(key: "Capabilities")]
        getter capabilities : Types::Capabilities?

        # A list of categories that this connection type belongs to. Categories help users filter and find
        # appropriate connection types based on their use cases.

        @[JSON::Field(key: "Categories")]
        getter categories : Array(String)?

        # The name of the connection type.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String?

        # A list of variants available for this connection type. Different variants may provide specialized
        # configurations for specific use cases or implementations of the same general connection type.

        @[JSON::Field(key: "ConnectionTypeVariants")]
        getter connection_type_variants : Array(Types::ConnectionTypeVariant)?

        # A description of the connection type.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The human-readable name for the connection type that is displayed in the Glue console.

        @[JSON::Field(key: "DisplayName")]
        getter display_name : String?

        # The URL of the logo associated with a connection type.

        @[JSON::Field(key: "LogoUrl")]
        getter logo_url : String?

        # The name of the vendor or provider that created or maintains this connection type.

        @[JSON::Field(key: "Vendor")]
        getter vendor : String?

        def initialize(
          @capabilities : Types::Capabilities? = nil,
          @categories : Array(String)? = nil,
          @connection_type : String? = nil,
          @connection_type_variants : Array(Types::ConnectionTypeVariant)? = nil,
          @description : String? = nil,
          @display_name : String? = nil,
          @logo_url : String? = nil,
          @vendor : String? = nil
        )
        end
      end

      # Represents a variant of a connection type in Glue Data Catalog. Connection type variants provide
      # specific configurations and behaviors for different implementations of the same general connection
      # type.

      struct ConnectionTypeVariant
        include JSON::Serializable

        # The unique identifier for the connection type variant. This name is used internally to identify the
        # specific variant of a connection type.

        @[JSON::Field(key: "ConnectionTypeVariantName")]
        getter connection_type_variant_name : String?

        # A detailed description of the connection type variant, including its purpose, use cases, and any
        # specific configuration requirements.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The human-readable name for the connection type variant that is displayed in the Glue console.

        @[JSON::Field(key: "DisplayName")]
        getter display_name : String?

        # The URL of the logo associated with a connection type variant.

        @[JSON::Field(key: "LogoUrl")]
        getter logo_url : String?

        def initialize(
          @connection_type_variant_name : String? = nil,
          @description : String? = nil,
          @display_name : String? = nil,
          @logo_url : String? = nil
        )
        end
      end

      # Specifies the connections used by a job.

      struct ConnectionsList
        include JSON::Serializable

        # A list of connections used by the job.

        @[JSON::Field(key: "Connections")]
        getter connections : Array(String)?

        def initialize(
          @connections : Array(String)? = nil
        )
        end
      end

      # Specifies a source generated with standard connection options.

      struct ConnectorDataSource
        include JSON::Serializable

        # The connectionType , as provided to the underlying Glue library. This node type supports the
        # following connection types: opensearch azuresql azurecosmos bigquery saphana teradata vertica

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        # A map specifying connection options for the node. You can find standard connection options for the
        # corresponding connection type in the Connection parameters section of the Glue documentation.

        @[JSON::Field(key: "Data")]
        getter data : Hash(String, String)

        # The name of this source node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Specifies the data schema for this source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @connection_type : String,
          @data : Hash(String, String),
          @name : String,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies a target generated with standard connection options.

      struct ConnectorDataTarget
        include JSON::Serializable

        # The connectionType , as provided to the underlying Glue library. This node type supports the
        # following connection types: opensearch azuresql azurecosmos bigquery saphana teradata vertica

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        # A map specifying connection options for the node. You can find standard connection options for the
        # corresponding connection type in the Connection parameters section of the Glue documentation.

        @[JSON::Field(key: "Data")]
        getter data : Hash(String, String)

        # The name of this target node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)?

        def initialize(
          @connection_type : String,
          @data : Hash(String, String),
          @name : String,
          @inputs : Array(String)? = nil
        )
        end
      end

      # The details of a crawl in the workflow.

      struct Crawl
        include JSON::Serializable

        # The date and time on which the crawl completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # The error message associated with the crawl.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # The log group associated with the crawl.

        @[JSON::Field(key: "LogGroup")]
        getter log_group : String?

        # The log stream associated with the crawl.

        @[JSON::Field(key: "LogStream")]
        getter log_stream : String?

        # The date and time on which the crawl started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # The state of the crawler.

        @[JSON::Field(key: "State")]
        getter state : String?

        def initialize(
          @completed_on : Time? = nil,
          @error_message : String? = nil,
          @log_group : String? = nil,
          @log_stream : String? = nil,
          @started_on : Time? = nil,
          @state : String? = nil
        )
        end
      end

      # Specifies a crawler program that examines a data source and uses classifiers to try to determine its
      # schema. If successful, the crawler records metadata concerning the data source in the Glue Data
      # Catalog.

      struct Crawler
        include JSON::Serializable

        # A list of UTF-8 strings that specify the custom classifiers that are associated with the crawler.

        @[JSON::Field(key: "Classifiers")]
        getter classifiers : Array(String)?

        # Crawler configuration information. This versioned JSON string allows users to specify aspects of a
        # crawler's behavior. For more information, see Setting crawler configuration options .

        @[JSON::Field(key: "Configuration")]
        getter configuration : String?

        # If the crawler is running, contains the total time elapsed since the last crawl began.

        @[JSON::Field(key: "CrawlElapsedTime")]
        getter crawl_elapsed_time : Int64?

        # The name of the SecurityConfiguration structure to be used by this crawler.

        @[JSON::Field(key: "CrawlerSecurityConfiguration")]
        getter crawler_security_configuration : String?

        # The time that the crawler was created.

        @[JSON::Field(key: "CreationTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter creation_time : Time?

        # The name of the database in which the crawler's output is stored.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # A description of the crawler.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Specifies whether the crawler should use Lake Formation credentials for the crawler instead of the
        # IAM role credentials.

        @[JSON::Field(key: "LakeFormationConfiguration")]
        getter lake_formation_configuration : Types::LakeFormationConfiguration?

        # The status of the last crawl, and potentially error information if an error occurred.

        @[JSON::Field(key: "LastCrawl")]
        getter last_crawl : Types::LastCrawlInfo?

        # The time that the crawler was last updated.

        @[JSON::Field(key: "LastUpdated", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_updated : Time?

        # A configuration that specifies whether data lineage is enabled for the crawler.

        @[JSON::Field(key: "LineageConfiguration")]
        getter lineage_configuration : Types::LineageConfiguration?

        # The name of the crawler.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that
        # were added since the last crawler run.

        @[JSON::Field(key: "RecrawlPolicy")]
        getter recrawl_policy : Types::RecrawlPolicy?

        # The Amazon Resource Name (ARN) of an IAM role that's used to access customer resources, such as
        # Amazon Simple Storage Service (Amazon S3) data.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # For scheduled crawlers, the schedule when the crawler runs.

        @[JSON::Field(key: "Schedule")]
        getter schedule : Types::Schedule?

        # The policy that specifies update and delete behaviors for the crawler.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::SchemaChangePolicy?

        # Indicates whether the crawler is running, or whether a run is pending.

        @[JSON::Field(key: "State")]
        getter state : String?

        # The prefix added to the names of tables that are created.

        @[JSON::Field(key: "TablePrefix")]
        getter table_prefix : String?

        # A collection of targets to crawl.

        @[JSON::Field(key: "Targets")]
        getter targets : Types::CrawlerTargets?

        # The version of the crawler.

        @[JSON::Field(key: "Version")]
        getter version : Int64?

        def initialize(
          @classifiers : Array(String)? = nil,
          @configuration : String? = nil,
          @crawl_elapsed_time : Int64? = nil,
          @crawler_security_configuration : String? = nil,
          @creation_time : Time? = nil,
          @database_name : String? = nil,
          @description : String? = nil,
          @lake_formation_configuration : Types::LakeFormationConfiguration? = nil,
          @last_crawl : Types::LastCrawlInfo? = nil,
          @last_updated : Time? = nil,
          @lineage_configuration : Types::LineageConfiguration? = nil,
          @name : String? = nil,
          @recrawl_policy : Types::RecrawlPolicy? = nil,
          @role : String? = nil,
          @schedule : Types::Schedule? = nil,
          @schema_change_policy : Types::SchemaChangePolicy? = nil,
          @state : String? = nil,
          @table_prefix : String? = nil,
          @targets : Types::CrawlerTargets? = nil,
          @version : Int64? = nil
        )
        end
      end

      # Contains the information for a run of a crawler.

      struct CrawlerHistory
        include JSON::Serializable

        # A UUID identifier for each crawl.

        @[JSON::Field(key: "CrawlId")]
        getter crawl_id : String?

        # The number of data processing units (DPU) used in hours for the crawl.

        @[JSON::Field(key: "DPUHour")]
        getter dpu_hour : Float64?

        # The date and time on which the crawl ended.

        @[JSON::Field(key: "EndTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter end_time : Time?

        # If an error occurred, the error message associated with the crawl.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # The log group associated with the crawl.

        @[JSON::Field(key: "LogGroup")]
        getter log_group : String?

        # The log stream associated with the crawl.

        @[JSON::Field(key: "LogStream")]
        getter log_stream : String?

        # The prefix for a CloudWatch message about this crawl.

        @[JSON::Field(key: "MessagePrefix")]
        getter message_prefix : String?

        # The date and time on which the crawl started.

        @[JSON::Field(key: "StartTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter start_time : Time?

        # The state of the crawl.

        @[JSON::Field(key: "State")]
        getter state : String?

        # A run summary for the specific crawl in JSON. Contains the catalog tables and partitions that were
        # added, updated, or deleted.

        @[JSON::Field(key: "Summary")]
        getter summary : String?

        def initialize(
          @crawl_id : String? = nil,
          @dpu_hour : Float64? = nil,
          @end_time : Time? = nil,
          @error_message : String? = nil,
          @log_group : String? = nil,
          @log_stream : String? = nil,
          @message_prefix : String? = nil,
          @start_time : Time? = nil,
          @state : String? = nil,
          @summary : String? = nil
        )
        end
      end

      # Metrics for a specified crawler.

      struct CrawlerMetrics
        include JSON::Serializable

        # The name of the crawler.

        @[JSON::Field(key: "CrawlerName")]
        getter crawler_name : String?

        # The duration of the crawler's most recent run, in seconds.

        @[JSON::Field(key: "LastRuntimeSeconds")]
        getter last_runtime_seconds : Float64?

        # The median duration of this crawler's runs, in seconds.

        @[JSON::Field(key: "MedianRuntimeSeconds")]
        getter median_runtime_seconds : Float64?

        # True if the crawler is still estimating how long it will take to complete this run.

        @[JSON::Field(key: "StillEstimating")]
        getter still_estimating : Bool?

        # The number of tables created by this crawler.

        @[JSON::Field(key: "TablesCreated")]
        getter tables_created : Int32?

        # The number of tables deleted by this crawler.

        @[JSON::Field(key: "TablesDeleted")]
        getter tables_deleted : Int32?

        # The number of tables updated by this crawler.

        @[JSON::Field(key: "TablesUpdated")]
        getter tables_updated : Int32?

        # The estimated time left to complete a running crawl.

        @[JSON::Field(key: "TimeLeftSeconds")]
        getter time_left_seconds : Float64?

        def initialize(
          @crawler_name : String? = nil,
          @last_runtime_seconds : Float64? = nil,
          @median_runtime_seconds : Float64? = nil,
          @still_estimating : Bool? = nil,
          @tables_created : Int32? = nil,
          @tables_deleted : Int32? = nil,
          @tables_updated : Int32? = nil,
          @time_left_seconds : Float64? = nil
        )
        end
      end

      # The details of a Crawler node present in the workflow.

      struct CrawlerNodeDetails
        include JSON::Serializable

        # A list of crawls represented by the crawl node.

        @[JSON::Field(key: "Crawls")]
        getter crawls : Array(Types::Crawl)?

        def initialize(
          @crawls : Array(Types::Crawl)? = nil
        )
        end
      end

      # The specified crawler is not running.

      struct CrawlerNotRunningException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The operation cannot be performed because the crawler is already running.

      struct CrawlerRunningException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The specified crawler is stopping.

      struct CrawlerStoppingException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Specifies data stores to crawl.

      struct CrawlerTargets
        include JSON::Serializable

        # Specifies Glue Data Catalog targets.

        @[JSON::Field(key: "CatalogTargets")]
        getter catalog_targets : Array(Types::CatalogTarget)?

        # Specifies Delta data store targets.

        @[JSON::Field(key: "DeltaTargets")]
        getter delta_targets : Array(Types::DeltaTarget)?

        # Specifies Amazon DynamoDB targets.

        @[JSON::Field(key: "DynamoDBTargets")]
        getter dynamo_db_targets : Array(Types::DynamoDBTarget)?

        # Specifies Apache Hudi data store targets.

        @[JSON::Field(key: "HudiTargets")]
        getter hudi_targets : Array(Types::HudiTarget)?

        # Specifies Apache Iceberg data store targets.

        @[JSON::Field(key: "IcebergTargets")]
        getter iceberg_targets : Array(Types::IcebergTarget)?

        # Specifies JDBC targets.

        @[JSON::Field(key: "JdbcTargets")]
        getter jdbc_targets : Array(Types::JdbcTarget)?

        # Specifies Amazon DocumentDB or MongoDB targets.

        @[JSON::Field(key: "MongoDBTargets")]
        getter mongo_db_targets : Array(Types::MongoDBTarget)?

        # Specifies Amazon Simple Storage Service (Amazon S3) targets.

        @[JSON::Field(key: "S3Targets")]
        getter s3_targets : Array(Types::S3Target)?

        def initialize(
          @catalog_targets : Array(Types::CatalogTarget)? = nil,
          @delta_targets : Array(Types::DeltaTarget)? = nil,
          @dynamo_db_targets : Array(Types::DynamoDBTarget)? = nil,
          @hudi_targets : Array(Types::HudiTarget)? = nil,
          @iceberg_targets : Array(Types::IcebergTarget)? = nil,
          @jdbc_targets : Array(Types::JdbcTarget)? = nil,
          @mongo_db_targets : Array(Types::MongoDBTarget)? = nil,
          @s3_targets : Array(Types::S3Target)? = nil
        )
        end
      end

      # A list of fields, comparators and value that you can use to filter the crawler runs for a specified
      # crawler.

      struct CrawlsFilter
        include JSON::Serializable

        # A key used to filter the crawler runs for a specified crawler. Valid values for each of the field
        # names are: CRAWL_ID : A string representing the UUID identifier for a crawl. STATE : A string
        # representing the state of the crawl. START_TIME and END_TIME : The epoch timestamp in milliseconds.
        # DPU_HOUR : The number of data processing unit (DPU) hours used for the crawl.

        @[JSON::Field(key: "FieldName")]
        getter field_name : String?

        # The value provided for comparison on the crawl field.

        @[JSON::Field(key: "FieldValue")]
        getter field_value : String?

        # A defined comparator that operates on the value. The available operators are: GT : Greater than. GE
        # : Greater than or equal to. LT : Less than. LE : Less than or equal to. EQ : Equal to. NE : Not
        # equal to.

        @[JSON::Field(key: "FilterOperator")]
        getter filter_operator : String?

        def initialize(
          @field_name : String? = nil,
          @field_value : String? = nil,
          @filter_operator : String? = nil
        )
        end
      end


      struct CreateBlueprintRequest
        include JSON::Serializable

        # Specifies a path in Amazon S3 where the blueprint is published.

        @[JSON::Field(key: "BlueprintLocation")]
        getter blueprint_location : String

        # The name of the blueprint.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A description of the blueprint.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The tags to be applied to this blueprint.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @blueprint_location : String,
          @name : String,
          @description : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateBlueprintResponse
        include JSON::Serializable

        # Returns the name of the blueprint that was registered.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct CreateCatalogRequest
        include JSON::Serializable

        # A CatalogInput object that defines the metadata for the catalog.

        @[JSON::Field(key: "CatalogInput")]
        getter catalog_input : Types::CatalogInput

        # The name of the catalog to create.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A map array of key-value pairs, not more than 50 pairs. Each key is a UTF-8 string, not less than 1
        # or more than 128 bytes long. Each value is a UTF-8 string, not more than 256 bytes long. The tags
        # you assign to the catalog.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @catalog_input : Types::CatalogInput,
          @name : String,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateCatalogResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CreateClassifierRequest
        include JSON::Serializable

        # A CsvClassifier object specifying the classifier to create.

        @[JSON::Field(key: "CsvClassifier")]
        getter csv_classifier : Types::CreateCsvClassifierRequest?

        # A GrokClassifier object specifying the classifier to create.

        @[JSON::Field(key: "GrokClassifier")]
        getter grok_classifier : Types::CreateGrokClassifierRequest?

        # A JsonClassifier object specifying the classifier to create.

        @[JSON::Field(key: "JsonClassifier")]
        getter json_classifier : Types::CreateJsonClassifierRequest?

        # An XMLClassifier object specifying the classifier to create.

        @[JSON::Field(key: "XMLClassifier")]
        getter xml_classifier : Types::CreateXMLClassifierRequest?

        def initialize(
          @csv_classifier : Types::CreateCsvClassifierRequest? = nil,
          @grok_classifier : Types::CreateGrokClassifierRequest? = nil,
          @json_classifier : Types::CreateJsonClassifierRequest? = nil,
          @xml_classifier : Types::CreateXMLClassifierRequest? = nil
        )
        end
      end


      struct CreateClassifierResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CreateColumnStatisticsTaskSettingsRequest
        include JSON::Serializable

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The role used for running the column statistics.

        @[JSON::Field(key: "Role")]
        getter role : String

        # The name of the table for which to generate column statistics.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog in which the database resides.

        @[JSON::Field(key: "CatalogID")]
        getter catalog_id : String?

        # A list of column names for which to run statistics.

        @[JSON::Field(key: "ColumnNameList")]
        getter column_name_list : Array(String)?

        # The percentage of data to sample.

        @[JSON::Field(key: "SampleSize")]
        getter sample_size : Float64?

        # A schedule for running the column statistics, specified in CRON syntax.

        @[JSON::Field(key: "Schedule")]
        getter schedule : String?

        # Name of the security configuration that is used to encrypt CloudWatch logs.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # A map of tags.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @database_name : String,
          @role : String,
          @table_name : String,
          @catalog_id : String? = nil,
          @column_name_list : Array(String)? = nil,
          @sample_size : Float64? = nil,
          @schedule : String? = nil,
          @security_configuration : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateColumnStatisticsTaskSettingsResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CreateConnectionRequest
        include JSON::Serializable

        # A ConnectionInput object defining the connection to create.

        @[JSON::Field(key: "ConnectionInput")]
        getter connection_input : Types::ConnectionInput

        # The ID of the Data Catalog in which to create the connection. If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The tags you assign to the connection.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @connection_input : Types::ConnectionInput,
          @catalog_id : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateConnectionResponse
        include JSON::Serializable

        # The status of the connection creation request. The request can take some time for certain
        # authentication types, for example when creating an OAuth connection with token exchange over VPC.

        @[JSON::Field(key: "CreateConnectionStatus")]
        getter create_connection_status : String?

        def initialize(
          @create_connection_status : String? = nil
        )
        end
      end


      struct CreateCrawlerRequest
        include JSON::Serializable

        # Name of the new crawler.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The IAM role or Amazon Resource Name (ARN) of an IAM role used by the new crawler to access customer
        # resources.

        @[JSON::Field(key: "Role")]
        getter role : String

        # A list of collection of targets to crawl.

        @[JSON::Field(key: "Targets")]
        getter targets : Types::CrawlerTargets

        # A list of custom classifiers that the user has registered. By default, all built-in classifiers are
        # included in a crawl, but these custom classifiers always override the default classifiers for a
        # given classification.

        @[JSON::Field(key: "Classifiers")]
        getter classifiers : Array(String)?

        # Crawler configuration information. This versioned JSON string allows users to specify aspects of a
        # crawler's behavior. For more information, see Setting crawler configuration options .

        @[JSON::Field(key: "Configuration")]
        getter configuration : String?

        # The name of the SecurityConfiguration structure to be used by this crawler.

        @[JSON::Field(key: "CrawlerSecurityConfiguration")]
        getter crawler_security_configuration : String?

        # The Glue database where results are written, such as:
        # arn:aws:daylight:us-east-1::database/sometable/* .

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # A description of the new crawler.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Specifies Lake Formation configuration settings for the crawler.

        @[JSON::Field(key: "LakeFormationConfiguration")]
        getter lake_formation_configuration : Types::LakeFormationConfiguration?

        # Specifies data lineage configuration settings for the crawler.

        @[JSON::Field(key: "LineageConfiguration")]
        getter lineage_configuration : Types::LineageConfiguration?

        # A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that
        # were added since the last crawler run.

        @[JSON::Field(key: "RecrawlPolicy")]
        getter recrawl_policy : Types::RecrawlPolicy?

        # A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers . For
        # example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *) .

        @[JSON::Field(key: "Schedule")]
        getter schedule : String?

        # The policy for the crawler's update and deletion behavior.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::SchemaChangePolicy?

        # The table prefix used for catalog tables that are created.

        @[JSON::Field(key: "TablePrefix")]
        getter table_prefix : String?

        # The tags to use with this crawler request. You may use tags to limit access to the crawler. For more
        # information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @name : String,
          @role : String,
          @targets : Types::CrawlerTargets,
          @classifiers : Array(String)? = nil,
          @configuration : String? = nil,
          @crawler_security_configuration : String? = nil,
          @database_name : String? = nil,
          @description : String? = nil,
          @lake_formation_configuration : Types::LakeFormationConfiguration? = nil,
          @lineage_configuration : Types::LineageConfiguration? = nil,
          @recrawl_policy : Types::RecrawlPolicy? = nil,
          @schedule : String? = nil,
          @schema_change_policy : Types::SchemaChangePolicy? = nil,
          @table_prefix : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateCrawlerResponse
        include JSON::Serializable

        def initialize
        end
      end

      # Specifies a custom CSV classifier for CreateClassifier to create.

      struct CreateCsvClassifierRequest
        include JSON::Serializable

        # The name of the classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Enables the processing of files that contain only one column.

        @[JSON::Field(key: "AllowSingleColumn")]
        getter allow_single_column : Bool?

        # Indicates whether the CSV file contains a header.

        @[JSON::Field(key: "ContainsHeader")]
        getter contains_header : String?

        # Enables the configuration of custom datatypes.

        @[JSON::Field(key: "CustomDatatypeConfigured")]
        getter custom_datatype_configured : Bool?

        # Creates a list of supported custom datatypes.

        @[JSON::Field(key: "CustomDatatypes")]
        getter custom_datatypes : Array(String)?

        # A custom symbol to denote what separates each column entry in the row.

        @[JSON::Field(key: "Delimiter")]
        getter delimiter : String?

        # Specifies not to trim values before identifying the type of column values. The default value is
        # true.

        @[JSON::Field(key: "DisableValueTrimming")]
        getter disable_value_trimming : Bool?

        # A list of strings representing column names.

        @[JSON::Field(key: "Header")]
        getter header : Array(String)?

        # A custom symbol to denote what combines content into a single column value. Must be different from
        # the column delimiter.

        @[JSON::Field(key: "QuoteSymbol")]
        getter quote_symbol : String?

        # Sets the SerDe for processing CSV in the classifier, which will be applied in the Data Catalog.
        # Valid values are OpenCSVSerDe , LazySimpleSerDe , and None . You can specify the None value when you
        # want the crawler to do the detection.

        @[JSON::Field(key: "Serde")]
        getter serde : String?

        def initialize(
          @name : String,
          @allow_single_column : Bool? = nil,
          @contains_header : String? = nil,
          @custom_datatype_configured : Bool? = nil,
          @custom_datatypes : Array(String)? = nil,
          @delimiter : String? = nil,
          @disable_value_trimming : Bool? = nil,
          @header : Array(String)? = nil,
          @quote_symbol : String? = nil,
          @serde : String? = nil
        )
        end
      end


      struct CreateCustomEntityTypeRequest
        include JSON::Serializable

        # A name for the custom pattern that allows it to be retrieved or deleted later. This name must be
        # unique per Amazon Web Services account.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A regular expression string that is used for detecting sensitive data in a custom pattern.

        @[JSON::Field(key: "RegexString")]
        getter regex_string : String

        # A list of context words. If none of these context words are found within the vicinity of the regular
        # expression the data will not be detected as sensitive data. If no context words are passed only a
        # regular expression is checked.

        @[JSON::Field(key: "ContextWords")]
        getter context_words : Array(String)?

        # A list of tags applied to the custom entity type.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @name : String,
          @regex_string : String,
          @context_words : Array(String)? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateCustomEntityTypeResponse
        include JSON::Serializable

        # The name of the custom pattern you created.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end

      # A request to create a data quality ruleset.

      struct CreateDataQualityRulesetRequest
        include JSON::Serializable

        # A unique name for the data quality ruleset.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer
        # guide.

        @[JSON::Field(key: "Ruleset")]
        getter ruleset : String

        # Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating
        # or starting multiple instances of the same resource.

        @[JSON::Field(key: "ClientToken")]
        getter client_token : String?

        # The name of the security configuration created with the data quality encryption option.

        @[JSON::Field(key: "DataQualitySecurityConfiguration")]
        getter data_quality_security_configuration : String?

        # A description of the data quality ruleset.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A list of tags applied to the data quality ruleset.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        # A target table associated with the data quality ruleset.

        @[JSON::Field(key: "TargetTable")]
        getter target_table : Types::DataQualityTargetTable?

        def initialize(
          @name : String,
          @ruleset : String,
          @client_token : String? = nil,
          @data_quality_security_configuration : String? = nil,
          @description : String? = nil,
          @tags : Hash(String, String)? = nil,
          @target_table : Types::DataQualityTargetTable? = nil
        )
        end
      end


      struct CreateDataQualityRulesetResponse
        include JSON::Serializable

        # A unique name for the data quality ruleset.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct CreateDatabaseRequest
        include JSON::Serializable

        # The metadata for the database.

        @[JSON::Field(key: "DatabaseInput")]
        getter database_input : Types::DatabaseInput

        # The ID of the Data Catalog in which to create the database. If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The tags you assign to the database.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @database_input : Types::DatabaseInput,
          @catalog_id : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateDatabaseResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CreateDevEndpointRequest
        include JSON::Serializable

        # The name to be assigned to the new DevEndpoint .

        @[JSON::Field(key: "EndpointName")]
        getter endpoint_name : String

        # The IAM role for the DevEndpoint .

        @[JSON::Field(key: "RoleArn")]
        getter role_arn : String

        # A map of arguments used to configure the DevEndpoint .

        @[JSON::Field(key: "Arguments")]
        getter arguments : Hash(String, String)?

        # The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint .

        @[JSON::Field(key: "ExtraJarsS3Path")]
        getter extra_jars_s3_path : String?

        # The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your
        # DevEndpoint . Multiple values must be complete paths separated by a comma. You can only use pure
        # Python libraries with a DevEndpoint . Libraries that rely on C extensions, such as the pandas Python
        # data analysis library, are not yet supported.

        @[JSON::Field(key: "ExtraPythonLibsS3Path")]
        getter extra_python_libs_s3_path : String?

        # Glue version determines the versions of Apache Spark and Python that Glue supports. The Python
        # version indicates the version supported for running your ETL scripts on development endpoints. For
        # more information about the available Glue versions and corresponding Spark and Python versions, see
        # Glue version in the developer guide. Development endpoints that are created without specifying a
        # Glue version default to Glue 0.9. You can specify a version of Python support for development
        # endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no
        # arguments are provided, the version defaults to Python 2.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # The number of Glue Data Processing Units (DPUs) to allocate to this DevEndpoint .

        @[JSON::Field(key: "NumberOfNodes")]
        getter number_of_nodes : Int32?

        # The number of workers of a defined workerType that are allocated to the development endpoint. The
        # maximum number of workers you can define are 299 for G.1X , and 149 for G.2X .

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The public key to be used by this DevEndpoint for authentication. This attribute is provided for
        # backward compatibility because the recommended attribute to use is public keys.

        @[JSON::Field(key: "PublicKey")]
        getter public_key : String?

        # A list of public keys to be used by the development endpoints for authentication. The use of this
        # attribute is preferred over a single public key because the public keys allow you to have a
        # different private key per client. If you previously created an endpoint with a public key, you must
        # remove that key to be able to set a list of public keys. Call the UpdateDevEndpoint API with the
        # public key content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys
        # attribute.

        @[JSON::Field(key: "PublicKeys")]
        getter public_keys : Array(String)?

        # The name of the SecurityConfiguration structure to be used with this DevEndpoint .

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # Security group IDs for the security groups to be used by the new DevEndpoint .

        @[JSON::Field(key: "SecurityGroupIds")]
        getter security_group_ids : Array(String)?

        # The subnet ID for the new DevEndpoint to use.

        @[JSON::Field(key: "SubnetId")]
        getter subnet_id : String?

        # The tags to use with this DevEndpoint. You may use tags to limit access to the DevEndpoint. For more
        # information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        # The type of predefined worker that is allocated to the development endpoint. Accepts a value of
        # Standard, G.1X, or G.2X. For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory
        # and a 50GB disk, and 2 executors per worker. For the G.1X worker type, each worker maps to 1 DPU (4
        # vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker
        # type for memory-intensive jobs. For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB
        # of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for
        # memory-intensive jobs. Known issue: when a development endpoint is created with the G.2X WorkerType
        # configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory,
        # and a 64 GB disk.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @endpoint_name : String,
          @role_arn : String,
          @arguments : Hash(String, String)? = nil,
          @extra_jars_s3_path : String? = nil,
          @extra_python_libs_s3_path : String? = nil,
          @glue_version : String? = nil,
          @number_of_nodes : Int32? = nil,
          @number_of_workers : Int32? = nil,
          @public_key : String? = nil,
          @public_keys : Array(String)? = nil,
          @security_configuration : String? = nil,
          @security_group_ids : Array(String)? = nil,
          @subnet_id : String? = nil,
          @tags : Hash(String, String)? = nil,
          @worker_type : String? = nil
        )
        end
      end


      struct CreateDevEndpointResponse
        include JSON::Serializable

        # The map of arguments used to configure this DevEndpoint . Valid arguments are:
        # "--enable-glue-datacatalog": "" You can specify a version of Python support for development
        # endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no
        # arguments are provided, the version defaults to Python 2.

        @[JSON::Field(key: "Arguments")]
        getter arguments : Hash(String, String)?

        # The Amazon Web Services Availability Zone where this DevEndpoint is located.

        @[JSON::Field(key: "AvailabilityZone")]
        getter availability_zone : String?

        # The point in time at which this DevEndpoint was created.

        @[JSON::Field(key: "CreatedTimestamp", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_timestamp : Time?

        # The name assigned to the new DevEndpoint .

        @[JSON::Field(key: "EndpointName")]
        getter endpoint_name : String?

        # Path to one or more Java .jar files in an S3 bucket that will be loaded in your DevEndpoint .

        @[JSON::Field(key: "ExtraJarsS3Path")]
        getter extra_jars_s3_path : String?

        # The paths to one or more Python libraries in an S3 bucket that will be loaded in your DevEndpoint .

        @[JSON::Field(key: "ExtraPythonLibsS3Path")]
        getter extra_python_libs_s3_path : String?

        # The reason for a current failure in this DevEndpoint .

        @[JSON::Field(key: "FailureReason")]
        getter failure_reason : String?

        # Glue version determines the versions of Apache Spark and Python that Glue supports. The Python
        # version indicates the version supported for running your ETL scripts on development endpoints. For
        # more information about the available Glue versions and corresponding Spark and Python versions, see
        # Glue version in the developer guide.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # The number of Glue Data Processing Units (DPUs) allocated to this DevEndpoint.

        @[JSON::Field(key: "NumberOfNodes")]
        getter number_of_nodes : Int32?

        # The number of workers of a defined workerType that are allocated to the development endpoint.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The Amazon Resource Name (ARN) of the role assigned to the new DevEndpoint .

        @[JSON::Field(key: "RoleArn")]
        getter role_arn : String?

        # The name of the SecurityConfiguration structure being used with this DevEndpoint .

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The security groups assigned to the new DevEndpoint .

        @[JSON::Field(key: "SecurityGroupIds")]
        getter security_group_ids : Array(String)?

        # The current status of the new DevEndpoint .

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The subnet ID assigned to the new DevEndpoint .

        @[JSON::Field(key: "SubnetId")]
        getter subnet_id : String?

        # The ID of the virtual private cloud (VPC) used by this DevEndpoint .

        @[JSON::Field(key: "VpcId")]
        getter vpc_id : String?

        # The type of predefined worker that is allocated to the development endpoint. May be a value of
        # Standard, G.1X, or G.2X.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        # The address of the YARN endpoint used by this DevEndpoint .

        @[JSON::Field(key: "YarnEndpointAddress")]
        getter yarn_endpoint_address : String?

        # The Apache Zeppelin port for the remote Apache Spark interpreter.

        @[JSON::Field(key: "ZeppelinRemoteSparkInterpreterPort")]
        getter zeppelin_remote_spark_interpreter_port : Int32?

        def initialize(
          @arguments : Hash(String, String)? = nil,
          @availability_zone : String? = nil,
          @created_timestamp : Time? = nil,
          @endpoint_name : String? = nil,
          @extra_jars_s3_path : String? = nil,
          @extra_python_libs_s3_path : String? = nil,
          @failure_reason : String? = nil,
          @glue_version : String? = nil,
          @number_of_nodes : Int32? = nil,
          @number_of_workers : Int32? = nil,
          @role_arn : String? = nil,
          @security_configuration : String? = nil,
          @security_group_ids : Array(String)? = nil,
          @status : String? = nil,
          @subnet_id : String? = nil,
          @vpc_id : String? = nil,
          @worker_type : String? = nil,
          @yarn_endpoint_address : String? = nil,
          @zeppelin_remote_spark_interpreter_port : Int32? = nil
        )
        end
      end

      # Request to create a new Glue Identity Center configuration.

      struct CreateGlueIdentityCenterConfigurationRequest
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the Identity Center instance to be associated with the Glue
        # configuration.

        @[JSON::Field(key: "InstanceArn")]
        getter instance_arn : String

        # A list of Identity Center scopes that define the permissions and access levels for the Glue
        # configuration.

        @[JSON::Field(key: "Scopes")]
        getter scopes : Array(String)?

        # Specifies whether users can run background sessions when using Identity Center authentication with
        # Glue services.

        @[JSON::Field(key: "UserBackgroundSessionsEnabled")]
        getter user_background_sessions_enabled : Bool?

        def initialize(
          @instance_arn : String,
          @scopes : Array(String)? = nil,
          @user_background_sessions_enabled : Bool? = nil
        )
        end
      end

      # Response from creating a new Glue Identity Center configuration.

      struct CreateGlueIdentityCenterConfigurationResponse
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the Identity Center application that was created for the Glue
        # configuration.

        @[JSON::Field(key: "ApplicationArn")]
        getter application_arn : String?

        def initialize(
          @application_arn : String? = nil
        )
        end
      end

      # Specifies a grok classifier for CreateClassifier to create.

      struct CreateGrokClassifierRequest
        include JSON::Serializable

        # An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs,
        # Amazon CloudWatch Logs, and so on.

        @[JSON::Field(key: "Classification")]
        getter classification : String

        # The grok pattern used by this classifier.

        @[JSON::Field(key: "GrokPattern")]
        getter grok_pattern : String

        # The name of the new classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Optional custom grok patterns used by this classifier.

        @[JSON::Field(key: "CustomPatterns")]
        getter custom_patterns : String?

        def initialize(
          @classification : String,
          @grok_pattern : String,
          @name : String,
          @custom_patterns : String? = nil
        )
        end
      end

      # The configuration parameters required to create a new Iceberg table in the Glue Data Catalog,
      # including table properties and metadata specifications.

      struct CreateIcebergTableInput
        include JSON::Serializable

        # The S3 location where the Iceberg table data will be stored.

        @[JSON::Field(key: "Location")]
        getter location : String

        # The schema definition that specifies the structure, field types, and metadata for the Iceberg table.

        @[JSON::Field(key: "Schema")]
        getter schema : Types::IcebergSchema

        # The partitioning specification that defines how the Iceberg table data will be organized and
        # partitioned for optimal query performance.

        @[JSON::Field(key: "PartitionSpec")]
        getter partition_spec : Types::IcebergPartitionSpec?

        # Key-value pairs of additional table properties and configuration settings for the Iceberg table.

        @[JSON::Field(key: "Properties")]
        getter properties : Hash(String, String)?

        # The sort order specification that defines how data should be ordered within each partition to
        # optimize query performance.

        @[JSON::Field(key: "WriteOrder")]
        getter write_order : Types::IcebergSortOrder?

        def initialize(
          @location : String,
          @schema : Types::IcebergSchema,
          @partition_spec : Types::IcebergPartitionSpec? = nil,
          @properties : Hash(String, String)? = nil,
          @write_order : Types::IcebergSortOrder? = nil
        )
        end
      end


      struct CreateIntegrationRequest
        include JSON::Serializable

        # A unique name for an integration in Glue.

        @[JSON::Field(key: "IntegrationName")]
        getter integration_name : String

        # The ARN of the source resource for the integration.

        @[JSON::Field(key: "SourceArn")]
        getter source_arn : String

        # The ARN of the target resource for the integration.

        @[JSON::Field(key: "TargetArn")]
        getter target_arn : String

        # An optional set of non-secret keyvalue pairs that contains additional contextual information for
        # encryption. This can only be provided if KMSKeyId is provided.

        @[JSON::Field(key: "AdditionalEncryptionContext")]
        getter additional_encryption_context : Hash(String, String)?

        # Selects source tables for the integration using Maxwell filter syntax.

        @[JSON::Field(key: "DataFilter")]
        getter data_filter : String?

        # A description of the integration.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The configuration settings.

        @[JSON::Field(key: "IntegrationConfig")]
        getter integration_config : Types::IntegrationConfig?

        # The ARN of a KMS key used for encrypting the channel.

        @[JSON::Field(key: "KmsKeyId")]
        getter kms_key_id : String?

        # Metadata assigned to the resource consisting of a list of key-value pairs.

        @[JSON::Field(key: "Tags")]
        getter tags : Array(Types::Tag)?

        def initialize(
          @integration_name : String,
          @source_arn : String,
          @target_arn : String,
          @additional_encryption_context : Hash(String, String)? = nil,
          @data_filter : String? = nil,
          @description : String? = nil,
          @integration_config : Types::IntegrationConfig? = nil,
          @kms_key_id : String? = nil,
          @tags : Array(Types::Tag)? = nil
        )
        end
      end


      struct CreateIntegrationResourcePropertyRequest
        include JSON::Serializable

        # The connection ARN of the source, or the database ARN of the target.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        # The resource properties associated with the integration source.

        @[JSON::Field(key: "SourceProcessingProperties")]
        getter source_processing_properties : Types::SourceProcessingProperties?

        # Metadata assigned to the resource consisting of a list of key-value pairs.

        @[JSON::Field(key: "Tags")]
        getter tags : Array(Types::Tag)?

        # The resource properties associated with the integration target.

        @[JSON::Field(key: "TargetProcessingProperties")]
        getter target_processing_properties : Types::TargetProcessingProperties?

        def initialize(
          @resource_arn : String,
          @source_processing_properties : Types::SourceProcessingProperties? = nil,
          @tags : Array(Types::Tag)? = nil,
          @target_processing_properties : Types::TargetProcessingProperties? = nil
        )
        end
      end


      struct CreateIntegrationResourcePropertyResponse
        include JSON::Serializable

        # The connection ARN of the source, or the database ARN of the target.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        # The resource ARN created through this create API. The format is something like
        # arn:aws:glue:&lt;region&gt;:&lt;account_id&gt;:integrationresourceproperty/*

        @[JSON::Field(key: "ResourcePropertyArn")]
        getter resource_property_arn : String?

        # The resource properties associated with the integration source.

        @[JSON::Field(key: "SourceProcessingProperties")]
        getter source_processing_properties : Types::SourceProcessingProperties?

        # The resource properties associated with the integration target.

        @[JSON::Field(key: "TargetProcessingProperties")]
        getter target_processing_properties : Types::TargetProcessingProperties?

        def initialize(
          @resource_arn : String,
          @resource_property_arn : String? = nil,
          @source_processing_properties : Types::SourceProcessingProperties? = nil,
          @target_processing_properties : Types::TargetProcessingProperties? = nil
        )
        end
      end


      struct CreateIntegrationResponse
        include JSON::Serializable

        # The time when the integration was created, in UTC.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time

        # The Amazon Resource Name (ARN) for the created integration.

        @[JSON::Field(key: "IntegrationArn")]
        getter integration_arn : String

        # A unique name for an integration in Glue.

        @[JSON::Field(key: "IntegrationName")]
        getter integration_name : String

        # The ARN of the source resource for the integration.

        @[JSON::Field(key: "SourceArn")]
        getter source_arn : String

        # The status of the integration being created. The possible statuses are: CREATING: The integration is
        # being created. ACTIVE: The integration creation succeeds. MODIFYING: The integration is being
        # modified. FAILED: The integration creation fails. DELETING: The integration is deleted. SYNCING: The
        # integration is synchronizing. NEEDS_ATTENTION: The integration needs attention, such as
        # synchronization.

        @[JSON::Field(key: "Status")]
        getter status : String

        # The ARN of the target resource for the integration.

        @[JSON::Field(key: "TargetArn")]
        getter target_arn : String

        # An optional set of non-secret keyvalue pairs that contains additional contextual information for
        # encryption.

        @[JSON::Field(key: "AdditionalEncryptionContext")]
        getter additional_encryption_context : Hash(String, String)?

        # Selects source tables for the integration using Maxwell filter syntax.

        @[JSON::Field(key: "DataFilter")]
        getter data_filter : String?

        # A description of the integration.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A list of errors associated with the integration creation.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::IntegrationError)?

        # The configuration settings.

        @[JSON::Field(key: "IntegrationConfig")]
        getter integration_config : Types::IntegrationConfig?

        # The ARN of a KMS key used for encrypting the channel.

        @[JSON::Field(key: "KmsKeyId")]
        getter kms_key_id : String?

        # Metadata assigned to the resource consisting of a list of key-value pairs.

        @[JSON::Field(key: "Tags")]
        getter tags : Array(Types::Tag)?

        def initialize(
          @create_time : Time,
          @integration_arn : String,
          @integration_name : String,
          @source_arn : String,
          @status : String,
          @target_arn : String,
          @additional_encryption_context : Hash(String, String)? = nil,
          @data_filter : String? = nil,
          @description : String? = nil,
          @errors : Array(Types::IntegrationError)? = nil,
          @integration_config : Types::IntegrationConfig? = nil,
          @kms_key_id : String? = nil,
          @tags : Array(Types::Tag)? = nil
        )
        end
      end


      struct CreateIntegrationTablePropertiesRequest
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the target table for which to create integration table properties.
        # Currently, this API only supports creating integration table properties for target tables, and the
        # provided ARN should be the ARN of the target table in the Glue Data Catalog. Support for creating
        # integration table properties for source connections (using the connection ARN) is not yet
        # implemented and will be added in a future release.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        # The name of the table to be replicated.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # A structure for the source table configuration. See the SourceTableConfig structure to see list of
        # supported source properties.

        @[JSON::Field(key: "SourceTableConfig")]
        getter source_table_config : Types::SourceTableConfig?

        # A structure for the target table configuration.

        @[JSON::Field(key: "TargetTableConfig")]
        getter target_table_config : Types::TargetTableConfig?

        def initialize(
          @resource_arn : String,
          @table_name : String,
          @source_table_config : Types::SourceTableConfig? = nil,
          @target_table_config : Types::TargetTableConfig? = nil
        )
        end
      end


      struct CreateIntegrationTablePropertiesResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CreateJobRequest
        include JSON::Serializable

        # The JobCommand that runs this job.

        @[JSON::Field(key: "Command")]
        getter command : Types::JobCommand

        # The name you assign to this job definition. It must be unique in your account.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name or Amazon Resource Name (ARN) of the IAM role associated with this job.

        @[JSON::Field(key: "Role")]
        getter role : String

        # This parameter is deprecated. Use MaxCapacity instead. The number of Glue data processing units
        # (DPUs) to allocate to this Job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a
        # relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of
        # memory. For more information, see the Glue pricing page .

        @[JSON::Field(key: "AllocatedCapacity")]
        getter allocated_capacity : Int32?

        # The representation of a directed acyclic graph on which both the Glue Studio visual component and
        # Glue Studio code generation is based.

        @[JSON::Field(key: "CodeGenConfigurationNodes")]
        getter code_gen_configuration_nodes : Hash(String, Types::CodeGenConfigurationNode)?

        # The connections used for this job.

        @[JSON::Field(key: "Connections")]
        getter connections : Types::ConnectionsList?

        # The default arguments for every run of this job, specified as name-value pairs. You can specify
        # arguments here that your own job-execution script consumes, as well as arguments that Glue itself
        # consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets
        # from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep
        # them within the Job. For information about how to specify and consume your own Job arguments, see
        # the Calling Glue APIs in Python topic in the developer guide. For information about the arguments
        # you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue
        # topic in the developer guide. For information about the arguments you can provide to this field when
        # configuring Ray jobs, see Using job parameters in Ray jobs in the developer guide.

        @[JSON::Field(key: "DefaultArguments")]
        getter default_arguments : Hash(String, String)?

        # Description of the job being defined.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Indicates whether the job is run with a standard or flexible execution class. The standard
        # execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated
        # resources. The flexible execution class is appropriate for time-insensitive jobs whose start and
        # completion times may vary. Only jobs with Glue version 3.0 and above and command type glueetl will
        # be allowed to set ExecutionClass to FLEX . The flexible execution class is available for Spark jobs.

        @[JSON::Field(key: "ExecutionClass")]
        getter execution_class : String?

        # An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.

        @[JSON::Field(key: "ExecutionProperty")]
        getter execution_property : Types::ExecutionProperty?

        # In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in
        # a job. The Python version indicates the version supported for jobs of type Spark. Ray jobs should
        # set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries
        # available in your Ray job are determined by the Runtime parameter of the Job command. For more
        # information about the available Glue versions and corresponding Spark and Python versions, see Glue
        # version in the developer guide. Jobs that are created without specifying a Glue version default to
        # Glue 0.9.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # A mode that describes how a job was created. Valid values are: SCRIPT - The job was created using
        # the Glue Studio script editor. VISUAL - The job was created using the Glue Studio visual editor.
        # NOTEBOOK - The job was created using an interactive sessions notebook. When the JobMode field is
        # missing or null, SCRIPT is assigned as the default value.

        @[JSON::Field(key: "JobMode")]
        getter job_mode : String?

        # Specifies whether job run queuing is enabled for the job runs for this job. A value of true means
        # job run queuing is enabled for the job runs. If false or not populated, the job runs will not be
        # considered for queueing. If this field does not match the value set in the job run, then the value
        # from the job run field will be used.

        @[JSON::Field(key: "JobRunQueuingEnabled")]
        getter job_run_queuing_enabled : Bool?

        # This field is reserved for future use.

        @[JSON::Field(key: "LogUri")]
        getter log_uri : String?

        # This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue
        # periodically performs maintenance activities. During these maintenance windows, Glue will need to
        # restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance
        # window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will
        # be restarted between 10:00AM GMT to 1:00PM GMT.

        @[JSON::Field(key: "MaintenanceWindow")]
        getter maintenance_window : String?

        # For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data
        # processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of
        # processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
        # information, see the Glue pricing page . For Glue version 2.0+ jobs, you cannot specify a Maximum
        # capacity . Instead, you should specify a Worker type and the Number of workers . Do not set
        # MaxCapacity if using WorkerType and NumberOfWorkers . The value that can be allocated for
        # MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an
        # Apache Spark streaming ETL job: When you specify a Python shell job ( JobCommand.Name
        # ="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. When you
        # specify an Apache Spark ETL job ( JobCommand.Name ="glueetl") or Apache Spark streaming ETL job (
        # JobCommand.Name ="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This
        # job type cannot have a fractional DPU allocation.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # The maximum number of times to retry this job if it fails.

        @[JSON::Field(key: "MaxRetries")]
        getter max_retries : Int32?

        # Arguments for this job that are not overridden when providing job arguments in a job run, specified
        # as name-value pairs.

        @[JSON::Field(key: "NonOverridableArguments")]
        getter non_overridable_arguments : Hash(String, String)?

        # Specifies configuration properties of a job notification.

        @[JSON::Field(key: "NotificationProperty")]
        getter notification_property : Types::NotificationProperty?

        # The number of workers of a defined workerType that are allocated when a job runs.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The name of the SecurityConfiguration structure to be used with this job.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The details for a source control configuration for a job, allowing synchronization of job artifacts
        # to or from a remote repository.

        @[JSON::Field(key: "SourceControlDetails")]
        getter source_control_details : Types::SourceControlDetails?

        # The tags to use with this job. You may use tags to limit access to the job. For more information
        # about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        # The job timeout in minutes. This is the maximum time that a job run can consume resources before it
        # is terminated and enters TIMEOUT status. Jobs must have timeout values less than 7 days or 10080
        # minutes. Otherwise, the jobs will throw an exception. When the value is left blank, the timeout is
        # defaulted to 2880 minutes. Any existing Glue jobs that had a timeout value greater than 7 days will
        # be defaulted to 7 days. For instance if you have specified a timeout of 20 days for a batch job, it
        # will be stopped on the 7th day. For streaming jobs, if you have set up a maintenance window, it will
        # be restarted during the maintenance window after 7 days.

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        # The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X,
        # G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs. For the G.1X worker type,
        # each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 94GB disk, and provides 1 executor per
        # worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to
        # offers a scalable and cost effective way to run most jobs. For the G.2X worker type, each worker
        # maps to 2 DPU (8 vCPUs, 32 GB of memory) with 138GB disk, and provides 1 executor per worker. We
        # recommend this worker type for workloads such as data transforms, joins, and queries, to offers a
        # scalable and cost effective way to run most jobs. For the G.4X worker type, each worker maps to 4
        # DPU (16 vCPUs, 64 GB of memory) with 256GB disk, and provides 1 executor per worker. We recommend
        # this worker type for jobs whose workloads contain your most demanding transforms, aggregations,
        # joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs
        # in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West (N.
        # California), US West (Oregon), Asia Pacific (Mumbai), Asia Pacific (Seoul), Asia Pacific
        # (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central), Europe (Frankfurt),
        # Europe (Ireland), Europe (London), Europe (Spain), Europe (Stockholm), and South America (So
        # Paulo). For the G.8X worker type, each worker maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB
        # disk, and provides 1 executor per worker. We recommend this worker type for jobs whose workloads
        # contain your most demanding transforms, aggregations, joins, and queries. This worker type is
        # available only for Glue version 3.0 or later Spark ETL jobs, in the same Amazon Web Services Regions
        # as supported for the G.4X worker type. For the G.025X worker type, each worker maps to 0.25 DPU (2
        # vCPUs, 4 GB of memory) with 84GB disk, and provides 1 executor per worker. We recommend this worker
        # type for low volume streaming jobs. This worker type is only available for Glue version 3.0 or later
        # streaming jobs. For the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with
        # 128 GB disk, and provides up to 8 Ray workers based on the autoscaler.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @command : Types::JobCommand,
          @name : String,
          @role : String,
          @allocated_capacity : Int32? = nil,
          @code_gen_configuration_nodes : Hash(String, Types::CodeGenConfigurationNode)? = nil,
          @connections : Types::ConnectionsList? = nil,
          @default_arguments : Hash(String, String)? = nil,
          @description : String? = nil,
          @execution_class : String? = nil,
          @execution_property : Types::ExecutionProperty? = nil,
          @glue_version : String? = nil,
          @job_mode : String? = nil,
          @job_run_queuing_enabled : Bool? = nil,
          @log_uri : String? = nil,
          @maintenance_window : String? = nil,
          @max_capacity : Float64? = nil,
          @max_retries : Int32? = nil,
          @non_overridable_arguments : Hash(String, String)? = nil,
          @notification_property : Types::NotificationProperty? = nil,
          @number_of_workers : Int32? = nil,
          @security_configuration : String? = nil,
          @source_control_details : Types::SourceControlDetails? = nil,
          @tags : Hash(String, String)? = nil,
          @timeout : Int32? = nil,
          @worker_type : String? = nil
        )
        end
      end


      struct CreateJobResponse
        include JSON::Serializable

        # The unique name that was provided for this job definition.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end

      # Specifies a JSON classifier for CreateClassifier to create.

      struct CreateJsonClassifierRequest
        include JSON::Serializable

        # A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of
        # JsonPath, as described in Writing JsonPath Custom Classifiers .

        @[JSON::Field(key: "JsonPath")]
        getter json_path : String

        # The name of the classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @json_path : String,
          @name : String
        )
        end
      end


      struct CreateMLTransformRequest
        include JSON::Serializable

        # A list of Glue table definitions used by the transform.

        @[JSON::Field(key: "InputRecordTables")]
        getter input_record_tables : Array(Types::GlueTable)

        # The unique name that you give the transform when you create it.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The algorithmic parameters that are specific to the transform type used. Conditionally dependent on
        # the transform type.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Types::TransformParameters

        # The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required
        # permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions
        # required by the transform. This role needs Glue service role permissions to allow access to
        # resources in Glue. See Attach a Policy to IAM Users That Access Glue . This role needs permission to
        # your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and
        # any libraries used by the task run for this transform.

        @[JSON::Field(key: "Role")]
        getter role : String

        # A description of the machine learning transform that is being defined. The default is an empty
        # string.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # This value determines which version of Glue this machine learning transform is compatible with. Glue
        # 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to
        # Glue 0.9. For more information, see Glue Versions in the developer guide.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # The number of Glue data processing units (DPUs) that are allocated to task runs for this transform.
        # You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing
        # power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see
        # the Glue pricing page . MaxCapacity is a mutually exclusive option with NumberOfWorkers and
        # WorkerType . If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set. If
        # MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set. If WorkerType is set, then
        # NumberOfWorkers is required (and vice versa). MaxCapacity and NumberOfWorkers must both be at least
        # 1. When the WorkerType field is set to a value other than Standard , the MaxCapacity field is set
        # automatically and becomes read-only. When the WorkerType field is set to a value other than Standard
        # , the MaxCapacity field is set automatically and becomes read-only.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # The maximum number of times to retry a task for this transform after a task run fails.

        @[JSON::Field(key: "MaxRetries")]
        getter max_retries : Int32?

        # The number of workers of a defined workerType that are allocated when this task runs. If WorkerType
        # is set, then NumberOfWorkers is required (and vice versa).

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The tags to use with this machine learning transform. You may use tags to limit access to the
        # machine learning transform. For more information about tags in Glue, see Amazon Web Services Tags in
        # Glue in the developer guide.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        # The timeout of the task run for this transform in minutes. This is the maximum time that a task run
        # for this transform can consume resources before it is terminated and enters TIMEOUT status. The
        # default is 2,880 minutes (48 hours).

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        # The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning
        # transforms can access user data encrypted in Amazon S3 using KMS.

        @[JSON::Field(key: "TransformEncryption")]
        getter transform_encryption : Types::TransformEncryption?

        # The type of predefined worker that is allocated when this task runs. Accepts a value of Standard,
        # G.1X, or G.2X. For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB
        # disk, and 2 executors per worker. For the G.1X worker type, each worker provides 4 vCPU, 16 GB of
        # memory and a 64GB disk, and 1 executor per worker. For the G.2X worker type, each worker provides 8
        # vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker. MaxCapacity is a mutually
        # exclusive option with NumberOfWorkers and WorkerType . If either NumberOfWorkers or WorkerType is
        # set, then MaxCapacity cannot be set. If MaxCapacity is set then neither NumberOfWorkers or
        # WorkerType can be set. If WorkerType is set, then NumberOfWorkers is required (and vice versa).
        # MaxCapacity and NumberOfWorkers must both be at least 1.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @input_record_tables : Array(Types::GlueTable),
          @name : String,
          @parameters : Types::TransformParameters,
          @role : String,
          @description : String? = nil,
          @glue_version : String? = nil,
          @max_capacity : Float64? = nil,
          @max_retries : Int32? = nil,
          @number_of_workers : Int32? = nil,
          @tags : Hash(String, String)? = nil,
          @timeout : Int32? = nil,
          @transform_encryption : Types::TransformEncryption? = nil,
          @worker_type : String? = nil
        )
        end
      end


      struct CreateMLTransformResponse
        include JSON::Serializable

        # A unique identifier that is generated for the transform.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String?

        def initialize(
          @transform_id : String? = nil
        )
        end
      end


      struct CreatePartitionIndexRequest
        include JSON::Serializable

        # Specifies the name of a database in which you want to create a partition index.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # Specifies a PartitionIndex structure to create a partition index in an existing table.

        @[JSON::Field(key: "PartitionIndex")]
        getter partition_index : Types::PartitionIndex

        # Specifies the name of a table in which you want to create a partition index.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The catalog ID where the table resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @partition_index : Types::PartitionIndex,
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct CreatePartitionIndexResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CreatePartitionRequest
        include JSON::Serializable

        # The name of the metadata database in which the partition is to be created.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A PartitionInput structure defining the partition to be created.

        @[JSON::Field(key: "PartitionInput")]
        getter partition_input : Types::PartitionInput

        # The name of the metadata table in which the partition is to be created.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The Amazon Web Services account ID of the catalog in which the partition is to be created.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @partition_input : Types::PartitionInput,
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct CreatePartitionResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CreateRegistryInput
        include JSON::Serializable

        # Name of the registry to be created of max length of 255, and may only contain letters, numbers,
        # hyphen, underscore, dollar sign, or hash mark. No whitespace.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String

        # A description of the registry. If description is not provided, there will not be any default value
        # for this.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Amazon Web Services tags that contain a key value pair and may be searched by console, command line,
        # or API.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @registry_name : String,
          @description : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateRegistryResponse
        include JSON::Serializable

        # A description of the registry.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The Amazon Resource Name (ARN) of the newly created registry.

        @[JSON::Field(key: "RegistryArn")]
        getter registry_arn : String?

        # The name of the registry.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The tags for the registry.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @description : String? = nil,
          @registry_arn : String? = nil,
          @registry_name : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateSchemaInput
        include JSON::Serializable

        # The data format of the schema definition. Currently AVRO , JSON and PROTOBUF are supported.

        @[JSON::Field(key: "DataFormat")]
        getter data_format : String

        # Name of the schema to be created of max length of 255, and may only contain letters, numbers,
        # hyphen, underscore, dollar sign, or hash mark. No whitespace.

        @[JSON::Field(key: "SchemaName")]
        getter schema_name : String

        # The compatibility mode of the schema. The possible values are: NONE : No compatibility mode applies.
        # You can use this choice in development scenarios or if you do not know the compatibility mode that
        # you want to apply to schemas. Any new version added will be accepted without undergoing a
        # compatibility check. DISABLED : This compatibility choice prevents versioning for a particular
        # schema. You can use this choice to prevent future versioning of a schema. BACKWARD : This
        # compatibility choice is recommended as it allows data receivers to read both the current and one
        # previous schema version. This means that for instance, a new schema version cannot drop data fields
        # or change the type of these fields, so they can't be read by readers using the previous version.
        # BACKWARD_ALL : This compatibility choice allows data receivers to read both the current and all
        # previous schema versions. You can use this choice when you need to delete fields or add optional
        # fields, and check compatibility against all previous schema versions. FORWARD : This compatibility
        # choice allows data receivers to read both the current and one next schema version, but not
        # necessarily later versions. You can use this choice when you need to add fields or delete optional
        # fields, but only check compatibility against the last schema version. FORWARD_ALL : This
        # compatibility choice allows data receivers to read written by producers of any new registered
        # schema. You can use this choice when you need to add fields or delete optional fields, and check
        # compatibility against all previous schema versions. FULL : This compatibility choice allows data
        # receivers to read data written by producers using the previous or next version of the schema, but
        # not necessarily earlier or later versions. You can use this choice when you need to add or remove
        # optional fields, but only check compatibility against the last schema version. FULL_ALL : This
        # compatibility choice allows data receivers to read data written by producers using all previous
        # schema versions. You can use this choice when you need to add or remove optional fields, and check
        # compatibility against all previous schema versions.

        @[JSON::Field(key: "Compatibility")]
        getter compatibility : String?

        # An optional description of the schema. If description is not provided, there will not be any
        # automatic default value for this.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # This is a wrapper shape to contain the registry identity fields. If this is not provided, the
        # default registry will be used. The ARN format for the same will be:
        # arn:aws:glue:us-east-2:&lt;customer id&gt;:registry/default-registry:random-5-letter-id .

        @[JSON::Field(key: "RegistryId")]
        getter registry_id : Types::RegistryId?

        # The schema definition using the DataFormat setting for SchemaName .

        @[JSON::Field(key: "SchemaDefinition")]
        getter schema_definition : String?

        # Amazon Web Services tags that contain a key value pair and may be searched by console, command line,
        # or API. If specified, follows the Amazon Web Services tags-on-create pattern.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @data_format : String,
          @schema_name : String,
          @compatibility : String? = nil,
          @description : String? = nil,
          @registry_id : Types::RegistryId? = nil,
          @schema_definition : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateSchemaResponse
        include JSON::Serializable

        # The schema compatibility mode.

        @[JSON::Field(key: "Compatibility")]
        getter compatibility : String?

        # The data format of the schema definition. Currently AVRO , JSON and PROTOBUF are supported.

        @[JSON::Field(key: "DataFormat")]
        getter data_format : String?

        # A description of the schema if specified when created.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The latest version of the schema associated with the returned schema definition.

        @[JSON::Field(key: "LatestSchemaVersion")]
        getter latest_schema_version : Int64?

        # The next version of the schema associated with the returned schema definition.

        @[JSON::Field(key: "NextSchemaVersion")]
        getter next_schema_version : Int64?

        # The Amazon Resource Name (ARN) of the registry.

        @[JSON::Field(key: "RegistryArn")]
        getter registry_arn : String?

        # The name of the registry.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The Amazon Resource Name (ARN) of the schema.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The version number of the checkpoint (the last time the compatibility mode was changed).

        @[JSON::Field(key: "SchemaCheckpoint")]
        getter schema_checkpoint : Int64?

        # The name of the schema.

        @[JSON::Field(key: "SchemaName")]
        getter schema_name : String?

        # The status of the schema.

        @[JSON::Field(key: "SchemaStatus")]
        getter schema_status : String?

        # The unique identifier of the first schema version.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The status of the first schema version created.

        @[JSON::Field(key: "SchemaVersionStatus")]
        getter schema_version_status : String?

        # The tags for the schema.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @compatibility : String? = nil,
          @data_format : String? = nil,
          @description : String? = nil,
          @latest_schema_version : Int64? = nil,
          @next_schema_version : Int64? = nil,
          @registry_arn : String? = nil,
          @registry_name : String? = nil,
          @schema_arn : String? = nil,
          @schema_checkpoint : Int64? = nil,
          @schema_name : String? = nil,
          @schema_status : String? = nil,
          @schema_version_id : String? = nil,
          @schema_version_status : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateScriptRequest
        include JSON::Serializable

        # A list of the edges in the DAG.

        @[JSON::Field(key: "DagEdges")]
        getter dag_edges : Array(Types::CodeGenEdge)?

        # A list of the nodes in the DAG.

        @[JSON::Field(key: "DagNodes")]
        getter dag_nodes : Array(Types::CodeGenNode)?

        # The programming language of the resulting code from the DAG.

        @[JSON::Field(key: "Language")]
        getter language : String?

        def initialize(
          @dag_edges : Array(Types::CodeGenEdge)? = nil,
          @dag_nodes : Array(Types::CodeGenNode)? = nil,
          @language : String? = nil
        )
        end
      end


      struct CreateScriptResponse
        include JSON::Serializable

        # The Python script generated from the DAG.

        @[JSON::Field(key: "PythonScript")]
        getter python_script : String?

        # The Scala code generated from the DAG.

        @[JSON::Field(key: "ScalaCode")]
        getter scala_code : String?

        def initialize(
          @python_script : String? = nil,
          @scala_code : String? = nil
        )
        end
      end


      struct CreateSecurityConfigurationRequest
        include JSON::Serializable

        # The encryption configuration for the new security configuration.

        @[JSON::Field(key: "EncryptionConfiguration")]
        getter encryption_configuration : Types::EncryptionConfiguration

        # The name for the new security configuration.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @encryption_configuration : Types::EncryptionConfiguration,
          @name : String
        )
        end
      end


      struct CreateSecurityConfigurationResponse
        include JSON::Serializable

        # The time at which the new security configuration was created.

        @[JSON::Field(key: "CreatedTimestamp", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_timestamp : Time?

        # The name assigned to the new security configuration.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @created_timestamp : Time? = nil,
          @name : String? = nil
        )
        end
      end

      # Request to create a new session.

      struct CreateSessionRequest
        include JSON::Serializable

        # The SessionCommand that runs the job.

        @[JSON::Field(key: "Command")]
        getter command : Types::SessionCommand

        # The ID of the session request.

        @[JSON::Field(key: "Id")]
        getter id : String

        # The IAM Role ARN

        @[JSON::Field(key: "Role")]
        getter role : String

        # The number of connections to use for the session.

        @[JSON::Field(key: "Connections")]
        getter connections : Types::ConnectionsList?

        # A map array of key-value pairs. Max is 75 pairs.

        @[JSON::Field(key: "DefaultArguments")]
        getter default_arguments : Hash(String, String)?

        # The description of the session.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The Glue version determines the versions of Apache Spark and Python that Glue supports. The
        # GlueVersion must be greater than 2.0.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # The number of minutes when idle before session times out. Default for Spark ETL jobs is value of
        # Timeout. Consult the documentation for other job types.

        @[JSON::Field(key: "IdleTimeout")]
        getter idle_timeout : Int32?

        # The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a
        # relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # The number of workers of a defined WorkerType to use for the session.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The origin of the request.

        @[JSON::Field(key: "RequestOrigin")]
        getter request_origin : String?

        # The name of the SecurityConfiguration structure to be used with the session

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The map of key value pairs (tags) belonging to the session.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        # The number of minutes before session times out. Default for Spark ETL jobs is 48 hours (2880
        # minutes). Consult the documentation for other job types.

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        # The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X,
        # G.4X, or G.8X for Spark jobs. Accepts the value Z.2X for Ray notebooks. For the G.1X worker type,
        # each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 94GB disk, and provides 1 executor per
        # worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to
        # offers a scalable and cost effective way to run most jobs. For the G.2X worker type, each worker
        # maps to 2 DPU (8 vCPUs, 32 GB of memory) with 138GB disk, and provides 1 executor per worker. We
        # recommend this worker type for workloads such as data transforms, joins, and queries, to offers a
        # scalable and cost effective way to run most jobs. For the G.4X worker type, each worker maps to 4
        # DPU (16 vCPUs, 64 GB of memory) with 256GB disk, and provides 1 executor per worker. We recommend
        # this worker type for jobs whose workloads contain your most demanding transforms, aggregations,
        # joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs
        # in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West
        # (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central),
        # Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm). For the G.8X worker type, each worker
        # maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk, and provides 1 executor per worker. We
        # recommend this worker type for jobs whose workloads contain your most demanding transforms,
        # aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later
        # Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type. For
        # the Z.2X worker type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk, and
        # provides up to 8 Ray workers based on the autoscaler.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @command : Types::SessionCommand,
          @id : String,
          @role : String,
          @connections : Types::ConnectionsList? = nil,
          @default_arguments : Hash(String, String)? = nil,
          @description : String? = nil,
          @glue_version : String? = nil,
          @idle_timeout : Int32? = nil,
          @max_capacity : Float64? = nil,
          @number_of_workers : Int32? = nil,
          @request_origin : String? = nil,
          @security_configuration : String? = nil,
          @tags : Hash(String, String)? = nil,
          @timeout : Int32? = nil,
          @worker_type : String? = nil
        )
        end
      end


      struct CreateSessionResponse
        include JSON::Serializable

        # Returns the session object in the response.

        @[JSON::Field(key: "Session")]
        getter session : Types::Session?

        def initialize(
          @session : Types::Session? = nil
        )
        end
      end


      struct CreateTableOptimizerRequest
        include JSON::Serializable

        # The Catalog ID of the table.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # The name of the database in the catalog in which the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # A TableOptimizerConfiguration object representing the configuration of a table optimizer.

        @[JSON::Field(key: "TableOptimizerConfiguration")]
        getter table_optimizer_configuration : Types::TableOptimizerConfiguration

        # The type of table optimizer.

        @[JSON::Field(key: "Type")]
        getter type : String

        def initialize(
          @catalog_id : String,
          @database_name : String,
          @table_name : String,
          @table_optimizer_configuration : Types::TableOptimizerConfiguration,
          @type : String
        )
        end
      end


      struct CreateTableOptimizerResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CreateTableRequest
        include JSON::Serializable

        # The catalog database in which to create the new table. For Hive compatibility, this name is entirely
        # lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The ID of the Data Catalog in which to create the Table . If none is supplied, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The unique identifier for the table within the specified database that will be created in the Glue
        # Data Catalog.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # Specifies an OpenTableFormatInput structure when creating an open format table.

        @[JSON::Field(key: "OpenTableFormatInput")]
        getter open_table_format_input : Types::OpenTableFormatInput?

        # A list of partition indexes, PartitionIndex structures, to create in the table.

        @[JSON::Field(key: "PartitionIndexes")]
        getter partition_indexes : Array(Types::PartitionIndex)?

        # The TableInput object that defines the metadata table to create in the catalog.

        @[JSON::Field(key: "TableInput")]
        getter table_input : Types::TableInput?

        # The ID of the transaction.

        @[JSON::Field(key: "TransactionId")]
        getter transaction_id : String?

        def initialize(
          @database_name : String,
          @catalog_id : String? = nil,
          @name : String? = nil,
          @open_table_format_input : Types::OpenTableFormatInput? = nil,
          @partition_indexes : Array(Types::PartitionIndex)? = nil,
          @table_input : Types::TableInput? = nil,
          @transaction_id : String? = nil
        )
        end
      end


      struct CreateTableResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CreateTriggerRequest
        include JSON::Serializable

        # The actions initiated by this trigger when it fires.

        @[JSON::Field(key: "Actions")]
        getter actions : Array(Types::Action)

        # The name of the trigger.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The type of the new trigger.

        @[JSON::Field(key: "Type")]
        getter type : String

        # A description of the new trigger.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Batch condition that must be met (specified number of events received or batch time window expired)
        # before EventBridge event trigger fires.

        @[JSON::Field(key: "EventBatchingCondition")]
        getter event_batching_condition : Types::EventBatchingCondition?

        # A predicate to specify when the new trigger should fire. This field is required when the trigger
        # type is CONDITIONAL .

        @[JSON::Field(key: "Predicate")]
        getter predicate : Types::Predicate?

        # A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers . For
        # example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *) . This
        # field is required when the trigger type is SCHEDULED.

        @[JSON::Field(key: "Schedule")]
        getter schedule : String?

        # Set to true to start SCHEDULED and CONDITIONAL triggers when created. True is not supported for
        # ON_DEMAND triggers.

        @[JSON::Field(key: "StartOnCreation")]
        getter start_on_creation : Bool?

        # The tags to use with this trigger. You may use tags to limit access to the trigger. For more
        # information about tags in Glue, see Amazon Web Services Tags in Glue in the developer guide.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        # The name of the workflow associated with the trigger.

        @[JSON::Field(key: "WorkflowName")]
        getter workflow_name : String?

        def initialize(
          @actions : Array(Types::Action),
          @name : String,
          @type : String,
          @description : String? = nil,
          @event_batching_condition : Types::EventBatchingCondition? = nil,
          @predicate : Types::Predicate? = nil,
          @schedule : String? = nil,
          @start_on_creation : Bool? = nil,
          @tags : Hash(String, String)? = nil,
          @workflow_name : String? = nil
        )
        end
      end


      struct CreateTriggerResponse
        include JSON::Serializable

        # The name of the trigger.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct CreateUsageProfileRequest
        include JSON::Serializable

        # A ProfileConfiguration object specifying the job and session values for the profile.

        @[JSON::Field(key: "Configuration")]
        getter configuration : Types::ProfileConfiguration

        # The name of the usage profile.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A description of the usage profile.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A list of tags applied to the usage profile.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @configuration : Types::ProfileConfiguration,
          @name : String,
          @description : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateUsageProfileResponse
        include JSON::Serializable

        # The name of the usage profile that was created.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct CreateUserDefinedFunctionRequest
        include JSON::Serializable

        # The name of the catalog database in which to create the function.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A FunctionInput object that defines the function to create in the Data Catalog.

        @[JSON::Field(key: "FunctionInput")]
        getter function_input : Types::UserDefinedFunctionInput

        # The ID of the Data Catalog in which to create the function. If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @function_input : Types::UserDefinedFunctionInput,
          @catalog_id : String? = nil
        )
        end
      end


      struct CreateUserDefinedFunctionResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct CreateWorkflowRequest
        include JSON::Serializable

        # The name to be assigned to the workflow. It should be unique within your account.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A collection of properties to be used as part of each execution of the workflow. Run properties may
        # be logged. Do not pass plaintext secrets as properties. Retrieve secrets from a Glue Connection,
        # Amazon Web Services Secrets Manager or other secret management mechanism if you intend to use them
        # within the workflow run.

        @[JSON::Field(key: "DefaultRunProperties")]
        getter default_run_properties : Hash(String, String)?

        # A description of the workflow.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in
        # some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs.
        # If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.

        @[JSON::Field(key: "MaxConcurrentRuns")]
        getter max_concurrent_runs : Int32?

        # The tags to be used with this workflow.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @name : String,
          @default_run_properties : Hash(String, String)? = nil,
          @description : String? = nil,
          @max_concurrent_runs : Int32? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct CreateWorkflowResponse
        include JSON::Serializable

        # The name of the workflow which was provided as part of the request.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end

      # Specifies an XML classifier for CreateClassifier to create.

      struct CreateXMLClassifierRequest
        include JSON::Serializable

        # An identifier of the data format that the classifier matches.

        @[JSON::Field(key: "Classification")]
        getter classification : String

        # The name of the classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The XML tag designating the element that contains each record in an XML document being parsed. This
        # can't identify a self-closing element (closed by /&gt; ). An empty row element that contains only
        # attributes can be parsed as long as it ends with a closing tag (for example, &lt;row item_a="A"
        # item_b="B"&gt;&lt;/row&gt; is okay, but &lt;row item_a="A" item_b="B" /&gt; is not).

        @[JSON::Field(key: "RowTag")]
        getter row_tag : String?

        def initialize(
          @classification : String,
          @name : String,
          @row_tag : String? = nil
        )
        end
      end

      # A classifier for custom CSV content.

      struct CsvClassifier
        include JSON::Serializable

        # The name of the classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Enables the processing of files that contain only one column.

        @[JSON::Field(key: "AllowSingleColumn")]
        getter allow_single_column : Bool?

        # Indicates whether the CSV file contains a header.

        @[JSON::Field(key: "ContainsHeader")]
        getter contains_header : String?

        # The time that this classifier was registered.

        @[JSON::Field(key: "CreationTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter creation_time : Time?

        # Enables the custom datatype to be configured.

        @[JSON::Field(key: "CustomDatatypeConfigured")]
        getter custom_datatype_configured : Bool?

        # A list of custom datatypes including "BINARY", "BOOLEAN", "DATE", "DECIMAL", "DOUBLE", "FLOAT",
        # "INT", "LONG", "SHORT", "STRING", "TIMESTAMP".

        @[JSON::Field(key: "CustomDatatypes")]
        getter custom_datatypes : Array(String)?

        # A custom symbol to denote what separates each column entry in the row.

        @[JSON::Field(key: "Delimiter")]
        getter delimiter : String?

        # Specifies not to trim values before identifying the type of column values. The default value is true
        # .

        @[JSON::Field(key: "DisableValueTrimming")]
        getter disable_value_trimming : Bool?

        # A list of strings representing column names.

        @[JSON::Field(key: "Header")]
        getter header : Array(String)?

        # The time that this classifier was last updated.

        @[JSON::Field(key: "LastUpdated", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_updated : Time?

        # A custom symbol to denote what combines content into a single column value. It must be different
        # from the column delimiter.

        @[JSON::Field(key: "QuoteSymbol")]
        getter quote_symbol : String?

        # Sets the SerDe for processing CSV in the classifier, which will be applied in the Data Catalog.
        # Valid values are OpenCSVSerDe , LazySimpleSerDe , and None . You can specify the None value when you
        # want the crawler to do the detection.

        @[JSON::Field(key: "Serde")]
        getter serde : String?

        # The version of this classifier.

        @[JSON::Field(key: "Version")]
        getter version : Int64?

        def initialize(
          @name : String,
          @allow_single_column : Bool? = nil,
          @contains_header : String? = nil,
          @creation_time : Time? = nil,
          @custom_datatype_configured : Bool? = nil,
          @custom_datatypes : Array(String)? = nil,
          @delimiter : String? = nil,
          @disable_value_trimming : Bool? = nil,
          @header : Array(String)? = nil,
          @last_updated : Time? = nil,
          @quote_symbol : String? = nil,
          @serde : String? = nil,
          @version : Int64? = nil
        )
        end
      end

      # Specifies a transform that uses custom code you provide to perform the data transformation. The
      # output is a collection of DynamicFrames.

      struct CustomCode
        include JSON::Serializable

        # The name defined for the custom code node class.

        @[JSON::Field(key: "ClassName")]
        getter class_name : String

        # The custom code that is used to perform the data transformation.

        @[JSON::Field(key: "Code")]
        getter code : String

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Specifies the data schema for the custom code transform.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @class_name : String,
          @code : String,
          @inputs : Array(String),
          @name : String,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # An object representing a custom pattern for detecting sensitive data across the columns and rows of
      # your structured data.

      struct CustomEntityType
        include JSON::Serializable

        # A name for the custom pattern that allows it to be retrieved or deleted later. This name must be
        # unique per Amazon Web Services account.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A regular expression string that is used for detecting sensitive data in a custom pattern.

        @[JSON::Field(key: "RegexString")]
        getter regex_string : String

        # A list of context words. If none of these context words are found within the vicinity of the regular
        # expression the data will not be detected as sensitive data. If no context words are passed only a
        # regular expression is checked.

        @[JSON::Field(key: "ContextWords")]
        getter context_words : Array(String)?

        def initialize(
          @name : String,
          @regex_string : String,
          @context_words : Array(String)? = nil
        )
        end
      end

      # Specifies additional options for DynamoDB ELT catalog operations.

      struct DDBELTCatalogAdditionalOptions
        include JSON::Serializable

        # Specifies the DynamoDB export configuration for the ELT operation.

        @[JSON::Field(key: "DynamodbExport")]
        getter dynamodb_export : String?

        # Specifies whether to unnest DynamoDB JSON format. When set to true , nested JSON structures in
        # DynamoDB items are flattened.

        @[JSON::Field(key: "DynamodbUnnestDDBJson")]
        getter dynamodb_unnest_ddb_json : Bool?

        def initialize(
          @dynamodb_export : String? = nil,
          @dynamodb_unnest_ddb_json : Bool? = nil
        )
        end
      end

      # Specifies connection options for DynamoDB ELT (Extract, Load, Transform) operations. This structure
      # contains configuration parameters for connecting to and extracting data from DynamoDB tables using
      # the ELT connector.

      struct DDBELTConnectionOptions
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the DynamoDB table to extract data from. This parameter specifies
        # the source table for the ELT operation.

        @[JSON::Field(key: "DynamodbTableArn")]
        getter dynamodb_table_arn : String

        # Specifies the export type for DynamoDB data extraction. This parameter determines how data is
        # exported from the DynamoDB table during the ELT process.

        @[JSON::Field(key: "DynamodbExport")]
        getter dynamodb_export : String?

        # The name of the Amazon S3 bucket used for intermediate storage during the DynamoDB ELT process. This
        # bucket is used to temporarily store exported DynamoDB data before it is processed by the ELT job.

        @[JSON::Field(key: "DynamodbS3Bucket")]
        getter dynamodb_s3_bucket : String?

        # The Amazon Web Services account ID of the owner of the S3 bucket specified in DynamodbS3Bucket .
        # This parameter is required when the S3 bucket is owned by a different Amazon Web Services account
        # than the one running the ELT job, enabling cross-account access to the intermediate storage bucket.

        @[JSON::Field(key: "DynamodbS3BucketOwner")]
        getter dynamodb_s3_bucket_owner : String?

        # The S3 object key prefix for files stored in the intermediate S3 bucket during the DynamoDB ELT
        # process. This prefix helps organize and identify the temporary files created during data extraction.

        @[JSON::Field(key: "DynamodbS3Prefix")]
        getter dynamodb_s3_prefix : String?

        # The Amazon Resource Name (ARN) of the Amazon Web Services Security Token Service (STS) role to
        # assume for accessing DynamoDB and S3 resources during the ELT operation. This role must have the
        # necessary permissions to read from the DynamoDB table and write to the intermediate S3 bucket.

        @[JSON::Field(key: "DynamodbStsRoleArn")]
        getter dynamodb_sts_role_arn : String?

        # A boolean value that specifies whether to unnest DynamoDB JSON format during data extraction. When
        # set to true , the connector will flatten nested JSON structures from DynamoDB items. When set to
        # false , the original DynamoDB JSON structure is preserved.

        @[JSON::Field(key: "DynamodbUnnestDDBJson")]
        getter dynamodb_unnest_ddb_json : Bool?

        def initialize(
          @dynamodb_table_arn : String,
          @dynamodb_export : String? = nil,
          @dynamodb_s3_bucket : String? = nil,
          @dynamodb_s3_bucket_owner : String? = nil,
          @dynamodb_s3_prefix : String? = nil,
          @dynamodb_sts_role_arn : String? = nil,
          @dynamodb_unnest_ddb_json : Bool? = nil
        )
        end
      end

      # Options to configure how your data quality evaluation results are published.

      struct DQResultsPublishingOptions
        include JSON::Serializable

        # Enable metrics for your data quality results.

        @[JSON::Field(key: "CloudWatchMetricsEnabled")]
        getter cloud_watch_metrics_enabled : Bool?

        # The context of the evaluation.

        @[JSON::Field(key: "EvaluationContext")]
        getter evaluation_context : String?

        # Enable publishing for your data quality results.

        @[JSON::Field(key: "ResultsPublishingEnabled")]
        getter results_publishing_enabled : Bool?

        # The Amazon S3 prefix prepended to the results.

        @[JSON::Field(key: "ResultsS3Prefix")]
        getter results_s3_prefix : String?

        def initialize(
          @cloud_watch_metrics_enabled : Bool? = nil,
          @evaluation_context : String? = nil,
          @results_publishing_enabled : Bool? = nil,
          @results_s3_prefix : String? = nil
        )
        end
      end

      # Options to configure how your job will stop if your data quality evaluation fails.

      struct DQStopJobOnFailureOptions
        include JSON::Serializable

        # When to stop job if your data quality evaluation fails. Options are Immediate or AfterDataLoad.

        @[JSON::Field(key: "StopJobOnFailureTiming")]
        getter stop_job_on_failure_timing : String?

        def initialize(
          @stop_job_on_failure_timing : String? = nil
        )
        end
      end

      # Contains configuration information for maintaining Data Catalog security.

      struct DataCatalogEncryptionSettings
        include JSON::Serializable

        # When connection password protection is enabled, the Data Catalog uses a customer-provided key to
        # encrypt the password as part of CreateConnection or UpdateConnection and store it in the
        # ENCRYPTED_PASSWORD field in the connection properties. You can enable catalog encryption or only
        # password encryption.

        @[JSON::Field(key: "ConnectionPasswordEncryption")]
        getter connection_password_encryption : Types::ConnectionPasswordEncryption?

        # Specifies the encryption-at-rest configuration for the Data Catalog.

        @[JSON::Field(key: "EncryptionAtRest")]
        getter encryption_at_rest : Types::EncryptionAtRest?

        def initialize(
          @connection_password_encryption : Types::ConnectionPasswordEncryption? = nil,
          @encryption_at_rest : Types::EncryptionAtRest? = nil
        )
        end
      end

      # Input properties to configure data lake access for your catalog resource in the Glue Data Catalog.

      struct DataLakeAccessProperties
        include JSON::Serializable

        # Specifies a federated catalog type for the native catalog resource. The currently supported type is
        # aws:redshift .

        @[JSON::Field(key: "CatalogType")]
        getter catalog_type : String?

        # Turns on or off data lake access for Apache Spark applications that access Amazon Redshift databases
        # in the Data Catalog from any non-Redshift engine, such as Amazon Athena, Amazon EMR, or Glue ETL.

        @[JSON::Field(key: "DataLakeAccess")]
        getter data_lake_access : Bool?

        # A role that will be assumed by Glue for transferring data into/out of the staging bucket during a
        # query.

        @[JSON::Field(key: "DataTransferRole")]
        getter data_transfer_role : String?

        # An encryption key that will be used for the staging bucket that will be created along with the
        # catalog.

        @[JSON::Field(key: "KmsKey")]
        getter kms_key : String?

        def initialize(
          @catalog_type : String? = nil,
          @data_lake_access : Bool? = nil,
          @data_transfer_role : String? = nil,
          @kms_key : String? = nil
        )
        end
      end

      # The output properties of the data lake access configuration for your catalog resource in the Glue
      # Data Catalog.

      struct DataLakeAccessPropertiesOutput
        include JSON::Serializable

        # Specifies a federated catalog type for the native catalog resource. The currently supported type is
        # aws:redshift .

        @[JSON::Field(key: "CatalogType")]
        getter catalog_type : String?

        # Turns on or off data lake access for Apache Spark applications that access Amazon Redshift databases
        # in the Data Catalog.

        @[JSON::Field(key: "DataLakeAccess")]
        getter data_lake_access : Bool?

        # A role that will be assumed by Glue for transferring data into/out of the staging bucket during a
        # query.

        @[JSON::Field(key: "DataTransferRole")]
        getter data_transfer_role : String?

        # An encryption key that will be used for the staging bucket that will be created along with the
        # catalog.

        @[JSON::Field(key: "KmsKey")]
        getter kms_key : String?

        # The managed Redshift Serverless compute name that is created for your catalog resource.

        @[JSON::Field(key: "ManagedWorkgroupName")]
        getter managed_workgroup_name : String?

        # The managed Redshift Serverless compute status.

        @[JSON::Field(key: "ManagedWorkgroupStatus")]
        getter managed_workgroup_status : String?

        # The default Redshift database resource name in the managed compute.

        @[JSON::Field(key: "RedshiftDatabaseName")]
        getter redshift_database_name : String?

        # A message that gives more detailed information about the managed workgroup status.

        @[JSON::Field(key: "StatusMessage")]
        getter status_message : String?

        def initialize(
          @catalog_type : String? = nil,
          @data_lake_access : Bool? = nil,
          @data_transfer_role : String? = nil,
          @kms_key : String? = nil,
          @managed_workgroup_name : String? = nil,
          @managed_workgroup_status : String? = nil,
          @redshift_database_name : String? = nil,
          @status_message : String? = nil
        )
        end
      end

      # The Lake Formation principal.

      struct DataLakePrincipal
        include JSON::Serializable

        # An identifier for the Lake Formation principal.

        @[JSON::Field(key: "DataLakePrincipalIdentifier")]
        getter data_lake_principal_identifier : String?

        def initialize(
          @data_lake_principal_identifier : String? = nil
        )
        end
      end

      # A summary of metrics showing the total counts of processed rows and rules, including their pass/fail
      # statistics based on row-level results.

      struct DataQualityAggregatedMetrics
        include JSON::Serializable

        # The total number of rows that failed one or more data quality rules.

        @[JSON::Field(key: "TotalRowsFailed")]
        getter total_rows_failed : Float64?

        # The total number of rows that passed all applicable data quality rules.

        @[JSON::Field(key: "TotalRowsPassed")]
        getter total_rows_passed : Float64?

        # The total number of rows that were processed during the data quality evaluation.

        @[JSON::Field(key: "TotalRowsProcessed")]
        getter total_rows_processed : Float64?

        # The total number of data quality rules that failed their evaluation criteria.

        @[JSON::Field(key: "TotalRulesFailed")]
        getter total_rules_failed : Float64?

        # The total number of data quality rules that passed their evaluation criteria.

        @[JSON::Field(key: "TotalRulesPassed")]
        getter total_rules_passed : Float64?

        # The total number of data quality rules that were evaluated.

        @[JSON::Field(key: "TotalRulesProcessed")]
        getter total_rules_processed : Float64?

        def initialize(
          @total_rows_failed : Float64? = nil,
          @total_rows_passed : Float64? = nil,
          @total_rows_processed : Float64? = nil,
          @total_rules_failed : Float64? = nil,
          @total_rules_passed : Float64? = nil,
          @total_rules_processed : Float64? = nil
        )
        end
      end

      # Describes the result of the evaluation of a data quality analyzer.

      struct DataQualityAnalyzerResult
        include JSON::Serializable

        # A description of the data quality analyzer.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A map of metrics associated with the evaluation of the analyzer.

        @[JSON::Field(key: "EvaluatedMetrics")]
        getter evaluated_metrics : Hash(String, Float64)?

        # An evaluation message.

        @[JSON::Field(key: "EvaluationMessage")]
        getter evaluation_message : String?

        # The name of the data quality analyzer.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @description : String? = nil,
          @evaluated_metrics : Hash(String, Float64)? = nil,
          @evaluation_message : String? = nil,
          @name : String? = nil
        )
        end
      end

      # Specifies how Data Quality assets in your account should be encrypted.

      struct DataQualityEncryption
        include JSON::Serializable

        # The encryption mode to use for encrypting Data Quality assets. These assets include data quality
        # rulesets, results, statistics, anomaly detection models and observations. Valid values are SSEKMS
        # for encryption using a customer-managed KMS key, or DISABLED .

        @[JSON::Field(key: "DataQualityEncryptionMode")]
        getter data_quality_encryption_mode : String?

        # The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.

        @[JSON::Field(key: "KmsKeyArn")]
        getter kms_key_arn : String?

        def initialize(
          @data_quality_encryption_mode : String? = nil,
          @kms_key_arn : String? = nil
        )
        end
      end

      # Additional run options you can specify for an evaluation run.

      struct DataQualityEvaluationRunAdditionalRunOptions
        include JSON::Serializable

        # Whether or not to enable CloudWatch metrics.

        @[JSON::Field(key: "CloudWatchMetricsEnabled")]
        getter cloud_watch_metrics_enabled : Bool?

        # Set the evaluation method for composite rules in the ruleset to ROW/COLUMN

        @[JSON::Field(key: "CompositeRuleEvaluationMethod")]
        getter composite_rule_evaluation_method : String?

        # Prefix for Amazon S3 to store results.

        @[JSON::Field(key: "ResultsS3Prefix")]
        getter results_s3_prefix : String?

        def initialize(
          @cloud_watch_metrics_enabled : Bool? = nil,
          @composite_rule_evaluation_method : String? = nil,
          @results_s3_prefix : String? = nil
        )
        end
      end

      # The database and table in the Glue Data Catalog that is used for input or output data for Data
      # Quality Operations.

      struct DataQualityGlueTable
        include JSON::Serializable

        # A database name in the Glue Data Catalog.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A table name in the Glue Data Catalog.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # Additional options for the table. Currently there are two keys supported: pushDownPredicate : to
        # filter on partitions without having to list and read all the files in your dataset.
        # catalogPartitionPredicate : to use server-side partition pruning using partition indexes in the Glue
        # Data Catalog.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?

        # A unique identifier for the Glue Data Catalog.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The name of the connection to the Glue Data Catalog.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # SQL Query of SparkSQL format that can be used to pre-process the data for the table in Glue Data
        # Catalog, before running the Data Quality Operation.

        @[JSON::Field(key: "PreProcessingQuery")]
        getter pre_processing_query : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @additional_options : Hash(String, String)? = nil,
          @catalog_id : String? = nil,
          @connection_name : String? = nil,
          @pre_processing_query : String? = nil
        )
        end
      end

      # Describes the data quality metric value according to the analysis of historical data.

      struct DataQualityMetricValues
        include JSON::Serializable

        # The actual value of the data quality metric.

        @[JSON::Field(key: "ActualValue")]
        getter actual_value : Float64?

        # The expected value of the data quality metric according to the analysis of historical data.

        @[JSON::Field(key: "ExpectedValue")]
        getter expected_value : Float64?

        # The lower limit of the data quality metric value according to the analysis of historical data.

        @[JSON::Field(key: "LowerLimit")]
        getter lower_limit : Float64?

        # The upper limit of the data quality metric value according to the analysis of historical data.

        @[JSON::Field(key: "UpperLimit")]
        getter upper_limit : Float64?

        def initialize(
          @actual_value : Float64? = nil,
          @expected_value : Float64? = nil,
          @lower_limit : Float64? = nil,
          @upper_limit : Float64? = nil
        )
        end
      end

      # Describes the observation generated after evaluating the rules and analyzers.

      struct DataQualityObservation
        include JSON::Serializable

        # A description of the data quality observation.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # An object of type MetricBasedObservation representing the observation that is based on evaluated
        # data quality metrics.

        @[JSON::Field(key: "MetricBasedObservation")]
        getter metric_based_observation : Types::MetricBasedObservation?

        def initialize(
          @description : String? = nil,
          @metric_based_observation : Types::MetricBasedObservation? = nil
        )
        end
      end

      # Describes a data quality result.

      struct DataQualityResult
        include JSON::Serializable

        # A summary of DataQualityAggregatedMetrics objects showing the total counts of processed rows and
        # rules, including their pass/fail statistics based on row-level results.

        @[JSON::Field(key: "AggregatedMetrics")]
        getter aggregated_metrics : Types::DataQualityAggregatedMetrics?

        # A list of DataQualityAnalyzerResult objects representing the results for each analyzer.

        @[JSON::Field(key: "AnalyzerResults")]
        getter analyzer_results : Array(Types::DataQualityAnalyzerResult)?

        # The date and time when this data quality run completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # The table associated with the data quality result, if any.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource?

        # In the context of a job in Glue Studio, each node in the canvas is typically assigned some sort of
        # name and data quality nodes will have names. In the case of multiple nodes, the evaluationContext
        # can differentiate the nodes.

        @[JSON::Field(key: "EvaluationContext")]
        getter evaluation_context : String?

        # The job name associated with the data quality result, if any.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # The job run ID associated with the data quality result, if any.

        @[JSON::Field(key: "JobRunId")]
        getter job_run_id : String?

        # A list of DataQualityObservation objects representing the observations generated after evaluating
        # the rules and analyzers.

        @[JSON::Field(key: "Observations")]
        getter observations : Array(Types::DataQualityObservation)?

        # The Profile ID for the data quality result.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String?

        # A unique result ID for the data quality result.

        @[JSON::Field(key: "ResultId")]
        getter result_id : String?

        # A list of DataQualityRuleResult objects representing the results for each rule.

        @[JSON::Field(key: "RuleResults")]
        getter rule_results : Array(Types::DataQualityRuleResult)?

        # The unique run ID for the ruleset evaluation for this data quality result.

        @[JSON::Field(key: "RulesetEvaluationRunId")]
        getter ruleset_evaluation_run_id : String?

        # The name of the ruleset associated with the data quality result.

        @[JSON::Field(key: "RulesetName")]
        getter ruleset_name : String?

        # An aggregate data quality score. Represents the ratio of rules that passed to the total number of
        # rules.

        @[JSON::Field(key: "Score")]
        getter score : Float64?

        # The date and time when this data quality run started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        def initialize(
          @aggregated_metrics : Types::DataQualityAggregatedMetrics? = nil,
          @analyzer_results : Array(Types::DataQualityAnalyzerResult)? = nil,
          @completed_on : Time? = nil,
          @data_source : Types::DataSource? = nil,
          @evaluation_context : String? = nil,
          @job_name : String? = nil,
          @job_run_id : String? = nil,
          @observations : Array(Types::DataQualityObservation)? = nil,
          @profile_id : String? = nil,
          @result_id : String? = nil,
          @rule_results : Array(Types::DataQualityRuleResult)? = nil,
          @ruleset_evaluation_run_id : String? = nil,
          @ruleset_name : String? = nil,
          @score : Float64? = nil,
          @started_on : Time? = nil
        )
        end
      end

      # Describes a data quality result.

      struct DataQualityResultDescription
        include JSON::Serializable

        # The table name associated with the data quality result.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource?

        # The job name associated with the data quality result.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # The job run ID associated with the data quality result.

        @[JSON::Field(key: "JobRunId")]
        getter job_run_id : String?

        # The unique result ID for this data quality result.

        @[JSON::Field(key: "ResultId")]
        getter result_id : String?

        # The time that the run started for this data quality result.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        def initialize(
          @data_source : Types::DataSource? = nil,
          @job_name : String? = nil,
          @job_run_id : String? = nil,
          @result_id : String? = nil,
          @started_on : Time? = nil
        )
        end
      end

      # Criteria used to return data quality results.

      struct DataQualityResultFilterCriteria
        include JSON::Serializable

        # Filter results by the specified data source. For example, retrieving all results for an Glue table.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource?

        # Filter results by the specified job name.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # Filter results by the specified job run ID.

        @[JSON::Field(key: "JobRunId")]
        getter job_run_id : String?

        # Filter results by runs that started after this time.

        @[JSON::Field(key: "StartedAfter", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_after : Time?

        # Filter results by runs that started before this time.

        @[JSON::Field(key: "StartedBefore", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_before : Time?

        def initialize(
          @data_source : Types::DataSource? = nil,
          @job_name : String? = nil,
          @job_run_id : String? = nil,
          @started_after : Time? = nil,
          @started_before : Time? = nil
        )
        end
      end

      # Describes the result of a data quality rule recommendation run.

      struct DataQualityRuleRecommendationRunDescription
        include JSON::Serializable

        # The data source (Glue table) associated with the recommendation run.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource?

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        # The date and time when this run started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # The status for this run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        def initialize(
          @data_source : Types::DataSource? = nil,
          @run_id : String? = nil,
          @started_on : Time? = nil,
          @status : String? = nil
        )
        end
      end

      # A filter for listing data quality recommendation runs.

      struct DataQualityRuleRecommendationRunFilter
        include JSON::Serializable

        # Filter based on a specified data source (Glue table).

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource

        # Filter based on time for results started after provided time.

        @[JSON::Field(key: "StartedAfter", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_after : Time?

        # Filter based on time for results started before provided time.

        @[JSON::Field(key: "StartedBefore", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_before : Time?

        def initialize(
          @data_source : Types::DataSource,
          @started_after : Time? = nil,
          @started_before : Time? = nil
        )
        end
      end

      # Describes the result of the evaluation of a data quality rule.

      struct DataQualityRuleResult
        include JSON::Serializable

        # A description of the data quality rule.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A map of metrics associated with the evaluation of the rule.

        @[JSON::Field(key: "EvaluatedMetrics")]
        getter evaluated_metrics : Hash(String, Float64)?

        # The evaluated rule.

        @[JSON::Field(key: "EvaluatedRule")]
        getter evaluated_rule : String?

        # An evaluation message.

        @[JSON::Field(key: "EvaluationMessage")]
        getter evaluation_message : String?

        # A map containing labels assigned to the data quality rule.

        @[JSON::Field(key: "Labels")]
        getter labels : Hash(String, String)?

        # The name of the data quality rule.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # A pass or fail status for the rule.

        @[JSON::Field(key: "Result")]
        getter result : String?

        # A map containing metrics associated with the evaluation of the rule based on row-level results.

        @[JSON::Field(key: "RuleMetrics")]
        getter rule_metrics : Hash(String, Float64)?

        def initialize(
          @description : String? = nil,
          @evaluated_metrics : Hash(String, Float64)? = nil,
          @evaluated_rule : String? = nil,
          @evaluation_message : String? = nil,
          @labels : Hash(String, String)? = nil,
          @name : String? = nil,
          @result : String? = nil,
          @rule_metrics : Hash(String, Float64)? = nil
        )
        end
      end

      # Describes the result of a data quality ruleset evaluation run.

      struct DataQualityRulesetEvaluationRunDescription
        include JSON::Serializable

        # The data source (an Glue table) associated with the run.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource?

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        # The date and time when the run started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # The status for this run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        def initialize(
          @data_source : Types::DataSource? = nil,
          @run_id : String? = nil,
          @started_on : Time? = nil,
          @status : String? = nil
        )
        end
      end

      # The filter criteria.

      struct DataQualityRulesetEvaluationRunFilter
        include JSON::Serializable

        # Filter based on a data source (an Glue table) associated with the run.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource

        # Filter results by runs that started after this time.

        @[JSON::Field(key: "StartedAfter", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_after : Time?

        # Filter results by runs that started before this time.

        @[JSON::Field(key: "StartedBefore", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_before : Time?

        def initialize(
          @data_source : Types::DataSource,
          @started_after : Time? = nil,
          @started_before : Time? = nil
        )
        end
      end

      # The criteria used to filter data quality rulesets.

      struct DataQualityRulesetFilterCriteria
        include JSON::Serializable

        # Filter on rulesets created after this date.

        @[JSON::Field(key: "CreatedAfter", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_after : Time?

        # Filter on rulesets created before this date.

        @[JSON::Field(key: "CreatedBefore", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_before : Time?

        # The description of the ruleset filter criteria.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Filter on rulesets last modified after this date.

        @[JSON::Field(key: "LastModifiedAfter", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_after : Time?

        # Filter on rulesets last modified before this date.

        @[JSON::Field(key: "LastModifiedBefore", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_before : Time?

        # The name of the ruleset filter criteria.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # The name and database name of the target table.

        @[JSON::Field(key: "TargetTable")]
        getter target_table : Types::DataQualityTargetTable?

        def initialize(
          @created_after : Time? = nil,
          @created_before : Time? = nil,
          @description : String? = nil,
          @last_modified_after : Time? = nil,
          @last_modified_before : Time? = nil,
          @name : String? = nil,
          @target_table : Types::DataQualityTargetTable? = nil
        )
        end
      end

      # Describes a data quality ruleset returned by GetDataQualityRuleset .

      struct DataQualityRulesetListDetails
        include JSON::Serializable

        # The date and time the data quality ruleset was created.

        @[JSON::Field(key: "CreatedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_on : Time?

        # A description of the data quality ruleset.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The date and time the data quality ruleset was last modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The name of the data quality ruleset.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # When a ruleset was created from a recommendation run, this run ID is generated to link the two
        # together.

        @[JSON::Field(key: "RecommendationRunId")]
        getter recommendation_run_id : String?

        # The number of rules in the ruleset.

        @[JSON::Field(key: "RuleCount")]
        getter rule_count : Int32?

        # An object representing an Glue table.

        @[JSON::Field(key: "TargetTable")]
        getter target_table : Types::DataQualityTargetTable?

        def initialize(
          @created_on : Time? = nil,
          @description : String? = nil,
          @last_modified_on : Time? = nil,
          @name : String? = nil,
          @recommendation_run_id : String? = nil,
          @rule_count : Int32? = nil,
          @target_table : Types::DataQualityTargetTable? = nil
        )
        end
      end

      # An object representing an Glue table.

      struct DataQualityTargetTable
        include JSON::Serializable

        # The name of the database where the Glue table exists.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the Glue table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The catalog id where the Glue table exists.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end

      # A data source (an Glue table) for which you want data quality results.

      struct DataSource
        include JSON::Serializable

        # An Glue table for Data Quality Operations.

        @[JSON::Field(key: "DataQualityGlueTable")]
        getter data_quality_glue_table : Types::DataQualityGlueTable?

        # An Glue table.

        @[JSON::Field(key: "GlueTable")]
        getter glue_table : Types::GlueTable?

        def initialize(
          @data_quality_glue_table : Types::DataQualityGlueTable? = nil,
          @glue_table : Types::GlueTable? = nil
        )
        end
      end

      # The Database object represents a logical grouping of tables that might reside in a Hive metastore or
      # an RDBMS.

      struct Database
        include JSON::Serializable

        # The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the Data Catalog in which the database resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # Creates a set of default permissions on the table for principals. Used by Lake Formation. Not used
        # in the normal course of Glue operations.

        @[JSON::Field(key: "CreateTableDefaultPermissions")]
        getter create_table_default_permissions : Array(Types::PrincipalPermissions)?

        # The time at which the metadata database was created in the catalog.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time?

        # A description of the database.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A FederatedDatabase structure that references an entity outside the Glue Data Catalog.

        @[JSON::Field(key: "FederatedDatabase")]
        getter federated_database : Types::FederatedDatabase?

        # The location of the database (for example, an HDFS path).

        @[JSON::Field(key: "LocationUri")]
        getter location_uri : String?

        # These key-value pairs define parameters and properties of the database.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # A DatabaseIdentifier structure that describes a target database for resource linking.

        @[JSON::Field(key: "TargetDatabase")]
        getter target_database : Types::DatabaseIdentifier?

        def initialize(
          @name : String,
          @catalog_id : String? = nil,
          @create_table_default_permissions : Array(Types::PrincipalPermissions)? = nil,
          @create_time : Time? = nil,
          @description : String? = nil,
          @federated_database : Types::FederatedDatabase? = nil,
          @location_uri : String? = nil,
          @parameters : Hash(String, String)? = nil,
          @target_database : Types::DatabaseIdentifier? = nil
        )
        end
      end

      # A structure that describes a target database for resource linking.

      struct DatabaseIdentifier
        include JSON::Serializable

        # The ID of the Data Catalog in which the database resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The name of the catalog database.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # Region of the target database.

        @[JSON::Field(key: "Region")]
        getter region : String?

        def initialize(
          @catalog_id : String? = nil,
          @database_name : String? = nil,
          @region : String? = nil
        )
        end
      end

      # The structure used to create or update a database.

      struct DatabaseInput
        include JSON::Serializable

        # The name of the database. For Hive compatibility, this is folded to lowercase when it is stored.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Creates a set of default permissions on the table for principals. Used by Lake Formation. Not used
        # in the normal course of Glue operations.

        @[JSON::Field(key: "CreateTableDefaultPermissions")]
        getter create_table_default_permissions : Array(Types::PrincipalPermissions)?

        # A description of the database.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A FederatedDatabase structure that references an entity outside the Glue Data Catalog.

        @[JSON::Field(key: "FederatedDatabase")]
        getter federated_database : Types::FederatedDatabase?

        # The location of the database (for example, an HDFS path).

        @[JSON::Field(key: "LocationUri")]
        getter location_uri : String?

        # These key-value pairs define parameters and properties of the database. These key-value pairs define
        # parameters and properties of the database.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # A DatabaseIdentifier structure that describes a target database for resource linking.

        @[JSON::Field(key: "TargetDatabase")]
        getter target_database : Types::DatabaseIdentifier?

        def initialize(
          @name : String,
          @create_table_default_permissions : Array(Types::PrincipalPermissions)? = nil,
          @description : String? = nil,
          @federated_database : Types::FederatedDatabase? = nil,
          @location_uri : String? = nil,
          @parameters : Hash(String, String)? = nil,
          @target_database : Types::DatabaseIdentifier? = nil
        )
        end
      end

      # An Inclusion Annotation.

      struct DatapointInclusionAnnotation
        include JSON::Serializable

        # The inclusion annotation value to apply to the statistic.

        @[JSON::Field(key: "InclusionAnnotation")]
        getter inclusion_annotation : String?

        # The ID of the data quality profile the statistic belongs to.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String?

        # The Statistic ID.

        @[JSON::Field(key: "StatisticId")]
        getter statistic_id : String?

        def initialize(
          @inclusion_annotation : String? = nil,
          @profile_id : String? = nil,
          @statistic_id : String? = nil
        )
        end
      end

      # A structure representing the datatype of the value.

      struct Datatype
        include JSON::Serializable

        # The datatype of the value.

        @[JSON::Field(key: "Id")]
        getter id : String

        # A label assigned to the datatype.

        @[JSON::Field(key: "Label")]
        getter label : String

        def initialize(
          @id : String,
          @label : String
        )
        end
      end

      # Defines column statistics supported for timestamp data columns.

      struct DateColumnStatisticsData
        include JSON::Serializable

        # The number of distinct values in a column.

        @[JSON::Field(key: "NumberOfDistinctValues")]
        getter number_of_distinct_values : Int64

        # The number of null values in the column.

        @[JSON::Field(key: "NumberOfNulls")]
        getter number_of_nulls : Int64

        # The highest value in the column.

        @[JSON::Field(key: "MaximumValue", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter maximum_value : Time?

        # The lowest value in the column.

        @[JSON::Field(key: "MinimumValue", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter minimum_value : Time?

        def initialize(
          @number_of_distinct_values : Int64,
          @number_of_nulls : Int64,
          @maximum_value : Time? = nil,
          @minimum_value : Time? = nil
        )
        end
      end

      # Defines column statistics supported for fixed-point number data columns.

      struct DecimalColumnStatisticsData
        include JSON::Serializable

        # The number of distinct values in a column.

        @[JSON::Field(key: "NumberOfDistinctValues")]
        getter number_of_distinct_values : Int64

        # The number of null values in the column.

        @[JSON::Field(key: "NumberOfNulls")]
        getter number_of_nulls : Int64

        # The highest value in the column.

        @[JSON::Field(key: "MaximumValue")]
        getter maximum_value : Types::DecimalNumber?

        # The lowest value in the column.

        @[JSON::Field(key: "MinimumValue")]
        getter minimum_value : Types::DecimalNumber?

        def initialize(
          @number_of_distinct_values : Int64,
          @number_of_nulls : Int64,
          @maximum_value : Types::DecimalNumber? = nil,
          @minimum_value : Types::DecimalNumber? = nil
        )
        end
      end

      # Contains a numeric value in decimal format.

      struct DecimalNumber
        include JSON::Serializable

        # The scale that determines where the decimal point falls in the unscaled value.

        @[JSON::Field(key: "Scale")]
        getter scale : Int32

        # The unscaled numeric value.

        @[JSON::Field(key: "UnscaledValue")]
        getter unscaled_value : Bytes

        def initialize(
          @scale : Int32,
          @unscaled_value : Bytes
        )
        end
      end


      struct DeleteBlueprintRequest
        include JSON::Serializable

        # The name of the blueprint to delete.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct DeleteBlueprintResponse
        include JSON::Serializable

        # Returns the name of the blueprint that was deleted.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct DeleteCatalogRequest
        include JSON::Serializable

        # The ID of the catalog.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        def initialize(
          @catalog_id : String
        )
        end
      end


      struct DeleteCatalogResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteClassifierRequest
        include JSON::Serializable

        # Name of the classifier to remove.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct DeleteClassifierResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteColumnStatisticsForPartitionRequest
        include JSON::Serializable

        # Name of the column.

        @[JSON::Field(key: "ColumnName")]
        getter column_name : String

        # The name of the catalog database where the partitions reside.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A list of partition values identifying the partition.

        @[JSON::Field(key: "PartitionValues")]
        getter partition_values : Array(String)

        # The name of the partitions' table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @column_name : String,
          @database_name : String,
          @partition_values : Array(String),
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct DeleteColumnStatisticsForPartitionResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteColumnStatisticsForTableRequest
        include JSON::Serializable

        # The name of the column.

        @[JSON::Field(key: "ColumnName")]
        getter column_name : String

        # The name of the catalog database where the partitions reside.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the partitions' table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @column_name : String,
          @database_name : String,
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct DeleteColumnStatisticsForTableResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteColumnStatisticsTaskSettingsRequest
        include JSON::Serializable

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table for which to delete column statistics.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        def initialize(
          @database_name : String,
          @table_name : String
        )
        end
      end


      struct DeleteColumnStatisticsTaskSettingsResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteConnectionRequest
        include JSON::Serializable

        # The name of the connection to delete.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String

        # The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @connection_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct DeleteConnectionResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteCrawlerRequest
        include JSON::Serializable

        # The name of the crawler to remove.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct DeleteCrawlerResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteCustomEntityTypeRequest
        include JSON::Serializable

        # The name of the custom pattern that you want to delete.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct DeleteCustomEntityTypeResponse
        include JSON::Serializable

        # The name of the custom pattern you deleted.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct DeleteDataQualityRulesetRequest
        include JSON::Serializable

        # A name for the data quality ruleset.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct DeleteDataQualityRulesetResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteDatabaseRequest
        include JSON::Serializable

        # The name of the database to delete. For Hive compatibility, this must be all lowercase.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct DeleteDatabaseResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteDevEndpointRequest
        include JSON::Serializable

        # The name of the DevEndpoint .

        @[JSON::Field(key: "EndpointName")]
        getter endpoint_name : String

        def initialize(
          @endpoint_name : String
        )
        end
      end


      struct DeleteDevEndpointResponse
        include JSON::Serializable

        def initialize
        end
      end

      # Request to delete the existing Glue Identity Center configuration.

      struct DeleteGlueIdentityCenterConfigurationRequest
        include JSON::Serializable

        def initialize
        end
      end

      # Response from deleting the Glue Identity Center configuration.

      struct DeleteGlueIdentityCenterConfigurationResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteIntegrationRequest
        include JSON::Serializable

        # The Amazon Resource Name (ARN) for the integration.

        @[JSON::Field(key: "IntegrationIdentifier")]
        getter integration_identifier : String

        def initialize(
          @integration_identifier : String
        )
        end
      end


      struct DeleteIntegrationResourcePropertyRequest
        include JSON::Serializable

        # The connection ARN of the source, or the database ARN of the target.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        def initialize(
          @resource_arn : String
        )
        end
      end


      struct DeleteIntegrationResourcePropertyResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteIntegrationResponse
        include JSON::Serializable

        # The time when the integration was created, in UTC.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time

        # The Amazon Resource Name (ARN) for the integration.

        @[JSON::Field(key: "IntegrationArn")]
        getter integration_arn : String

        # A unique name for an integration in Glue.

        @[JSON::Field(key: "IntegrationName")]
        getter integration_name : String

        # The ARN of the source for the integration.

        @[JSON::Field(key: "SourceArn")]
        getter source_arn : String

        # The status of the integration being deleted. The possible statuses are: CREATING: The integration is
        # being created. ACTIVE: The integration creation succeeds. MODIFYING: The integration is being
        # modified. FAILED: The integration creation fails. DELETING: The integration is deleted. SYNCING: The
        # integration is synchronizing. NEEDS_ATTENTION: The integration needs attention, such as
        # synchronization.

        @[JSON::Field(key: "Status")]
        getter status : String

        # The ARN of the target for the integration.

        @[JSON::Field(key: "TargetArn")]
        getter target_arn : String

        # An optional set of non-secret keyvalue pairs that contains additional contextual information for
        # encryption.

        @[JSON::Field(key: "AdditionalEncryptionContext")]
        getter additional_encryption_context : Hash(String, String)?

        # Selects source tables for the integration using Maxwell filter syntax.

        @[JSON::Field(key: "DataFilter")]
        getter data_filter : String?

        # A description of the integration.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A list of errors associated with the integration.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::IntegrationError)?

        # The ARN of a KMS key used for encrypting the channel.

        @[JSON::Field(key: "KmsKeyId")]
        getter kms_key_id : String?

        # Metadata assigned to the resource consisting of a list of key-value pairs.

        @[JSON::Field(key: "Tags")]
        getter tags : Array(Types::Tag)?

        def initialize(
          @create_time : Time,
          @integration_arn : String,
          @integration_name : String,
          @source_arn : String,
          @status : String,
          @target_arn : String,
          @additional_encryption_context : Hash(String, String)? = nil,
          @data_filter : String? = nil,
          @description : String? = nil,
          @errors : Array(Types::IntegrationError)? = nil,
          @kms_key_id : String? = nil,
          @tags : Array(Types::Tag)? = nil
        )
        end
      end


      struct DeleteIntegrationTablePropertiesRequest
        include JSON::Serializable

        # The connection ARN of the source, or the database ARN of the target.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        # The name of the table to be replicated.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        def initialize(
          @resource_arn : String,
          @table_name : String
        )
        end
      end


      struct DeleteIntegrationTablePropertiesResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteJobRequest
        include JSON::Serializable

        # The name of the job definition to delete.

        @[JSON::Field(key: "JobName")]
        getter job_name : String

        def initialize(
          @job_name : String
        )
        end
      end


      struct DeleteJobResponse
        include JSON::Serializable

        # The name of the job definition that was deleted.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        def initialize(
          @job_name : String? = nil
        )
        end
      end


      struct DeleteMLTransformRequest
        include JSON::Serializable

        # The unique identifier of the transform to delete.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String

        def initialize(
          @transform_id : String
        )
        end
      end


      struct DeleteMLTransformResponse
        include JSON::Serializable

        # The unique identifier of the transform that was deleted.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String?

        def initialize(
          @transform_id : String? = nil
        )
        end
      end


      struct DeletePartitionIndexRequest
        include JSON::Serializable

        # Specifies the name of a database from which you want to delete a partition index.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the partition index to be deleted.

        @[JSON::Field(key: "IndexName")]
        getter index_name : String

        # Specifies the name of a table from which you want to delete a partition index.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The catalog ID where the table resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @index_name : String,
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct DeletePartitionIndexResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeletePartitionRequest
        include JSON::Serializable

        # The name of the catalog database in which the table in question resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The values that define the partition.

        @[JSON::Field(key: "PartitionValues")]
        getter partition_values : Array(String)

        # The name of the table that contains the partition to be deleted.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partition to be deleted resides. If none is provided, the
        # Amazon Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @partition_values : Array(String),
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct DeletePartitionResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteRegistryInput
        include JSON::Serializable

        # This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).

        @[JSON::Field(key: "RegistryId")]
        getter registry_id : Types::RegistryId

        def initialize(
          @registry_id : Types::RegistryId
        )
        end
      end


      struct DeleteRegistryResponse
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the registry being deleted.

        @[JSON::Field(key: "RegistryArn")]
        getter registry_arn : String?

        # The name of the registry being deleted.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The status of the registry. A successful operation will return the Deleting status.

        @[JSON::Field(key: "Status")]
        getter status : String?

        def initialize(
          @registry_arn : String? = nil,
          @registry_name : String? = nil,
          @status : String? = nil
        )
        end
      end


      struct DeleteResourcePolicyRequest
        include JSON::Serializable

        # The hash value returned when this policy was set.

        @[JSON::Field(key: "PolicyHashCondition")]
        getter policy_hash_condition : String?

        # The ARN of the Glue resource for the resource policy to be deleted.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String?

        def initialize(
          @policy_hash_condition : String? = nil,
          @resource_arn : String? = nil
        )
        end
      end


      struct DeleteResourcePolicyResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteSchemaInput
        include JSON::Serializable

        # This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId

        def initialize(
          @schema_id : Types::SchemaId
        )
        end
      end


      struct DeleteSchemaResponse
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the schema being deleted.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The name of the schema being deleted.

        @[JSON::Field(key: "SchemaName")]
        getter schema_name : String?

        # The status of the schema.

        @[JSON::Field(key: "Status")]
        getter status : String?

        def initialize(
          @schema_arn : String? = nil,
          @schema_name : String? = nil,
          @status : String? = nil
        )
        end
      end


      struct DeleteSchemaVersionsInput
        include JSON::Serializable

        # This is a wrapper structure that may contain the schema name and Amazon Resource Name (ARN).

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId

        # A version range may be supplied which may be of the format: a single version number, 5 a range, 5-8
        # : deletes versions 5, 6, 7, 8

        @[JSON::Field(key: "Versions")]
        getter versions : String

        def initialize(
          @schema_id : Types::SchemaId,
          @versions : String
        )
        end
      end


      struct DeleteSchemaVersionsResponse
        include JSON::Serializable

        # A list of SchemaVersionErrorItem objects, each containing an error and schema version.

        @[JSON::Field(key: "SchemaVersionErrors")]
        getter schema_version_errors : Array(Types::SchemaVersionErrorItem)?

        def initialize(
          @schema_version_errors : Array(Types::SchemaVersionErrorItem)? = nil
        )
        end
      end


      struct DeleteSecurityConfigurationRequest
        include JSON::Serializable

        # The name of the security configuration to delete.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct DeleteSecurityConfigurationResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteSessionRequest
        include JSON::Serializable

        # The ID of the session to be deleted.

        @[JSON::Field(key: "Id")]
        getter id : String

        # The name of the origin of the delete session request.

        @[JSON::Field(key: "RequestOrigin")]
        getter request_origin : String?

        def initialize(
          @id : String,
          @request_origin : String? = nil
        )
        end
      end


      struct DeleteSessionResponse
        include JSON::Serializable

        # Returns the ID of the deleted session.

        @[JSON::Field(key: "Id")]
        getter id : String?

        def initialize(
          @id : String? = nil
        )
        end
      end


      struct DeleteTableOptimizerRequest
        include JSON::Serializable

        # The Catalog ID of the table.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # The name of the database in the catalog in which the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The type of table optimizer.

        @[JSON::Field(key: "Type")]
        getter type : String

        def initialize(
          @catalog_id : String,
          @database_name : String,
          @table_name : String,
          @type : String
        )
        end
      end


      struct DeleteTableOptimizerResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteTableRequest
        include JSON::Serializable

        # The name of the catalog database in which the table resides. For Hive compatibility, this name is
        # entirely lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table to be deleted. For Hive compatibility, this name is entirely lowercase.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The transaction ID at which to delete the table contents.

        @[JSON::Field(key: "TransactionId")]
        getter transaction_id : String?

        def initialize(
          @database_name : String,
          @name : String,
          @catalog_id : String? = nil,
          @transaction_id : String? = nil
        )
        end
      end


      struct DeleteTableResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteTableVersionRequest
        include JSON::Serializable

        # The database in the catalog in which the table resides. For Hive compatibility, this name is
        # entirely lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table. For Hive compatibility, this name is entirely lowercase.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the table version to be deleted. A VersionID is a string representation of an integer.
        # Each version is incremented by 1.

        @[JSON::Field(key: "VersionId")]
        getter version_id : String

        # The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @version_id : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct DeleteTableVersionResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteTriggerRequest
        include JSON::Serializable

        # The name of the trigger to delete.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct DeleteTriggerResponse
        include JSON::Serializable

        # The name of the trigger that was deleted.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct DeleteUsageProfileRequest
        include JSON::Serializable

        # The name of the usage profile to delete.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct DeleteUsageProfileResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteUserDefinedFunctionRequest
        include JSON::Serializable

        # The name of the catalog database where the function is located.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the function definition to be deleted.

        @[JSON::Field(key: "FunctionName")]
        getter function_name : String

        # The ID of the Data Catalog where the function to be deleted is located. If none is supplied, the
        # Amazon Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @function_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct DeleteUserDefinedFunctionResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct DeleteWorkflowRequest
        include JSON::Serializable

        # Name of the workflow to be deleted.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct DeleteWorkflowResponse
        include JSON::Serializable

        # Name of the workflow specified in input.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end

      # Specifies a Delta data store to crawl one or more Delta tables.

      struct DeltaTarget
        include JSON::Serializable

        # The name of the connection to use to connect to the Delta table target.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # Specifies whether the crawler will create native tables, to allow integration with query engines
        # that support querying of the Delta transaction log directly.

        @[JSON::Field(key: "CreateNativeDeltaTable")]
        getter create_native_delta_table : Bool?

        # A list of the Amazon S3 paths to the Delta tables.

        @[JSON::Field(key: "DeltaTables")]
        getter delta_tables : Array(String)?

        # Specifies whether to write the manifest files to the Delta table path.

        @[JSON::Field(key: "WriteManifest")]
        getter write_manifest : Bool?

        def initialize(
          @connection_name : String? = nil,
          @create_native_delta_table : Bool? = nil,
          @delta_tables : Array(String)? = nil,
          @write_manifest : Bool? = nil
        )
        end
      end


      struct DescribeConnectionTypeRequest
        include JSON::Serializable

        # The name of the connection type to be described.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        def initialize(
          @connection_type : String
        )
        end
      end


      struct DescribeConnectionTypeResponse
        include JSON::Serializable

        # Connection properties specific to the Athena compute environment.

        @[JSON::Field(key: "AthenaConnectionProperties")]
        getter athena_connection_properties : Hash(String, Types::Property)?

        # The type of authentication used for the connection.

        @[JSON::Field(key: "AuthenticationConfiguration")]
        getter authentication_configuration : Types::AuthConfiguration?

        # The supported authentication types, data interface types (compute environments), and data operations
        # of the connector.

        @[JSON::Field(key: "Capabilities")]
        getter capabilities : Types::Capabilities?

        # The compute environments that are supported by the connection.

        @[JSON::Field(key: "ComputeEnvironmentConfigurations")]
        getter compute_environment_configurations : Hash(String, Types::ComputeEnvironmentConfiguration)?

        # Returns properties that can be set when creating a connection in the
        # ConnectionInput.ConnectionProperties . ConnectionOptions defines parameters that can be set in a
        # Spark ETL script in the connection options map passed to a dataframe.

        @[JSON::Field(key: "ConnectionOptions")]
        getter connection_options : Hash(String, Types::Property)?

        # Connection properties which are common across compute environments.

        @[JSON::Field(key: "ConnectionProperties")]
        getter connection_properties : Hash(String, Types::Property)?

        # The name of the connection type.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String?

        # A description of the connection type.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Physical requirements for a connection, such as VPC, Subnet and Security Group specifications.

        @[JSON::Field(key: "PhysicalConnectionRequirements")]
        getter physical_connection_requirements : Hash(String, Types::Property)?

        # Connection properties specific to the Python compute environment.

        @[JSON::Field(key: "PythonConnectionProperties")]
        getter python_connection_properties : Hash(String, Types::Property)?

        # Connection properties specific to the Spark compute environment.

        @[JSON::Field(key: "SparkConnectionProperties")]
        getter spark_connection_properties : Hash(String, Types::Property)?

        def initialize(
          @athena_connection_properties : Hash(String, Types::Property)? = nil,
          @authentication_configuration : Types::AuthConfiguration? = nil,
          @capabilities : Types::Capabilities? = nil,
          @compute_environment_configurations : Hash(String, Types::ComputeEnvironmentConfiguration)? = nil,
          @connection_options : Hash(String, Types::Property)? = nil,
          @connection_properties : Hash(String, Types::Property)? = nil,
          @connection_type : String? = nil,
          @description : String? = nil,
          @physical_connection_requirements : Hash(String, Types::Property)? = nil,
          @python_connection_properties : Hash(String, Types::Property)? = nil,
          @spark_connection_properties : Hash(String, Types::Property)? = nil
        )
        end
      end


      struct DescribeEntityRequest
        include JSON::Serializable

        # The name of the connection that contains the connection type credentials.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String

        # The name of the entity that you want to describe from the connection type.

        @[JSON::Field(key: "EntityName")]
        getter entity_name : String

        # The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon
        # Web Services Account ID is the catalog ID.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The version of the API used for the data store.

        @[JSON::Field(key: "DataStoreApiVersion")]
        getter data_store_api_version : String?

        # A continuation token, included if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @connection_name : String,
          @entity_name : String,
          @catalog_id : String? = nil,
          @data_store_api_version : String? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct DescribeEntityResponse
        include JSON::Serializable

        # Describes the fields for that connector entity. This is the list of Field objects. Field is very
        # similar to column in a database. The Field object has information about different properties
        # associated with fields in the connector.

        @[JSON::Field(key: "Fields")]
        getter fields : Array(Types::Field)?

        # A continuation token, present if the current segment is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @fields : Array(Types::Field)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct DescribeInboundIntegrationsRequest
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the integration.

        @[JSON::Field(key: "IntegrationArn")]
        getter integration_arn : String?

        # A token to specify where to start paginating. This is the marker from a previously truncated
        # response.

        @[JSON::Field(key: "Marker")]
        getter marker : String?

        # The total number of items to return in the output.

        @[JSON::Field(key: "MaxRecords")]
        getter max_records : Int32?

        # The Amazon Resource Name (ARN) of the target resource in the integration.

        @[JSON::Field(key: "TargetArn")]
        getter target_arn : String?

        def initialize(
          @integration_arn : String? = nil,
          @marker : String? = nil,
          @max_records : Int32? = nil,
          @target_arn : String? = nil
        )
        end
      end


      struct DescribeInboundIntegrationsResponse
        include JSON::Serializable

        # A list of inbound integrations.

        @[JSON::Field(key: "InboundIntegrations")]
        getter inbound_integrations : Array(Types::InboundIntegration)?

        # A value that indicates the starting point for the next set of response records in a subsequent
        # request.

        @[JSON::Field(key: "Marker")]
        getter marker : String?

        def initialize(
          @inbound_integrations : Array(Types::InboundIntegration)? = nil,
          @marker : String? = nil
        )
        end
      end


      struct DescribeIntegrationsRequest
        include JSON::Serializable

        # A list of key and values, to filter down the results. Supported keys are "Status",
        # "IntegrationName", and "SourceArn". IntegrationName is limited to only one value.

        @[JSON::Field(key: "Filters")]
        getter filters : Array(Types::IntegrationFilter)?

        # The Amazon Resource Name (ARN) for the integration.

        @[JSON::Field(key: "IntegrationIdentifier")]
        getter integration_identifier : String?

        # A value that indicates the starting point for the next set of response records in a subsequent
        # request.

        @[JSON::Field(key: "Marker")]
        getter marker : String?

        # The total number of items to return in the output.

        @[JSON::Field(key: "MaxRecords")]
        getter max_records : Int32?

        def initialize(
          @filters : Array(Types::IntegrationFilter)? = nil,
          @integration_identifier : String? = nil,
          @marker : String? = nil,
          @max_records : Int32? = nil
        )
        end
      end


      struct DescribeIntegrationsResponse
        include JSON::Serializable

        # A list of zero-ETL integrations.

        @[JSON::Field(key: "Integrations")]
        getter integrations : Array(Types::Integration)?

        # A value that indicates the starting point for the next set of response records in a subsequent
        # request.

        @[JSON::Field(key: "Marker")]
        getter marker : String?

        def initialize(
          @integrations : Array(Types::Integration)? = nil,
          @marker : String? = nil
        )
        end
      end

      # A development endpoint where a developer can remotely debug extract, transform, and load (ETL)
      # scripts.

      struct DevEndpoint
        include JSON::Serializable

        # A map of arguments used to configure the DevEndpoint . Valid arguments are:
        # "--enable-glue-datacatalog": "" You can specify a version of Python support for development
        # endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no
        # arguments are provided, the version defaults to Python 2.

        @[JSON::Field(key: "Arguments")]
        getter arguments : Hash(String, String)?

        # The Amazon Web Services Availability Zone where this DevEndpoint is located.

        @[JSON::Field(key: "AvailabilityZone")]
        getter availability_zone : String?

        # The point in time at which this DevEndpoint was created.

        @[JSON::Field(key: "CreatedTimestamp", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_timestamp : Time?

        # The name of the DevEndpoint .

        @[JSON::Field(key: "EndpointName")]
        getter endpoint_name : String?

        # The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint .
        # You can only use pure Java/Scala libraries with a DevEndpoint .

        @[JSON::Field(key: "ExtraJarsS3Path")]
        getter extra_jars_s3_path : String?

        # The paths to one or more Python libraries in an Amazon S3 bucket that should be loaded in your
        # DevEndpoint . Multiple values must be complete paths separated by a comma. You can only use pure
        # Python libraries with a DevEndpoint . Libraries that rely on C extensions, such as the pandas Python
        # data analysis library, are not currently supported.

        @[JSON::Field(key: "ExtraPythonLibsS3Path")]
        getter extra_python_libs_s3_path : String?

        # The reason for a current failure in this DevEndpoint .

        @[JSON::Field(key: "FailureReason")]
        getter failure_reason : String?

        # Glue version determines the versions of Apache Spark and Python that Glue supports. The Python
        # version indicates the version supported for running your ETL scripts on development endpoints. For
        # more information about the available Glue versions and corresponding Spark and Python versions, see
        # Glue version in the developer guide. Development endpoints that are created without specifying a
        # Glue version default to Glue 0.9. You can specify a version of Python support for development
        # endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no
        # arguments are provided, the version defaults to Python 2.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # The point in time at which this DevEndpoint was last modified.

        @[JSON::Field(key: "LastModifiedTimestamp", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_timestamp : Time?

        # The status of the last update.

        @[JSON::Field(key: "LastUpdateStatus")]
        getter last_update_status : String?

        # The number of Glue Data Processing Units (DPUs) allocated to this DevEndpoint .

        @[JSON::Field(key: "NumberOfNodes")]
        getter number_of_nodes : Int32?

        # The number of workers of a defined workerType that are allocated to the development endpoint. The
        # maximum number of workers you can define are 299 for G.1X , and 149 for G.2X .

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # A private IP address to access the DevEndpoint within a VPC if the DevEndpoint is created within
        # one. The PrivateAddress field is present only when you create the DevEndpoint within your VPC.

        @[JSON::Field(key: "PrivateAddress")]
        getter private_address : String?

        # The public IP address used by this DevEndpoint . The PublicAddress field is present only when you
        # create a non-virtual private cloud (VPC) DevEndpoint .

        @[JSON::Field(key: "PublicAddress")]
        getter public_address : String?

        # The public key to be used by this DevEndpoint for authentication. This attribute is provided for
        # backward compatibility because the recommended attribute to use is public keys.

        @[JSON::Field(key: "PublicKey")]
        getter public_key : String?

        # A list of public keys to be used by the DevEndpoints for authentication. Using this attribute is
        # preferred over a single public key because the public keys allow you to have a different private key
        # per client. If you previously created an endpoint with a public key, you must remove that key to be
        # able to set a list of public keys. Call the UpdateDevEndpoint API operation with the public key
        # content in the deletePublicKeys attribute, and the list of new keys in the addPublicKeys attribute.

        @[JSON::Field(key: "PublicKeys")]
        getter public_keys : Array(String)?

        # The Amazon Resource Name (ARN) of the IAM role used in this DevEndpoint .

        @[JSON::Field(key: "RoleArn")]
        getter role_arn : String?

        # The name of the SecurityConfiguration structure to be used with this DevEndpoint .

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # A list of security group identifiers used in this DevEndpoint .

        @[JSON::Field(key: "SecurityGroupIds")]
        getter security_group_ids : Array(String)?

        # The current status of this DevEndpoint .

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The subnet ID for this DevEndpoint .

        @[JSON::Field(key: "SubnetId")]
        getter subnet_id : String?

        # The ID of the virtual private cloud (VPC) used by this DevEndpoint .

        @[JSON::Field(key: "VpcId")]
        getter vpc_id : String?

        # The type of predefined worker that is allocated to the development endpoint. Accepts a value of
        # Standard, G.1X, or G.2X. For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory
        # and a 50GB disk, and 2 executors per worker. For the G.1X worker type, each worker maps to 1 DPU (4
        # vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. We recommend this worker
        # type for memory-intensive jobs. For the G.2X worker type, each worker maps to 2 DPU (8 vCPU, 32 GB
        # of memory, 128 GB disk), and provides 1 executor per worker. We recommend this worker type for
        # memory-intensive jobs. Known issue: when a development endpoint is created with the G.2X WorkerType
        # configuration, the Spark drivers for the development endpoint will run on 4 vCPU, 16 GB of memory,
        # and a 64 GB disk.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        # The YARN endpoint address used by this DevEndpoint .

        @[JSON::Field(key: "YarnEndpointAddress")]
        getter yarn_endpoint_address : String?

        # The Apache Zeppelin port for the remote Apache Spark interpreter.

        @[JSON::Field(key: "ZeppelinRemoteSparkInterpreterPort")]
        getter zeppelin_remote_spark_interpreter_port : Int32?

        def initialize(
          @arguments : Hash(String, String)? = nil,
          @availability_zone : String? = nil,
          @created_timestamp : Time? = nil,
          @endpoint_name : String? = nil,
          @extra_jars_s3_path : String? = nil,
          @extra_python_libs_s3_path : String? = nil,
          @failure_reason : String? = nil,
          @glue_version : String? = nil,
          @last_modified_timestamp : Time? = nil,
          @last_update_status : String? = nil,
          @number_of_nodes : Int32? = nil,
          @number_of_workers : Int32? = nil,
          @private_address : String? = nil,
          @public_address : String? = nil,
          @public_key : String? = nil,
          @public_keys : Array(String)? = nil,
          @role_arn : String? = nil,
          @security_configuration : String? = nil,
          @security_group_ids : Array(String)? = nil,
          @status : String? = nil,
          @subnet_id : String? = nil,
          @vpc_id : String? = nil,
          @worker_type : String? = nil,
          @yarn_endpoint_address : String? = nil,
          @zeppelin_remote_spark_interpreter_port : Int32? = nil
        )
        end
      end

      # Custom libraries to be loaded into a development endpoint.

      struct DevEndpointCustomLibraries
        include JSON::Serializable

        # The path to one or more Java .jar files in an S3 bucket that should be loaded in your DevEndpoint .
        # You can only use pure Java/Scala libraries with a DevEndpoint .

        @[JSON::Field(key: "ExtraJarsS3Path")]
        getter extra_jars_s3_path : String?

        # The paths to one or more Python libraries in an Amazon Simple Storage Service (Amazon S3) bucket
        # that should be loaded in your DevEndpoint . Multiple values must be complete paths separated by a
        # comma. You can only use pure Python libraries with a DevEndpoint . Libraries that rely on C
        # extensions, such as the pandas Python data analysis library, are not currently supported.

        @[JSON::Field(key: "ExtraPythonLibsS3Path")]
        getter extra_python_libs_s3_path : String?

        def initialize(
          @extra_jars_s3_path : String? = nil,
          @extra_python_libs_s3_path : String? = nil
        )
        end
      end

      # Specifies the direct JDBC source connection.

      struct DirectJDBCSource
        include JSON::Serializable

        # The connection name of the JDBC source.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String

        # The connection type of the JDBC source.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        # The database of the JDBC source connection.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the JDBC source connection.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The table of the JDBC source connection.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies the data schema for the direct JDBC source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # The temp directory of the JDBC Redshift source.

        @[JSON::Field(key: "RedshiftTmpDir")]
        getter redshift_tmp_dir : String?

        def initialize(
          @connection_name : String,
          @connection_type : String,
          @database : String,
          @name : String,
          @table : String,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @redshift_tmp_dir : String? = nil
        )
        end
      end

      # Specifies an Apache Kafka data store.

      struct DirectKafkaSource
        include JSON::Serializable

        # The name of the data store.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Specifies options related to data preview for viewing a sample of your data.

        @[JSON::Field(key: "DataPreviewOptions")]
        getter data_preview_options : Types::StreamingDataPreviewOptions?

        # Whether to automatically determine the schema from the incoming data.

        @[JSON::Field(key: "DetectSchema")]
        getter detect_schema : Bool?

        # Specifies the streaming options.

        @[JSON::Field(key: "StreamingOptions")]
        getter streaming_options : Types::KafkaStreamingSourceOptions?

        # The amount of time to spend processing each micro batch.

        @[JSON::Field(key: "WindowSize")]
        getter window_size : Int32?

        def initialize(
          @name : String,
          @data_preview_options : Types::StreamingDataPreviewOptions? = nil,
          @detect_schema : Bool? = nil,
          @streaming_options : Types::KafkaStreamingSourceOptions? = nil,
          @window_size : Int32? = nil
        )
        end
      end

      # Specifies a direct Amazon Kinesis data source.

      struct DirectKinesisSource
        include JSON::Serializable

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Additional options for data preview.

        @[JSON::Field(key: "DataPreviewOptions")]
        getter data_preview_options : Types::StreamingDataPreviewOptions?

        # Whether to automatically determine the schema from the incoming data.

        @[JSON::Field(key: "DetectSchema")]
        getter detect_schema : Bool?

        # Additional options for the Kinesis streaming data source.

        @[JSON::Field(key: "StreamingOptions")]
        getter streaming_options : Types::KinesisStreamingSourceOptions?

        # The amount of time to spend processing each micro batch.

        @[JSON::Field(key: "WindowSize")]
        getter window_size : Int32?

        def initialize(
          @name : String,
          @data_preview_options : Types::StreamingDataPreviewOptions? = nil,
          @detect_schema : Bool? = nil,
          @streaming_options : Types::KinesisStreamingSourceOptions? = nil,
          @window_size : Int32? = nil
        )
        end
      end

      # A policy that specifies update behavior for the crawler.

      struct DirectSchemaChangePolicy
        include JSON::Serializable

        # Specifies the database that the schema change policy applies to.

        @[JSON::Field(key: "Database")]
        getter database : String?

        # Whether to use the specified update behavior when the crawler finds a changed schema.

        @[JSON::Field(key: "EnableUpdateCatalog")]
        getter enable_update_catalog : Bool?

        # Specifies the table in the database that the schema change policy applies to.

        @[JSON::Field(key: "Table")]
        getter table : String?

        # The update behavior when the crawler finds a changed schema.

        @[JSON::Field(key: "UpdateBehavior")]
        getter update_behavior : String?

        def initialize(
          @database : String? = nil,
          @enable_update_catalog : Bool? = nil,
          @table : String? = nil,
          @update_behavior : String? = nil
        )
        end
      end

      # Defines column statistics supported for floating-point number data columns.

      struct DoubleColumnStatisticsData
        include JSON::Serializable

        # The number of distinct values in a column.

        @[JSON::Field(key: "NumberOfDistinctValues")]
        getter number_of_distinct_values : Int64

        # The number of null values in the column.

        @[JSON::Field(key: "NumberOfNulls")]
        getter number_of_nulls : Int64

        # The highest value in the column.

        @[JSON::Field(key: "MaximumValue")]
        getter maximum_value : Float64?

        # The lowest value in the column.

        @[JSON::Field(key: "MinimumValue")]
        getter minimum_value : Float64?

        def initialize(
          @number_of_distinct_values : Int64,
          @number_of_nulls : Int64,
          @maximum_value : Float64? = nil,
          @minimum_value : Float64? = nil
        )
        end
      end

      # Specifies a transform that removes rows of repeating data from a data set.

      struct DropDuplicates
        include JSON::Serializable

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the columns to be merged or removed if repeating.

        @[JSON::Field(key: "Columns")]
        getter columns : Array(Array(String))?

        def initialize(
          @inputs : Array(String),
          @name : String,
          @columns : Array(Array(String))? = nil
        )
        end
      end

      # Specifies a transform that chooses the data property keys that you want to drop.

      struct DropFields
        include JSON::Serializable

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A JSON path to a variable in the data structure.

        @[JSON::Field(key: "Paths")]
        getter paths : Array(Array(String))

        def initialize(
          @inputs : Array(String),
          @name : String,
          @paths : Array(Array(String))
        )
        end
      end

      # Specifies a transform that removes columns from the dataset if all values in the column are 'null'.
      # By default, Glue Studio will recognize null objects, but some values such as empty strings, strings
      # that are "null", -1 integers or other placeholders such as zeros, are not automatically recognized
      # as nulls.

      struct DropNullFields
        include JSON::Serializable

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A structure that represents whether certain values are recognized as null values for removal.

        @[JSON::Field(key: "NullCheckBoxList")]
        getter null_check_box_list : Types::NullCheckBoxList?

        # A structure that specifies a list of NullValueField structures that represent a custom null value
        # such as zero or other value being used as a null placeholder unique to the dataset. The
        # DropNullFields transform removes custom null values only if both the value of the null placeholder
        # and the datatype match the data.

        @[JSON::Field(key: "NullTextList")]
        getter null_text_list : Array(Types::NullValueField)?

        def initialize(
          @inputs : Array(String),
          @name : String,
          @null_check_box_list : Types::NullCheckBoxList? = nil,
          @null_text_list : Array(Types::NullValueField)? = nil
        )
        end
      end

      # Specifies the set of parameters needed to perform the dynamic transform.

      struct DynamicTransform
        include JSON::Serializable

        # Specifies the name of the function of the dynamic transform.

        @[JSON::Field(key: "FunctionName")]
        getter function_name : String

        # Specifies the inputs for the dynamic transform that are required.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # Specifies the name of the dynamic transform.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Specifies the path of the dynamic transform source and config files.

        @[JSON::Field(key: "Path")]
        getter path : String

        # Specifies the name of the dynamic transform as it appears in the Glue Studio visual editor.

        @[JSON::Field(key: "TransformName")]
        getter transform_name : String

        # Specifies the data schema for the dynamic transform.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # Specifies the parameters of the dynamic transform.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Array(Types::TransformConfigParameter)?

        # This field is not used and will be deprecated in future release.

        @[JSON::Field(key: "Version")]
        getter version : String?

        def initialize(
          @function_name : String,
          @inputs : Array(String),
          @name : String,
          @path : String,
          @transform_name : String,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @parameters : Array(Types::TransformConfigParameter)? = nil,
          @version : String? = nil
        )
        end
      end

      # Specifies a DynamoDB data source in the Glue Data Catalog.

      struct DynamoDBCatalogSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options for the DynamoDB data source.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Types::DDBELTCatalogAdditionalOptions?

        # Specifies whether Point-in-Time Recovery (PITR) is enabled for the DynamoDB table. When set to true
        # , allows reading from a specific point in time. The default value is false .

        @[JSON::Field(key: "PitrEnabled")]
        getter pitr_enabled : Bool?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @additional_options : Types::DDBELTCatalogAdditionalOptions? = nil,
          @pitr_enabled : Bool? = nil
        )
        end
      end

      # Specifies a DynamoDB ELT connector source for extracting data from DynamoDB tables.

      struct DynamoDBELTConnectorSource
        include JSON::Serializable

        # The name of the DynamoDB ELT connector source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The connection options for the DynamoDB ELT connector source.

        @[JSON::Field(key: "ConnectionOptions")]
        getter connection_options : Types::DDBELTConnectionOptions?

        # Specifies the data schema for the DynamoDB ELT connector source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @name : String,
          @connection_options : Types::DDBELTConnectionOptions? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies an Amazon DynamoDB table to crawl.

      struct DynamoDBTarget
        include JSON::Serializable

        # The name of the DynamoDB table to crawl.

        @[JSON::Field(key: "Path")]
        getter path : String?

        # Indicates whether to scan all the records, or to sample rows from the table. Scanning all the
        # records can take a long time when the table is not a high throughput table. A value of true means to
        # scan all records, while a value of false means to sample the records. If no value is specified, the
        # value defaults to true .

        @[JSON::Field(key: "scanAll")]
        getter scan_all : Bool?

        # The percentage of the configured read capacity units to use by the Glue crawler. Read capacity units
        # is a term defined by DynamoDB, and is a numeric value that acts as rate limiter for the number of
        # reads that can be performed on that table per second. The valid values are null or a value between
        # 0.1 to 1.5. A null value is used when user does not provide a value, and defaults to 0.5 of the
        # configured Read Capacity Unit (for provisioned tables), or 0.25 of the max configured Read Capacity
        # Unit (for tables using on-demand mode).

        @[JSON::Field(key: "scanRate")]
        getter scan_rate : Float64?

        def initialize(
          @path : String? = nil,
          @scan_all : Bool? = nil,
          @scan_rate : Float64? = nil
        )
        end
      end

      # An edge represents a directed connection between two Glue components that are part of the workflow
      # the edge belongs to.

      struct Edge
        include JSON::Serializable

        # The unique of the node within the workflow where the edge ends.

        @[JSON::Field(key: "DestinationId")]
        getter destination_id : String?

        # The unique of the node within the workflow where the edge starts.

        @[JSON::Field(key: "SourceId")]
        getter source_id : String?

        def initialize(
          @destination_id : String? = nil,
          @source_id : String? = nil
        )
        end
      end

      # Specifies the encryption-at-rest configuration for the Data Catalog.

      struct EncryptionAtRest
        include JSON::Serializable

        # The encryption-at-rest mode for encrypting Data Catalog data.

        @[JSON::Field(key: "CatalogEncryptionMode")]
        getter catalog_encryption_mode : String

        # The role that Glue assumes to encrypt and decrypt the Data Catalog objects on the caller's behalf.

        @[JSON::Field(key: "CatalogEncryptionServiceRole")]
        getter catalog_encryption_service_role : String?

        # The ID of the KMS key to use for encryption at rest.

        @[JSON::Field(key: "SseAwsKmsKeyId")]
        getter sse_aws_kms_key_id : String?

        def initialize(
          @catalog_encryption_mode : String,
          @catalog_encryption_service_role : String? = nil,
          @sse_aws_kms_key_id : String? = nil
        )
        end
      end

      # Specifies an encryption configuration.

      struct EncryptionConfiguration
        include JSON::Serializable

        # The encryption configuration for Amazon CloudWatch.

        @[JSON::Field(key: "CloudWatchEncryption")]
        getter cloud_watch_encryption : Types::CloudWatchEncryption?

        # The encryption configuration for Glue Data Quality assets.

        @[JSON::Field(key: "DataQualityEncryption")]
        getter data_quality_encryption : Types::DataQualityEncryption?

        # The encryption configuration for job bookmarks.

        @[JSON::Field(key: "JobBookmarksEncryption")]
        getter job_bookmarks_encryption : Types::JobBookmarksEncryption?

        # The encryption configuration for Amazon Simple Storage Service (Amazon S3) data.

        @[JSON::Field(key: "S3Encryption")]
        getter s3_encryption : Array(Types::S3Encryption)?

        def initialize(
          @cloud_watch_encryption : Types::CloudWatchEncryption? = nil,
          @data_quality_encryption : Types::DataQualityEncryption? = nil,
          @job_bookmarks_encryption : Types::JobBookmarksEncryption? = nil,
          @s3_encryption : Array(Types::S3Encryption)? = nil
        )
        end
      end

      # An entity supported by a given ConnectionType .

      struct Entity
        include JSON::Serializable

        # The type of entities that are present in the response. This value depends on the source connection.
        # For example this is SObjects for Salesforce and databases or schemas or tables for sources like
        # Amazon Redshift.

        @[JSON::Field(key: "Category")]
        getter category : String?

        # An optional map of keys which may be returned for an entity by a connector.

        @[JSON::Field(key: "CustomProperties")]
        getter custom_properties : Hash(String, String)?

        # A description of the entity.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The name of the entity.

        @[JSON::Field(key: "EntityName")]
        getter entity_name : String?

        # A Boolean value which helps to determine whether there are sub objects that can be listed.

        @[JSON::Field(key: "IsParentEntity")]
        getter is_parent_entity : Bool?

        # Label used for the entity.

        @[JSON::Field(key: "Label")]
        getter label : String?

        def initialize(
          @category : String? = nil,
          @custom_properties : Hash(String, String)? = nil,
          @description : String? = nil,
          @entity_name : String? = nil,
          @is_parent_entity : Bool? = nil,
          @label : String? = nil
        )
        end
      end

      # A specified entity does not exist

      struct EntityNotFoundException
        include JSON::Serializable

        # Indicates whether or not the exception relates to a federated source.

        @[JSON::Field(key: "FromFederationSource")]
        getter from_federation_source : Bool?

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @from_federation_source : Bool? = nil,
          @message : String? = nil
        )
        end
      end

      # Contains details about an error.

      struct ErrorDetail
        include JSON::Serializable

        # The code associated with this error.

        @[JSON::Field(key: "ErrorCode")]
        getter error_code : String?

        # A message describing the error.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        def initialize(
          @error_code : String? = nil,
          @error_message : String? = nil
        )
        end
      end

      # An object containing error details.

      struct ErrorDetails
        include JSON::Serializable

        # The error code for an error.

        @[JSON::Field(key: "ErrorCode")]
        getter error_code : String?

        # The error message for an error.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        def initialize(
          @error_code : String? = nil,
          @error_message : String? = nil
        )
        end
      end

      # Specifies your data quality evaluation criteria.

      struct EvaluateDataQuality
        include JSON::Serializable

        # The inputs of your data quality evaluation.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data quality evaluation.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ruleset for your data quality evaluation.

        @[JSON::Field(key: "Ruleset")]
        getter ruleset : String

        # The output of your data quality evaluation.

        @[JSON::Field(key: "Output")]
        getter output : String?

        # Options to configure how your results are published.

        @[JSON::Field(key: "PublishingOptions")]
        getter publishing_options : Types::DQResultsPublishingOptions?

        # Options to configure how your job will stop if your data quality evaluation fails.

        @[JSON::Field(key: "StopJobOnFailureOptions")]
        getter stop_job_on_failure_options : Types::DQStopJobOnFailureOptions?

        def initialize(
          @inputs : Array(String),
          @name : String,
          @ruleset : String,
          @output : String? = nil,
          @publishing_options : Types::DQResultsPublishingOptions? = nil,
          @stop_job_on_failure_options : Types::DQStopJobOnFailureOptions? = nil
        )
        end
      end

      # Specifies your data quality evaluation criteria.

      struct EvaluateDataQualityMultiFrame
        include JSON::Serializable

        # The inputs of your data quality evaluation. The first input in this list is the primary data source.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data quality evaluation.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ruleset for your data quality evaluation.

        @[JSON::Field(key: "Ruleset")]
        getter ruleset : String

        # The aliases of all data sources except primary.

        @[JSON::Field(key: "AdditionalDataSources")]
        getter additional_data_sources : Hash(String, String)?

        # Options to configure runtime behavior of the transform.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?

        # Options to configure how your results are published.

        @[JSON::Field(key: "PublishingOptions")]
        getter publishing_options : Types::DQResultsPublishingOptions?

        # Options to configure how your job will stop if your data quality evaluation fails.

        @[JSON::Field(key: "StopJobOnFailureOptions")]
        getter stop_job_on_failure_options : Types::DQStopJobOnFailureOptions?

        def initialize(
          @inputs : Array(String),
          @name : String,
          @ruleset : String,
          @additional_data_sources : Hash(String, String)? = nil,
          @additional_options : Hash(String, String)? = nil,
          @publishing_options : Types::DQResultsPublishingOptions? = nil,
          @stop_job_on_failure_options : Types::DQStopJobOnFailureOptions? = nil
        )
        end
      end

      # Evaluation metrics provide an estimate of the quality of your machine learning transform.

      struct EvaluationMetrics
        include JSON::Serializable

        # The type of machine learning transform.

        @[JSON::Field(key: "TransformType")]
        getter transform_type : String

        # The evaluation metrics for the find matches algorithm.

        @[JSON::Field(key: "FindMatchesMetrics")]
        getter find_matches_metrics : Types::FindMatchesMetrics?

        def initialize(
          @transform_type : String,
          @find_matches_metrics : Types::FindMatchesMetrics? = nil
        )
        end
      end

      # Batch condition that must be met (specified number of events received or batch time window expired)
      # before EventBridge event trigger fires.

      struct EventBatchingCondition
        include JSON::Serializable

        # Number of events that must be received from Amazon EventBridge before EventBridge event trigger
        # fires.

        @[JSON::Field(key: "BatchSize")]
        getter batch_size : Int32

        # Window of time in seconds after which EventBridge event trigger fires. Window starts when first
        # event is received.

        @[JSON::Field(key: "BatchWindow")]
        getter batch_window : Int32?

        def initialize(
          @batch_size : Int32,
          @batch_window : Int32? = nil
        )
        end
      end

      # A run attempt for a column statistics task run.

      struct ExecutionAttempt
        include JSON::Serializable

        # A task run ID for the last column statistics task run.

        @[JSON::Field(key: "ColumnStatisticsTaskRunId")]
        getter column_statistics_task_run_id : String?

        # An error message associated with the last column statistics task run.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # A timestamp when the last column statistics task run occurred.

        @[JSON::Field(key: "ExecutionTimestamp", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter execution_timestamp : Time?

        # The status of the last column statistics task run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        def initialize(
          @column_statistics_task_run_id : String? = nil,
          @error_message : String? = nil,
          @execution_timestamp : Time? = nil,
          @status : String? = nil
        )
        end
      end

      # An execution property of a job.

      struct ExecutionProperty
        include JSON::Serializable

        # The maximum number of concurrent runs allowed for the job. The default is 1. An error is returned
        # when this threshold is reached. The maximum value you can specify is controlled by a service limit.

        @[JSON::Field(key: "MaxConcurrentRuns")]
        getter max_concurrent_runs : Int32?

        def initialize(
          @max_concurrent_runs : Int32? = nil
        )
        end
      end

      # Specifies configuration properties for an exporting labels task run.

      struct ExportLabelsTaskRunProperties
        include JSON::Serializable

        # The Amazon Simple Storage Service (Amazon S3) path where you will export the labels.

        @[JSON::Field(key: "OutputS3Path")]
        getter output_s3_path : String?

        def initialize(
          @output_s3_path : String? = nil
        )
        end
      end

      # A catalog that points to an entity outside the Glue Data Catalog.

      struct FederatedCatalog
        include JSON::Serializable

        # The name of the connection to an external data source, for example a Redshift-federated catalog.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # The type of connection used to access the federated catalog, specifying the protocol or method for
        # connection to the external data source.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String?

        # A unique identifier for the federated catalog.

        @[JSON::Field(key: "Identifier")]
        getter identifier : String?

        def initialize(
          @connection_name : String? = nil,
          @connection_type : String? = nil,
          @identifier : String? = nil
        )
        end
      end

      # A database that points to an entity outside the Glue Data Catalog.

      struct FederatedDatabase
        include JSON::Serializable

        # The name of the connection to the external metastore.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # The type of connection used to access the federated database, such as JDBC, ODBC, or other supported
        # connection protocols.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String?

        # A unique identifier for the federated database.

        @[JSON::Field(key: "Identifier")]
        getter identifier : String?

        def initialize(
          @connection_name : String? = nil,
          @connection_type : String? = nil,
          @identifier : String? = nil
        )
        end
      end

      # A federated resource already exists.

      struct FederatedResourceAlreadyExistsException
        include JSON::Serializable

        # The associated Glue resource already exists.

        @[JSON::Field(key: "AssociatedGlueResource")]
        getter associated_glue_resource : String?

        # The message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @associated_glue_resource : String? = nil,
          @message : String? = nil
        )
        end
      end

      # A table that points to an entity outside the Glue Data Catalog.

      struct FederatedTable
        include JSON::Serializable

        # The name of the connection to the external metastore.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # The type of connection used to access the federated table, specifying the protocol or method for
        # connecting to the external data source.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String?

        # A unique identifier for the federated database.

        @[JSON::Field(key: "DatabaseIdentifier")]
        getter database_identifier : String?

        # A unique identifier for the federated table.

        @[JSON::Field(key: "Identifier")]
        getter identifier : String?

        def initialize(
          @connection_name : String? = nil,
          @connection_type : String? = nil,
          @database_identifier : String? = nil,
          @identifier : String? = nil
        )
        end
      end

      # A federation source failed.

      struct FederationSourceException
        include JSON::Serializable

        # The error code of the problem.

        @[JSON::Field(key: "FederationSourceErrorCode")]
        getter federation_source_error_code : String?

        # The message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @federation_source_error_code : String? = nil,
          @message : String? = nil
        )
        end
      end

      # A federation source failed, but the operation may be retried.

      struct FederationSourceRetryableException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The Field object has information about the different properties associated with a field in the
      # connector.

      struct Field
        include JSON::Serializable

        # Optional map of keys which may be returned.

        @[JSON::Field(key: "CustomProperties")]
        getter custom_properties : Hash(String, String)?

        # A description of the field.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A unique identifier for the field.

        @[JSON::Field(key: "FieldName")]
        getter field_name : String?

        # The type of data in the field.

        @[JSON::Field(key: "FieldType")]
        getter field_type : String?

        # Indicates whether this field can be created as part of a destination write.

        @[JSON::Field(key: "IsCreateable")]
        getter is_createable : Bool?

        # Indicates whether this field is populated automatically when the object is created, such as a
        # created at timestamp.

        @[JSON::Field(key: "IsDefaultOnCreate")]
        getter is_default_on_create : Bool?

        # Indicates whether this field can used in a filter clause ( WHERE clause) of a SQL statement when
        # querying data.

        @[JSON::Field(key: "IsFilterable")]
        getter is_filterable : Bool?

        # Indicates whether this field can be nullable or not.

        @[JSON::Field(key: "IsNullable")]
        getter is_nullable : Bool?

        # Indicates whether a given field can be used in partitioning the query made to SaaS.

        @[JSON::Field(key: "IsPartitionable")]
        getter is_partitionable : Bool?

        # Indicates whether this field can used as a primary key for the given entity.

        @[JSON::Field(key: "IsPrimaryKey")]
        getter is_primary_key : Bool?

        # Indicates whether this field can be added in Select clause of SQL query or whether it is retrievable
        # or not.

        @[JSON::Field(key: "IsRetrievable")]
        getter is_retrievable : Bool?

        # Indicates whether this field can be updated as part of a destination write.

        @[JSON::Field(key: "IsUpdateable")]
        getter is_updateable : Bool?

        # Indicates whether this field can be upserted as part of a destination write.

        @[JSON::Field(key: "IsUpsertable")]
        getter is_upsertable : Bool?

        # A readable label used for the field.

        @[JSON::Field(key: "Label")]
        getter label : String?

        # The data type returned by the SaaS API, such as picklist or textarea from Salesforce.

        @[JSON::Field(key: "NativeDataType")]
        getter native_data_type : String?

        # A parent field name for a nested field.

        @[JSON::Field(key: "ParentField")]
        getter parent_field : String?

        # Indicates the support filter operators for this field.

        @[JSON::Field(key: "SupportedFilterOperators")]
        getter supported_filter_operators : Array(String)?

        # A list of supported values for the field.

        @[JSON::Field(key: "SupportedValues")]
        getter supported_values : Array(String)?

        def initialize(
          @custom_properties : Hash(String, String)? = nil,
          @description : String? = nil,
          @field_name : String? = nil,
          @field_type : String? = nil,
          @is_createable : Bool? = nil,
          @is_default_on_create : Bool? = nil,
          @is_filterable : Bool? = nil,
          @is_nullable : Bool? = nil,
          @is_partitionable : Bool? = nil,
          @is_primary_key : Bool? = nil,
          @is_retrievable : Bool? = nil,
          @is_updateable : Bool? = nil,
          @is_upsertable : Bool? = nil,
          @label : String? = nil,
          @native_data_type : String? = nil,
          @parent_field : String? = nil,
          @supported_filter_operators : Array(String)? = nil,
          @supported_values : Array(String)? = nil
        )
        end
      end

      # Specifies a transform that locates records in the dataset that have missing values and adds a new
      # field with a value determined by imputation. The input data set is used to train the machine
      # learning model that determines what the missing value should be.

      struct FillMissingValues
        include JSON::Serializable

        # A JSON path to a variable in the data structure for the dataset that is imputed.

        @[JSON::Field(key: "ImputedPath")]
        getter imputed_path : String

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A JSON path to a variable in the data structure for the dataset that is filled.

        @[JSON::Field(key: "FilledPath")]
        getter filled_path : String?

        def initialize(
          @imputed_path : String,
          @inputs : Array(String),
          @name : String,
          @filled_path : String? = nil
        )
        end
      end

      # Specifies a transform that splits a dataset into two, based on a filter condition.

      struct Filter
        include JSON::Serializable

        # Specifies a filter expression.

        @[JSON::Field(key: "Filters")]
        getter filters : Array(Types::FilterExpression)

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The operator used to filter rows by comparing the key value to a specified value.

        @[JSON::Field(key: "LogicalOperator")]
        getter logical_operator : String

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @filters : Array(Types::FilterExpression),
          @inputs : Array(String),
          @logical_operator : String,
          @name : String
        )
        end
      end

      # Specifies a filter expression.

      struct FilterExpression
        include JSON::Serializable

        # The type of operation to perform in the expression.

        @[JSON::Field(key: "Operation")]
        getter operation : String

        # A list of filter values.

        @[JSON::Field(key: "Values")]
        getter values : Array(Types::FilterValue)

        # Whether the expression is to be negated.

        @[JSON::Field(key: "Negated")]
        getter negated : Bool?

        def initialize(
          @operation : String,
          @values : Array(Types::FilterValue),
          @negated : Bool? = nil
        )
        end
      end

      # Represents a single entry in the list of values for a FilterExpression .

      struct FilterValue
        include JSON::Serializable

        # The type of filter value.

        @[JSON::Field(key: "Type")]
        getter type : String

        # The value to be associated.

        @[JSON::Field(key: "Value")]
        getter value : Array(String)

        def initialize(
          @type : String,
          @value : Array(String)
        )
        end
      end

      # The evaluation metrics for the find matches algorithm. The quality of your machine learning
      # transform is measured by getting your transform to predict some matches and comparing the results to
      # known matches from the same dataset. The quality metrics are based on a subset of your data, so they
      # are not precise.

      struct FindMatchesMetrics
        include JSON::Serializable

        # The area under the precision/recall curve (AUPRC) is a single number measuring the overall quality
        # of the transform, that is independent of the choice made for precision vs. recall. Higher values
        # indicate that you have a more attractive precision vs. recall tradeoff. For more information, see
        # Precision and recall in Wikipedia.

        @[JSON::Field(key: "AreaUnderPRCurve")]
        getter area_under_pr_curve : Float64?

        # A list of ColumnImportance structures containing column importance metrics, sorted in order of
        # descending importance.

        @[JSON::Field(key: "ColumnImportances")]
        getter column_importances : Array(Types::ColumnImportance)?

        # The confusion matrix shows you what your transform is predicting accurately and what types of errors
        # it is making. For more information, see Confusion matrix in Wikipedia.

        @[JSON::Field(key: "ConfusionMatrix")]
        getter confusion_matrix : Types::ConfusionMatrix?

        # The maximum F1 metric indicates the transform's accuracy between 0 and 1, where 1 is the best
        # accuracy. For more information, see F1 score in Wikipedia.

        @[JSON::Field(key: "F1")]
        getter f1 : Float64?

        # The precision metric indicates when often your transform is correct when it predicts a match.
        # Specifically, it measures how well the transform finds true positives from the total true positives
        # possible. For more information, see Precision and recall in Wikipedia.

        @[JSON::Field(key: "Precision")]
        getter precision : Float64?

        # The recall metric indicates that for an actual match, how often your transform predicts the match.
        # Specifically, it measures how well the transform finds true positives from the total records in the
        # source data. For more information, see Precision and recall in Wikipedia.

        @[JSON::Field(key: "Recall")]
        getter recall : Float64?

        def initialize(
          @area_under_pr_curve : Float64? = nil,
          @column_importances : Array(Types::ColumnImportance)? = nil,
          @confusion_matrix : Types::ConfusionMatrix? = nil,
          @f1 : Float64? = nil,
          @precision : Float64? = nil,
          @recall : Float64? = nil
        )
        end
      end

      # The parameters to configure the find matches transform.

      struct FindMatchesParameters
        include JSON::Serializable

        # The value that is selected when tuning your transform for a balance between accuracy and cost. A
        # value of 0.5 means that the system balances accuracy and cost concerns. A value of 1.0 means a bias
        # purely for accuracy, which typically results in a higher cost, sometimes substantially higher. A
        # value of 0.0 means a bias purely for cost, which results in a less accurate FindMatches transform,
        # sometimes with unacceptable accuracy. Accuracy measures how well the transform finds true positives
        # and true negatives. Increasing accuracy requires more machine resources and cost. But it also
        # results in increased recall. Cost measures how many compute resources, and thus money, are consumed
        # to run the transform.

        @[JSON::Field(key: "AccuracyCostTradeoff")]
        getter accuracy_cost_tradeoff : Float64?

        # The value to switch on or off to force the output to match the provided labels from users. If the
        # value is True , the find matches transform forces the output to match the provided labels. The
        # results override the normal conflation results. If the value is False , the find matches transform
        # does not ensure all the labels provided are respected, and the results rely on the trained model.
        # Note that setting this value to true may increase the conflation execution time.

        @[JSON::Field(key: "EnforceProvidedLabels")]
        getter enforce_provided_labels : Bool?

        # The value selected when tuning your transform for a balance between precision and recall. A value of
        # 0.5 means no preference; a value of 1.0 means a bias purely for precision, and a value of 0.0 means
        # a bias for recall. Because this is a tradeoff, choosing values close to 1.0 means very low recall,
        # and choosing values close to 0.0 results in very low precision. The precision metric indicates how
        # often your model is correct when it predicts a match. The recall metric indicates that for an actual
        # match, how often your model predicts the match.

        @[JSON::Field(key: "PrecisionRecallTradeoff")]
        getter precision_recall_tradeoff : Float64?

        # The name of a column that uniquely identifies rows in the source table. Used to help identify
        # matching records.

        @[JSON::Field(key: "PrimaryKeyColumnName")]
        getter primary_key_column_name : String?

        def initialize(
          @accuracy_cost_tradeoff : Float64? = nil,
          @enforce_provided_labels : Bool? = nil,
          @precision_recall_tradeoff : Float64? = nil,
          @primary_key_column_name : String? = nil
        )
        end
      end

      # Specifies configuration properties for a Find Matches task run.

      struct FindMatchesTaskRunProperties
        include JSON::Serializable

        # The job ID for the Find Matches task run.

        @[JSON::Field(key: "JobId")]
        getter job_id : String?

        # The name assigned to the job for the Find Matches task run.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # The job run ID for the Find Matches task run.

        @[JSON::Field(key: "JobRunId")]
        getter job_run_id : String?

        def initialize(
          @job_id : String? = nil,
          @job_name : String? = nil,
          @job_run_id : String? = nil
        )
        end
      end


      struct GetBlueprintRequest
        include JSON::Serializable

        # The name of the blueprint.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Specifies whether or not to include the blueprint in the response.

        @[JSON::Field(key: "IncludeBlueprint")]
        getter include_blueprint : Bool?

        # Specifies whether or not to include the parameter specification.

        @[JSON::Field(key: "IncludeParameterSpec")]
        getter include_parameter_spec : Bool?

        def initialize(
          @name : String,
          @include_blueprint : Bool? = nil,
          @include_parameter_spec : Bool? = nil
        )
        end
      end


      struct GetBlueprintResponse
        include JSON::Serializable

        # Returns a Blueprint object.

        @[JSON::Field(key: "Blueprint")]
        getter blueprint : Types::Blueprint?

        def initialize(
          @blueprint : Types::Blueprint? = nil
        )
        end
      end


      struct GetBlueprintRunRequest
        include JSON::Serializable

        # The name of the blueprint.

        @[JSON::Field(key: "BlueprintName")]
        getter blueprint_name : String

        # The run ID for the blueprint run you want to retrieve.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        def initialize(
          @blueprint_name : String,
          @run_id : String
        )
        end
      end


      struct GetBlueprintRunResponse
        include JSON::Serializable

        # Returns a BlueprintRun object.

        @[JSON::Field(key: "BlueprintRun")]
        getter blueprint_run : Types::BlueprintRun?

        def initialize(
          @blueprint_run : Types::BlueprintRun? = nil
        )
        end
      end


      struct GetBlueprintRunsRequest
        include JSON::Serializable

        # The name of the blueprint.

        @[JSON::Field(key: "BlueprintName")]
        getter blueprint_name : String

        # The maximum size of a list to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation request.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @blueprint_name : String,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetBlueprintRunsResponse
        include JSON::Serializable

        # Returns a list of BlueprintRun objects.

        @[JSON::Field(key: "BlueprintRuns")]
        getter blueprint_runs : Array(Types::BlueprintRun)?

        # A continuation token, if not all blueprint runs have been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @blueprint_runs : Array(Types::BlueprintRun)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetCatalogImportStatusRequest
        include JSON::Serializable

        # The ID of the catalog to migrate. Currently, this should be the Amazon Web Services account ID.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @catalog_id : String? = nil
        )
        end
      end


      struct GetCatalogImportStatusResponse
        include JSON::Serializable

        # The status of the specified catalog migration.

        @[JSON::Field(key: "ImportStatus")]
        getter import_status : Types::CatalogImportStatus?

        def initialize(
          @import_status : Types::CatalogImportStatus? = nil
        )
        end
      end


      struct GetCatalogRequest
        include JSON::Serializable

        # The ID of the parent catalog in which the catalog resides. If none is provided, the Amazon Web
        # Services Account Number is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        def initialize(
          @catalog_id : String
        )
        end
      end


      struct GetCatalogResponse
        include JSON::Serializable

        # A Catalog object. The definition of the specified catalog in the Glue Data Catalog.

        @[JSON::Field(key: "Catalog")]
        getter catalog : Types::Catalog?

        def initialize(
          @catalog : Types::Catalog? = nil
        )
        end
      end


      struct GetCatalogsRequest
        include JSON::Serializable

        # Whether to list the default catalog in the account and region in the response. Defaults to false .
        # When true and ParentCatalogId = NULL | Amazon Web Services Account ID , all catalogs and the default
        # catalog are enumerated in the response. When the ParentCatalogId is not equal to null, and this
        # attribute is passed as false or true , an InvalidInputException is thrown.

        @[JSON::Field(key: "IncludeRoot")]
        getter include_root : Bool?

        # The maximum number of catalogs to return in one response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The ID of the parent catalog in which the catalog resides. If none is provided, the Amazon Web
        # Services Account Number is used by default.

        @[JSON::Field(key: "ParentCatalogId")]
        getter parent_catalog_id : String?

        # Whether to list all catalogs across the catalog hierarchy, starting from the ParentCatalogId .
        # Defaults to false . When true , all catalog objects in the ParentCatalogID hierarchy are enumerated
        # in the response.

        @[JSON::Field(key: "Recursive")]
        getter recursive : Bool?

        def initialize(
          @include_root : Bool? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @parent_catalog_id : String? = nil,
          @recursive : Bool? = nil
        )
        end
      end


      struct GetCatalogsResponse
        include JSON::Serializable

        # An array of Catalog objects. A list of Catalog objects from the specified parent catalog.

        @[JSON::Field(key: "CatalogList")]
        getter catalog_list : Array(Types::Catalog)

        # A continuation token for paginating the returned list of tokens, returned if the current segment of
        # the list is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @catalog_list : Array(Types::Catalog),
          @next_token : String? = nil
        )
        end
      end


      struct GetClassifierRequest
        include JSON::Serializable

        # Name of the classifier to retrieve.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct GetClassifierResponse
        include JSON::Serializable

        # The requested classifier.

        @[JSON::Field(key: "Classifier")]
        getter classifier : Types::Classifier?

        def initialize(
          @classifier : Types::Classifier? = nil
        )
        end
      end


      struct GetClassifiersRequest
        include JSON::Serializable

        # The size of the list to return (optional).

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # An optional continuation token.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetClassifiersResponse
        include JSON::Serializable

        # The requested list of classifier objects.

        @[JSON::Field(key: "Classifiers")]
        getter classifiers : Array(Types::Classifier)?

        # A continuation token.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @classifiers : Array(Types::Classifier)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetColumnStatisticsForPartitionRequest
        include JSON::Serializable

        # A list of the column names.

        @[JSON::Field(key: "ColumnNames")]
        getter column_names : Array(String)

        # The name of the catalog database where the partitions reside.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A list of partition values identifying the partition.

        @[JSON::Field(key: "PartitionValues")]
        getter partition_values : Array(String)

        # The name of the partitions' table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @column_names : Array(String),
          @database_name : String,
          @partition_values : Array(String),
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct GetColumnStatisticsForPartitionResponse
        include JSON::Serializable

        # List of ColumnStatistics that failed to be retrieved.

        @[JSON::Field(key: "ColumnStatisticsList")]
        getter column_statistics_list : Array(Types::ColumnStatistics)?

        # Error occurred during retrieving column statistics data.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::ColumnError)?

        def initialize(
          @column_statistics_list : Array(Types::ColumnStatistics)? = nil,
          @errors : Array(Types::ColumnError)? = nil
        )
        end
      end


      struct GetColumnStatisticsForTableRequest
        include JSON::Serializable

        # A list of the column names.

        @[JSON::Field(key: "ColumnNames")]
        getter column_names : Array(String)

        # The name of the catalog database where the partitions reside.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the partitions' table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @column_names : Array(String),
          @database_name : String,
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct GetColumnStatisticsForTableResponse
        include JSON::Serializable

        # List of ColumnStatistics.

        @[JSON::Field(key: "ColumnStatisticsList")]
        getter column_statistics_list : Array(Types::ColumnStatistics)?

        # List of ColumnStatistics that failed to be retrieved.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::ColumnError)?

        def initialize(
          @column_statistics_list : Array(Types::ColumnStatistics)? = nil,
          @errors : Array(Types::ColumnError)? = nil
        )
        end
      end


      struct GetColumnStatisticsTaskRunRequest
        include JSON::Serializable

        # The identifier for the particular column statistics task run.

        @[JSON::Field(key: "ColumnStatisticsTaskRunId")]
        getter column_statistics_task_run_id : String

        def initialize(
          @column_statistics_task_run_id : String
        )
        end
      end


      struct GetColumnStatisticsTaskRunResponse
        include JSON::Serializable

        # A ColumnStatisticsTaskRun object representing the details of the column stats run.

        @[JSON::Field(key: "ColumnStatisticsTaskRun")]
        getter column_statistics_task_run : Types::ColumnStatisticsTaskRun?

        def initialize(
          @column_statistics_task_run : Types::ColumnStatisticsTaskRun? = nil
        )
        end
      end


      struct GetColumnStatisticsTaskRunsRequest
        include JSON::Serializable

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The maximum size of the response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetColumnStatisticsTaskRunsResponse
        include JSON::Serializable

        # A list of column statistics task runs.

        @[JSON::Field(key: "ColumnStatisticsTaskRuns")]
        getter column_statistics_task_runs : Array(Types::ColumnStatisticsTaskRun)?

        # A continuation token, if not all task runs have yet been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @column_statistics_task_runs : Array(Types::ColumnStatisticsTaskRun)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetColumnStatisticsTaskSettingsRequest
        include JSON::Serializable

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table for which to retrieve column statistics.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        def initialize(
          @database_name : String,
          @table_name : String
        )
        end
      end


      struct GetColumnStatisticsTaskSettingsResponse
        include JSON::Serializable

        # A ColumnStatisticsTaskSettings object representing the settings for the column statistics task.

        @[JSON::Field(key: "ColumnStatisticsTaskSettings")]
        getter column_statistics_task_settings : Types::ColumnStatisticsTaskSettings?

        def initialize(
          @column_statistics_task_settings : Types::ColumnStatisticsTaskSettings? = nil
        )
        end
      end


      struct GetConnectionRequest
        include JSON::Serializable

        # The name of the connection definition to retrieve.

        @[JSON::Field(key: "Name")]
        getter name : String

        # For connections that may be used in multiple services, specifies returning properties for the
        # specified compute environment.

        @[JSON::Field(key: "ApplyOverrideForComputeEnvironment")]
        getter apply_override_for_compute_environment : String?

        # The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # Allows you to retrieve the connection metadata without returning the password. For instance, the
        # Glue console uses this flag to retrieve the connection, and does not display the password. Set this
        # parameter when the caller might not have permission to use the KMS key to decrypt the password, but
        # it does have permission to access the rest of the connection properties.

        @[JSON::Field(key: "HidePassword")]
        getter hide_password : Bool?

        def initialize(
          @name : String,
          @apply_override_for_compute_environment : String? = nil,
          @catalog_id : String? = nil,
          @hide_password : Bool? = nil
        )
        end
      end


      struct GetConnectionResponse
        include JSON::Serializable

        # The requested connection definition.

        @[JSON::Field(key: "Connection")]
        getter connection : Types::Connection?

        def initialize(
          @connection : Types::Connection? = nil
        )
        end
      end

      # Filters the connection definitions that are returned by the GetConnections API operation.

      struct GetConnectionsFilter
        include JSON::Serializable

        # Denotes if the connection was created with schema version 1 or 2.

        @[JSON::Field(key: "ConnectionSchemaVersion")]
        getter connection_schema_version : Int32?

        # The type of connections to return. Currently, SFTP is not supported.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String?

        # A criteria string that must match the criteria recorded in the connection definition for that
        # connection definition to be returned.

        @[JSON::Field(key: "MatchCriteria")]
        getter match_criteria : Array(String)?

        def initialize(
          @connection_schema_version : Int32? = nil,
          @connection_type : String? = nil,
          @match_criteria : Array(String)? = nil
        )
        end
      end


      struct GetConnectionsRequest
        include JSON::Serializable

        # The ID of the Data Catalog in which the connections reside. If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # A filter that controls which connections are returned.

        @[JSON::Field(key: "Filter")]
        getter filter : Types::GetConnectionsFilter?

        # Allows you to retrieve the connection metadata without returning the password. For instance, the
        # Glue console uses this flag to retrieve the connection, and does not display the password. Set this
        # parameter when the caller might not have permission to use the KMS key to decrypt the password, but
        # it does have permission to access the rest of the connection properties.

        @[JSON::Field(key: "HidePassword")]
        getter hide_password : Bool?

        # The maximum number of connections to return in one response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @catalog_id : String? = nil,
          @filter : Types::GetConnectionsFilter? = nil,
          @hide_password : Bool? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetConnectionsResponse
        include JSON::Serializable

        # A list of requested connection definitions.

        @[JSON::Field(key: "ConnectionList")]
        getter connection_list : Array(Types::Connection)?

        # A continuation token, if the list of connections returned does not include the last of the filtered
        # connections.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @connection_list : Array(Types::Connection)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetCrawlerMetricsRequest
        include JSON::Serializable

        # A list of the names of crawlers about which to retrieve metrics.

        @[JSON::Field(key: "CrawlerNameList")]
        getter crawler_name_list : Array(String)?

        # The maximum size of a list to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @crawler_name_list : Array(String)? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetCrawlerMetricsResponse
        include JSON::Serializable

        # A list of metrics for the specified crawler.

        @[JSON::Field(key: "CrawlerMetricsList")]
        getter crawler_metrics_list : Array(Types::CrawlerMetrics)?

        # A continuation token, if the returned list does not contain the last metric available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @crawler_metrics_list : Array(Types::CrawlerMetrics)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetCrawlerRequest
        include JSON::Serializable

        # The name of the crawler to retrieve metadata for.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct GetCrawlerResponse
        include JSON::Serializable

        # The metadata for the specified crawler.

        @[JSON::Field(key: "Crawler")]
        getter crawler : Types::Crawler?

        def initialize(
          @crawler : Types::Crawler? = nil
        )
        end
      end


      struct GetCrawlersRequest
        include JSON::Serializable

        # The number of crawlers to return on each call.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation request.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetCrawlersResponse
        include JSON::Serializable

        # A list of crawler metadata.

        @[JSON::Field(key: "Crawlers")]
        getter crawlers : Array(Types::Crawler)?

        # A continuation token, if the returned list has not reached the end of those defined in this customer
        # account.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @crawlers : Array(Types::Crawler)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetCustomEntityTypeRequest
        include JSON::Serializable

        # The name of the custom pattern that you want to retrieve.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct GetCustomEntityTypeResponse
        include JSON::Serializable

        # A list of context words if specified when you created the custom pattern. If none of these context
        # words are found within the vicinity of the regular expression the data will not be detected as
        # sensitive data.

        @[JSON::Field(key: "ContextWords")]
        getter context_words : Array(String)?

        # The name of the custom pattern that you retrieved.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # A regular expression string that is used for detecting sensitive data in a custom pattern.

        @[JSON::Field(key: "RegexString")]
        getter regex_string : String?

        def initialize(
          @context_words : Array(String)? = nil,
          @name : String? = nil,
          @regex_string : String? = nil
        )
        end
      end


      struct GetDataCatalogEncryptionSettingsRequest
        include JSON::Serializable

        # The ID of the Data Catalog to retrieve the security configuration for. If none is provided, the
        # Amazon Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @catalog_id : String? = nil
        )
        end
      end


      struct GetDataCatalogEncryptionSettingsResponse
        include JSON::Serializable

        # The requested security configuration.

        @[JSON::Field(key: "DataCatalogEncryptionSettings")]
        getter data_catalog_encryption_settings : Types::DataCatalogEncryptionSettings?

        def initialize(
          @data_catalog_encryption_settings : Types::DataCatalogEncryptionSettings? = nil
        )
        end
      end


      struct GetDataQualityModelRequest
        include JSON::Serializable

        # The Profile ID.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String

        # The Statistic ID.

        @[JSON::Field(key: "StatisticId")]
        getter statistic_id : String?

        def initialize(
          @profile_id : String,
          @statistic_id : String? = nil
        )
        end
      end


      struct GetDataQualityModelResponse
        include JSON::Serializable

        # The timestamp when the data quality model training completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # The training failure reason.

        @[JSON::Field(key: "FailureReason")]
        getter failure_reason : String?

        # The timestamp when the data quality model training started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # The training status of the data quality model.

        @[JSON::Field(key: "Status")]
        getter status : String?

        def initialize(
          @completed_on : Time? = nil,
          @failure_reason : String? = nil,
          @started_on : Time? = nil,
          @status : String? = nil
        )
        end
      end


      struct GetDataQualityModelResultRequest
        include JSON::Serializable

        # The Profile ID.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String

        # The Statistic ID.

        @[JSON::Field(key: "StatisticId")]
        getter statistic_id : String

        def initialize(
          @profile_id : String,
          @statistic_id : String
        )
        end
      end


      struct GetDataQualityModelResultResponse
        include JSON::Serializable

        # The timestamp when the data quality model training completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # A list of StatisticModelResult

        @[JSON::Field(key: "Model")]
        getter model : Array(Types::StatisticModelResult)?

        def initialize(
          @completed_on : Time? = nil,
          @model : Array(Types::StatisticModelResult)? = nil
        )
        end
      end


      struct GetDataQualityResultRequest
        include JSON::Serializable

        # A unique result ID for the data quality result.

        @[JSON::Field(key: "ResultId")]
        getter result_id : String

        def initialize(
          @result_id : String
        )
        end
      end

      # The response for the data quality result.

      struct GetDataQualityResultResponse
        include JSON::Serializable

        # A summary of DataQualityAggregatedMetrics objects showing the total counts of processed rows and
        # rules, including their pass/fail statistics based on row-level results.

        @[JSON::Field(key: "AggregatedMetrics")]
        getter aggregated_metrics : Types::DataQualityAggregatedMetrics?

        # A list of DataQualityAnalyzerResult objects representing the results for each analyzer.

        @[JSON::Field(key: "AnalyzerResults")]
        getter analyzer_results : Array(Types::DataQualityAnalyzerResult)?

        # The date and time when the run for this data quality result was completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # The table associated with the data quality result, if any.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource?

        # In the context of a job in Glue Studio, each node in the canvas is typically assigned some sort of
        # name and data quality nodes will have names. In the case of multiple nodes, the evaluationContext
        # can differentiate the nodes.

        @[JSON::Field(key: "EvaluationContext")]
        getter evaluation_context : String?

        # The job name associated with the data quality result, if any.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # The job run ID associated with the data quality result, if any.

        @[JSON::Field(key: "JobRunId")]
        getter job_run_id : String?

        # A list of DataQualityObservation objects representing the observations generated after evaluating
        # the rules and analyzers.

        @[JSON::Field(key: "Observations")]
        getter observations : Array(Types::DataQualityObservation)?

        # The Profile ID for the data quality result.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String?

        # A unique result ID for the data quality result.

        @[JSON::Field(key: "ResultId")]
        getter result_id : String?

        # A list of DataQualityRuleResult objects representing the results for each rule.

        @[JSON::Field(key: "RuleResults")]
        getter rule_results : Array(Types::DataQualityRuleResult)?

        # The unique run ID associated with the ruleset evaluation.

        @[JSON::Field(key: "RulesetEvaluationRunId")]
        getter ruleset_evaluation_run_id : String?

        # The name of the ruleset associated with the data quality result.

        @[JSON::Field(key: "RulesetName")]
        getter ruleset_name : String?

        # An aggregate data quality score. Represents the ratio of rules that passed to the total number of
        # rules.

        @[JSON::Field(key: "Score")]
        getter score : Float64?

        # The date and time when the run for this data quality result started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        def initialize(
          @aggregated_metrics : Types::DataQualityAggregatedMetrics? = nil,
          @analyzer_results : Array(Types::DataQualityAnalyzerResult)? = nil,
          @completed_on : Time? = nil,
          @data_source : Types::DataSource? = nil,
          @evaluation_context : String? = nil,
          @job_name : String? = nil,
          @job_run_id : String? = nil,
          @observations : Array(Types::DataQualityObservation)? = nil,
          @profile_id : String? = nil,
          @result_id : String? = nil,
          @rule_results : Array(Types::DataQualityRuleResult)? = nil,
          @ruleset_evaluation_run_id : String? = nil,
          @ruleset_name : String? = nil,
          @score : Float64? = nil,
          @started_on : Time? = nil
        )
        end
      end


      struct GetDataQualityRuleRecommendationRunRequest
        include JSON::Serializable

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        def initialize(
          @run_id : String
        )
        end
      end

      # The response for the Data Quality rule recommendation run.

      struct GetDataQualityRuleRecommendationRunResponse
        include JSON::Serializable

        # The date and time when this run was completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # The name of the ruleset that was created by the run.

        @[JSON::Field(key: "CreatedRulesetName")]
        getter created_ruleset_name : String?

        # The name of the security configuration created with the data quality encryption option.

        @[JSON::Field(key: "DataQualitySecurityConfiguration")]
        getter data_quality_security_configuration : String?

        # The data source (an Glue table) associated with this run.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource?

        # The error strings that are associated with the run.

        @[JSON::Field(key: "ErrorString")]
        getter error_string : String?

        # The amount of time (in seconds) that the run consumed resources.

        @[JSON::Field(key: "ExecutionTime")]
        getter execution_time : Int32?

        # A timestamp. The last point in time when this data quality rule recommendation run was modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The number of G.1X workers to be used in the run. The default is 5.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # When a start rule recommendation run completes, it creates a recommended ruleset (a set of rules).
        # This member has those rules in Data Quality Definition Language (DQDL) format.

        @[JSON::Field(key: "RecommendedRuleset")]
        getter recommended_ruleset : String?

        # An IAM role supplied to encrypt the results of the run.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        # The date and time when this run started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # The status for this run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The timeout for a run in minutes. This is the maximum time that a run can consume resources before
        # it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        def initialize(
          @completed_on : Time? = nil,
          @created_ruleset_name : String? = nil,
          @data_quality_security_configuration : String? = nil,
          @data_source : Types::DataSource? = nil,
          @error_string : String? = nil,
          @execution_time : Int32? = nil,
          @last_modified_on : Time? = nil,
          @number_of_workers : Int32? = nil,
          @recommended_ruleset : String? = nil,
          @role : String? = nil,
          @run_id : String? = nil,
          @started_on : Time? = nil,
          @status : String? = nil,
          @timeout : Int32? = nil
        )
        end
      end


      struct GetDataQualityRulesetEvaluationRunRequest
        include JSON::Serializable

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        def initialize(
          @run_id : String
        )
        end
      end


      struct GetDataQualityRulesetEvaluationRunResponse
        include JSON::Serializable

        # A map of reference strings to additional data sources you can specify for an evaluation run.

        @[JSON::Field(key: "AdditionalDataSources")]
        getter additional_data_sources : Hash(String, Types::DataSource)?

        # Additional run options you can specify for an evaluation run.

        @[JSON::Field(key: "AdditionalRunOptions")]
        getter additional_run_options : Types::DataQualityEvaluationRunAdditionalRunOptions?

        # The date and time when this run was completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # The data source (an Glue table) associated with this evaluation run.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource?

        # The error strings that are associated with the run.

        @[JSON::Field(key: "ErrorString")]
        getter error_string : String?

        # The amount of time (in seconds) that the run consumed resources.

        @[JSON::Field(key: "ExecutionTime")]
        getter execution_time : Int32?

        # A timestamp. The last point in time when this data quality rule recommendation run was modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The number of G.1X workers to be used in the run. The default is 5.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # A list of result IDs for the data quality results for the run.

        @[JSON::Field(key: "ResultIds")]
        getter result_ids : Array(String)?

        # An IAM role supplied to encrypt the results of the run.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # A list of ruleset names for the run. Currently, this parameter takes only one Ruleset name.

        @[JSON::Field(key: "RulesetNames")]
        getter ruleset_names : Array(String)?

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        # The date and time when this run started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # The status for this run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The timeout for a run in minutes. This is the maximum time that a run can consume resources before
        # it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        def initialize(
          @additional_data_sources : Hash(String, Types::DataSource)? = nil,
          @additional_run_options : Types::DataQualityEvaluationRunAdditionalRunOptions? = nil,
          @completed_on : Time? = nil,
          @data_source : Types::DataSource? = nil,
          @error_string : String? = nil,
          @execution_time : Int32? = nil,
          @last_modified_on : Time? = nil,
          @number_of_workers : Int32? = nil,
          @result_ids : Array(String)? = nil,
          @role : String? = nil,
          @ruleset_names : Array(String)? = nil,
          @run_id : String? = nil,
          @started_on : Time? = nil,
          @status : String? = nil,
          @timeout : Int32? = nil
        )
        end
      end


      struct GetDataQualityRulesetRequest
        include JSON::Serializable

        # The name of the ruleset.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end

      # Returns the data quality ruleset response.

      struct GetDataQualityRulesetResponse
        include JSON::Serializable

        # A timestamp. The time and date that this data quality ruleset was created.

        @[JSON::Field(key: "CreatedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_on : Time?

        # The name of the security configuration created with the data quality encryption option.

        @[JSON::Field(key: "DataQualitySecurityConfiguration")]
        getter data_quality_security_configuration : String?

        # A description of the ruleset.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A timestamp. The last point in time when this data quality ruleset was modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The name of the ruleset.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # When a ruleset was created from a recommendation run, this run ID is generated to link the two
        # together.

        @[JSON::Field(key: "RecommendationRunId")]
        getter recommendation_run_id : String?

        # A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer
        # guide.

        @[JSON::Field(key: "Ruleset")]
        getter ruleset : String?

        # The name and database name of the target table.

        @[JSON::Field(key: "TargetTable")]
        getter target_table : Types::DataQualityTargetTable?

        def initialize(
          @created_on : Time? = nil,
          @data_quality_security_configuration : String? = nil,
          @description : String? = nil,
          @last_modified_on : Time? = nil,
          @name : String? = nil,
          @recommendation_run_id : String? = nil,
          @ruleset : String? = nil,
          @target_table : Types::DataQualityTargetTable? = nil
        )
        end
      end


      struct GetDatabaseRequest
        include JSON::Serializable

        # The name of the database to retrieve. For Hive compatibility, this should be all lowercase.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the Data Catalog in which the database resides. If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct GetDatabaseResponse
        include JSON::Serializable

        # The definition of the specified database in the Data Catalog.

        @[JSON::Field(key: "Database")]
        getter database : Types::Database?

        def initialize(
          @database : Types::Database? = nil
        )
        end
      end


      struct GetDatabasesRequest
        include JSON::Serializable

        # Specifies the database fields returned by the GetDatabases call. This parameter doesnt accept an
        # empty list. The request must include the NAME .

        @[JSON::Field(key: "AttributesToGet")]
        getter attributes_to_get : Array(String)?

        # The ID of the Data Catalog from which to retrieve Databases . If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The maximum number of databases to return in one response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # Allows you to specify that you want to list the databases shared with your account. The allowable
        # values are FEDERATED , FOREIGN or ALL . If set to FEDERATED , will list the federated databases
        # (referencing an external entity) shared with your account. If set to FOREIGN , will list the
        # databases shared with your account. If set to ALL , will list the databases shared with your
        # account, as well as the databases in yor local account.

        @[JSON::Field(key: "ResourceShareType")]
        getter resource_share_type : String?

        def initialize(
          @attributes_to_get : Array(String)? = nil,
          @catalog_id : String? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @resource_share_type : String? = nil
        )
        end
      end


      struct GetDatabasesResponse
        include JSON::Serializable

        # A list of Database objects from the specified catalog.

        @[JSON::Field(key: "DatabaseList")]
        getter database_list : Array(Types::Database)

        # A continuation token for paginating the returned list of tokens, returned if the current segment of
        # the list is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @database_list : Array(Types::Database),
          @next_token : String? = nil
        )
        end
      end


      struct GetDataflowGraphRequest
        include JSON::Serializable

        # The Python script to transform.

        @[JSON::Field(key: "PythonScript")]
        getter python_script : String?

        def initialize(
          @python_script : String? = nil
        )
        end
      end


      struct GetDataflowGraphResponse
        include JSON::Serializable

        # A list of the edges in the resulting DAG.

        @[JSON::Field(key: "DagEdges")]
        getter dag_edges : Array(Types::CodeGenEdge)?

        # A list of the nodes in the resulting DAG.

        @[JSON::Field(key: "DagNodes")]
        getter dag_nodes : Array(Types::CodeGenNode)?

        def initialize(
          @dag_edges : Array(Types::CodeGenEdge)? = nil,
          @dag_nodes : Array(Types::CodeGenNode)? = nil
        )
        end
      end


      struct GetDevEndpointRequest
        include JSON::Serializable

        # Name of the DevEndpoint to retrieve information for.

        @[JSON::Field(key: "EndpointName")]
        getter endpoint_name : String

        def initialize(
          @endpoint_name : String
        )
        end
      end


      struct GetDevEndpointResponse
        include JSON::Serializable

        # A DevEndpoint definition.

        @[JSON::Field(key: "DevEndpoint")]
        getter dev_endpoint : Types::DevEndpoint?

        def initialize(
          @dev_endpoint : Types::DevEndpoint? = nil
        )
        end
      end


      struct GetDevEndpointsRequest
        include JSON::Serializable

        # The maximum size of information to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetDevEndpointsResponse
        include JSON::Serializable

        # A list of DevEndpoint definitions.

        @[JSON::Field(key: "DevEndpoints")]
        getter dev_endpoints : Array(Types::DevEndpoint)?

        # A continuation token, if not all DevEndpoint definitions have yet been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @dev_endpoints : Array(Types::DevEndpoint)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetEntityRecordsRequest
        include JSON::Serializable

        # Name of the entity that we want to query the preview data from the given connection type.

        @[JSON::Field(key: "EntityName")]
        getter entity_name : String

        # Limits the number of records fetched with the request.

        @[JSON::Field(key: "Limit")]
        getter limit : Int64

        # The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon
        # Web Services Account ID is the catalog ID.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The name of the connection that contains the connection type credentials.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # Connector options that are required to query the data.

        @[JSON::Field(key: "ConnectionOptions")]
        getter connection_options : Hash(String, String)?

        # The API version of the SaaS connector.

        @[JSON::Field(key: "DataStoreApiVersion")]
        getter data_store_api_version : String?

        # A filter predicate that you can apply in the query request.

        @[JSON::Field(key: "FilterPredicate")]
        getter filter_predicate : String?

        # A continuation token, included if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A parameter that orders the response preview data.

        @[JSON::Field(key: "OrderBy")]
        getter order_by : String?

        # List of fields that we want to fetch as part of preview data.

        @[JSON::Field(key: "SelectedFields")]
        getter selected_fields : Array(String)?

        def initialize(
          @entity_name : String,
          @limit : Int64,
          @catalog_id : String? = nil,
          @connection_name : String? = nil,
          @connection_options : Hash(String, String)? = nil,
          @data_store_api_version : String? = nil,
          @filter_predicate : String? = nil,
          @next_token : String? = nil,
          @order_by : String? = nil,
          @selected_fields : Array(String)? = nil
        )
        end
      end


      struct GetEntityRecordsResponse
        include JSON::Serializable

        # A continuation token, present if the current segment is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of the requested objects.

        @[JSON::Field(key: "Records")]
        getter records : Array(Types::Record)?

        def initialize(
          @next_token : String? = nil,
          @records : Array(Types::Record)? = nil
        )
        end
      end

      # Request to retrieve the Glue Identity Center configuration.

      struct GetGlueIdentityCenterConfigurationRequest
        include JSON::Serializable

        def initialize
        end
      end

      # Response containing the Glue Identity Center configuration details.

      struct GetGlueIdentityCenterConfigurationResponse
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the Identity Center application associated with the Glue
        # configuration.

        @[JSON::Field(key: "ApplicationArn")]
        getter application_arn : String?

        # The Amazon Resource Name (ARN) of the Identity Center instance associated with the Glue
        # configuration.

        @[JSON::Field(key: "InstanceArn")]
        getter instance_arn : String?

        # A list of Identity Center scopes that define the permissions and access levels for the Glue
        # configuration.

        @[JSON::Field(key: "Scopes")]
        getter scopes : Array(String)?

        # Indicates whether users can run background sessions when using Identity Center authentication with
        # Glue services.

        @[JSON::Field(key: "UserBackgroundSessionsEnabled")]
        getter user_background_sessions_enabled : Bool?

        def initialize(
          @application_arn : String? = nil,
          @instance_arn : String? = nil,
          @scopes : Array(String)? = nil,
          @user_background_sessions_enabled : Bool? = nil
        )
        end
      end


      struct GetIntegrationResourcePropertyRequest
        include JSON::Serializable

        # The connection ARN of the source, or the database ARN of the target.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        def initialize(
          @resource_arn : String
        )
        end
      end


      struct GetIntegrationResourcePropertyResponse
        include JSON::Serializable

        # The connection ARN of the source, or the database ARN of the target.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String?

        # The resource ARN created through this create API. The format is something like
        # arn:aws:glue:&lt;region&gt;:&lt;account_id&gt;:integrationresourceproperty/*

        @[JSON::Field(key: "ResourcePropertyArn")]
        getter resource_property_arn : String?

        # The resource properties associated with the integration source.

        @[JSON::Field(key: "SourceProcessingProperties")]
        getter source_processing_properties : Types::SourceProcessingProperties?

        # The resource properties associated with the integration target.

        @[JSON::Field(key: "TargetProcessingProperties")]
        getter target_processing_properties : Types::TargetProcessingProperties?

        def initialize(
          @resource_arn : String? = nil,
          @resource_property_arn : String? = nil,
          @source_processing_properties : Types::SourceProcessingProperties? = nil,
          @target_processing_properties : Types::TargetProcessingProperties? = nil
        )
        end
      end


      struct GetIntegrationTablePropertiesRequest
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the target table for which to retrieve integration table
        # properties. Currently, this API only supports retrieving properties for target tables, and the
        # provided ARN should be the ARN of the target table in the Glue Data Catalog. Support for retrieving
        # integration table properties for source connections (using the connection ARN) is not yet
        # implemented and will be added in a future release.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        # The name of the table to be replicated.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        def initialize(
          @resource_arn : String,
          @table_name : String
        )
        end
      end


      struct GetIntegrationTablePropertiesResponse
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the target table for which to retrieve integration table
        # properties. Currently, this API only supports retrieving properties for target tables, and the
        # provided ARN should be the ARN of the target table in the Glue Data Catalog. Support for retrieving
        # integration table properties for source connections (using the connection ARN) is not yet
        # implemented and will be added in a future release.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String?

        # A structure for the source table configuration.

        @[JSON::Field(key: "SourceTableConfig")]
        getter source_table_config : Types::SourceTableConfig?

        # The name of the table to be replicated.

        @[JSON::Field(key: "TableName")]
        getter table_name : String?

        # A structure for the target table configuration.

        @[JSON::Field(key: "TargetTableConfig")]
        getter target_table_config : Types::TargetTableConfig?

        def initialize(
          @resource_arn : String? = nil,
          @source_table_config : Types::SourceTableConfig? = nil,
          @table_name : String? = nil,
          @target_table_config : Types::TargetTableConfig? = nil
        )
        end
      end


      struct GetJobBookmarkRequest
        include JSON::Serializable

        # The name of the job in question.

        @[JSON::Field(key: "JobName")]
        getter job_name : String

        # The unique run identifier associated with this job run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        def initialize(
          @job_name : String,
          @run_id : String? = nil
        )
        end
      end


      struct GetJobBookmarkResponse
        include JSON::Serializable

        # A structure that defines a point that a job can resume processing.

        @[JSON::Field(key: "JobBookmarkEntry")]
        getter job_bookmark_entry : Types::JobBookmarkEntry?

        def initialize(
          @job_bookmark_entry : Types::JobBookmarkEntry? = nil
        )
        end
      end


      struct GetJobRequest
        include JSON::Serializable

        # The name of the job definition to retrieve.

        @[JSON::Field(key: "JobName")]
        getter job_name : String

        def initialize(
          @job_name : String
        )
        end
      end


      struct GetJobResponse
        include JSON::Serializable

        # The requested job definition.

        @[JSON::Field(key: "Job")]
        getter job : Types::Job?

        def initialize(
          @job : Types::Job? = nil
        )
        end
      end


      struct GetJobRunRequest
        include JSON::Serializable

        # Name of the job definition being run.

        @[JSON::Field(key: "JobName")]
        getter job_name : String

        # The ID of the job run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        # True if a list of predecessor runs should be returned.

        @[JSON::Field(key: "PredecessorsIncluded")]
        getter predecessors_included : Bool?

        def initialize(
          @job_name : String,
          @run_id : String,
          @predecessors_included : Bool? = nil
        )
        end
      end


      struct GetJobRunResponse
        include JSON::Serializable

        # The requested job-run metadata.

        @[JSON::Field(key: "JobRun")]
        getter job_run : Types::JobRun?

        def initialize(
          @job_run : Types::JobRun? = nil
        )
        end
      end


      struct GetJobRunsRequest
        include JSON::Serializable

        # The name of the job definition for which to retrieve all job runs.

        @[JSON::Field(key: "JobName")]
        getter job_name : String

        # The maximum size of the response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @job_name : String,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetJobRunsResponse
        include JSON::Serializable

        # A list of job-run metadata objects.

        @[JSON::Field(key: "JobRuns")]
        getter job_runs : Array(Types::JobRun)?

        # A continuation token, if not all requested job runs have been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @job_runs : Array(Types::JobRun)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetJobsRequest
        include JSON::Serializable

        # The maximum size of the response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetJobsResponse
        include JSON::Serializable

        # A list of job definitions.

        @[JSON::Field(key: "Jobs")]
        getter jobs : Array(Types::Job)?

        # A continuation token, if not all job definitions have yet been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @jobs : Array(Types::Job)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetMLTaskRunRequest
        include JSON::Serializable

        # The unique identifier of the task run.

        @[JSON::Field(key: "TaskRunId")]
        getter task_run_id : String

        # The unique identifier of the machine learning transform.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String

        def initialize(
          @task_run_id : String,
          @transform_id : String
        )
        end
      end


      struct GetMLTaskRunResponse
        include JSON::Serializable

        # The date and time when this task run was completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # The error strings that are associated with the task run.

        @[JSON::Field(key: "ErrorString")]
        getter error_string : String?

        # The amount of time (in seconds) that the task run consumed resources.

        @[JSON::Field(key: "ExecutionTime")]
        getter execution_time : Int32?

        # The date and time when this task run was last modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The names of the log groups that are associated with the task run.

        @[JSON::Field(key: "LogGroupName")]
        getter log_group_name : String?

        # The list of properties that are associated with the task run.

        @[JSON::Field(key: "Properties")]
        getter properties : Types::TaskRunProperties?

        # The date and time when this task run started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # The status for this task run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "TaskRunId")]
        getter task_run_id : String?

        # The unique identifier of the task run.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String?

        def initialize(
          @completed_on : Time? = nil,
          @error_string : String? = nil,
          @execution_time : Int32? = nil,
          @last_modified_on : Time? = nil,
          @log_group_name : String? = nil,
          @properties : Types::TaskRunProperties? = nil,
          @started_on : Time? = nil,
          @status : String? = nil,
          @task_run_id : String? = nil,
          @transform_id : String? = nil
        )
        end
      end


      struct GetMLTaskRunsRequest
        include JSON::Serializable

        # The unique identifier of the machine learning transform.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String

        # The filter criteria, in the TaskRunFilterCriteria structure, for the task run.

        @[JSON::Field(key: "Filter")]
        getter filter : Types::TaskRunFilterCriteria?

        # The maximum number of results to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A token for pagination of the results. The default is empty.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The sorting criteria, in the TaskRunSortCriteria structure, for the task run.

        @[JSON::Field(key: "Sort")]
        getter sort : Types::TaskRunSortCriteria?

        def initialize(
          @transform_id : String,
          @filter : Types::TaskRunFilterCriteria? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @sort : Types::TaskRunSortCriteria? = nil
        )
        end
      end


      struct GetMLTaskRunsResponse
        include JSON::Serializable

        # A pagination token, if more results are available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of task runs that are associated with the transform.

        @[JSON::Field(key: "TaskRuns")]
        getter task_runs : Array(Types::TaskRun)?

        def initialize(
          @next_token : String? = nil,
          @task_runs : Array(Types::TaskRun)? = nil
        )
        end
      end


      struct GetMLTransformRequest
        include JSON::Serializable

        # The unique identifier of the transform, generated at the time that the transform was created.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String

        def initialize(
          @transform_id : String
        )
        end
      end


      struct GetMLTransformResponse
        include JSON::Serializable

        # The date and time when the transform was created.

        @[JSON::Field(key: "CreatedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_on : Time?

        # A description of the transform.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The latest evaluation metrics.

        @[JSON::Field(key: "EvaluationMetrics")]
        getter evaluation_metrics : Types::EvaluationMetrics?

        # This value determines which version of Glue this machine learning transform is compatible with. Glue
        # 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to
        # Glue 0.9. For more information, see Glue Versions in the developer guide.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # A list of Glue table definitions used by the transform.

        @[JSON::Field(key: "InputRecordTables")]
        getter input_record_tables : Array(Types::GlueTable)?

        # The number of labels available for this transform.

        @[JSON::Field(key: "LabelCount")]
        getter label_count : Int32?

        # The date and time when the transform was last modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The number of Glue data processing units (DPUs) that are allocated to task runs for this transform.
        # You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing
        # power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see
        # the Glue pricing page . When the WorkerType field is set to a value other than Standard , the
        # MaxCapacity field is set automatically and becomes read-only.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # The maximum number of times to retry a task for this transform after a task run fails.

        @[JSON::Field(key: "MaxRetries")]
        getter max_retries : Int32?

        # The unique name given to the transform when it was created.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # The number of workers of a defined workerType that are allocated when this task runs.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The configuration parameters that are specific to the algorithm used.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Types::TransformParameters?

        # The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # The Map&lt;Column, Type&gt; object that represents the schema that this transform accepts. Has an
        # upper bound of 100 columns.

        @[JSON::Field(key: "Schema")]
        getter schema : Array(Types::SchemaColumn)?

        # The last known status of the transform (to indicate whether it can be used or not). One of
        # "NOT_READY", "READY", or "DELETING".

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The timeout for a task run for this transform in minutes. This is the maximum time that a task run
        # for this transform can consume resources before it is terminated and enters TIMEOUT status. The
        # default is 2,880 minutes (48 hours).

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        # The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning
        # transforms can access user data encrypted in Amazon S3 using KMS.

        @[JSON::Field(key: "TransformEncryption")]
        getter transform_encryption : Types::TransformEncryption?

        # The unique identifier of the transform, generated at the time that the transform was created.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String?

        # The type of predefined worker that is allocated when this task runs. Accepts a value of Standard,
        # G.1X, or G.2X. For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB
        # disk, and 2 executors per worker. For the G.1X worker type, each worker provides 4 vCPU, 16 GB of
        # memory and a 64GB disk, and 1 executor per worker. For the G.2X worker type, each worker provides 8
        # vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @created_on : Time? = nil,
          @description : String? = nil,
          @evaluation_metrics : Types::EvaluationMetrics? = nil,
          @glue_version : String? = nil,
          @input_record_tables : Array(Types::GlueTable)? = nil,
          @label_count : Int32? = nil,
          @last_modified_on : Time? = nil,
          @max_capacity : Float64? = nil,
          @max_retries : Int32? = nil,
          @name : String? = nil,
          @number_of_workers : Int32? = nil,
          @parameters : Types::TransformParameters? = nil,
          @role : String? = nil,
          @schema : Array(Types::SchemaColumn)? = nil,
          @status : String? = nil,
          @timeout : Int32? = nil,
          @transform_encryption : Types::TransformEncryption? = nil,
          @transform_id : String? = nil,
          @worker_type : String? = nil
        )
        end
      end


      struct GetMLTransformsRequest
        include JSON::Serializable

        # The filter transformation criteria.

        @[JSON::Field(key: "Filter")]
        getter filter : Types::TransformFilterCriteria?

        # The maximum number of results to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A paginated token to offset the results.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The sorting criteria.

        @[JSON::Field(key: "Sort")]
        getter sort : Types::TransformSortCriteria?

        def initialize(
          @filter : Types::TransformFilterCriteria? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @sort : Types::TransformSortCriteria? = nil
        )
        end
      end


      struct GetMLTransformsResponse
        include JSON::Serializable

        # A list of machine learning transforms.

        @[JSON::Field(key: "Transforms")]
        getter transforms : Array(Types::MLTransform)

        # A pagination token, if more results are available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @transforms : Array(Types::MLTransform),
          @next_token : String? = nil
        )
        end
      end


      struct GetMappingRequest
        include JSON::Serializable

        # Specifies the source table.

        @[JSON::Field(key: "Source")]
        getter source : Types::CatalogEntry

        # Parameters for the mapping.

        @[JSON::Field(key: "Location")]
        getter location : Types::Location?

        # A list of target tables.

        @[JSON::Field(key: "Sinks")]
        getter sinks : Array(Types::CatalogEntry)?

        def initialize(
          @source : Types::CatalogEntry,
          @location : Types::Location? = nil,
          @sinks : Array(Types::CatalogEntry)? = nil
        )
        end
      end


      struct GetMappingResponse
        include JSON::Serializable

        # A list of mappings to the specified targets.

        @[JSON::Field(key: "Mapping")]
        getter mapping : Array(Types::MappingEntry)

        def initialize(
          @mapping : Array(Types::MappingEntry)
        )
        end
      end


      struct GetMaterializedViewRefreshTaskRunRequest
        include JSON::Serializable

        # The ID of the Data Catalog where the table resides. If none is supplied, the account ID is used by
        # default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # The identifier for the particular materialized view refresh task run.

        @[JSON::Field(key: "MaterializedViewRefreshTaskRunId")]
        getter materialized_view_refresh_task_run_id : String

        def initialize(
          @catalog_id : String,
          @materialized_view_refresh_task_run_id : String
        )
        end
      end


      struct GetMaterializedViewRefreshTaskRunResponse
        include JSON::Serializable

        # A MaterializedViewRefreshTaskRun object representing the details of the task run.

        @[JSON::Field(key: "MaterializedViewRefreshTaskRun")]
        getter materialized_view_refresh_task_run : Types::MaterializedViewRefreshTaskRun?

        def initialize(
          @materialized_view_refresh_task_run : Types::MaterializedViewRefreshTaskRun? = nil
        )
        end
      end


      struct GetPartitionIndexesRequest
        include JSON::Serializable

        # Specifies the name of a database from which you want to retrieve partition indexes.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # Specifies the name of a table for which you want to retrieve the partition indexes.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The catalog ID where the table resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # A continuation token, included if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @catalog_id : String? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetPartitionIndexesResponse
        include JSON::Serializable

        # A continuation token, present if the current list segment is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of index descriptors.

        @[JSON::Field(key: "PartitionIndexDescriptorList")]
        getter partition_index_descriptor_list : Array(Types::PartitionIndexDescriptor)?

        def initialize(
          @next_token : String? = nil,
          @partition_index_descriptor_list : Array(Types::PartitionIndexDescriptor)? = nil
        )
        end
      end


      struct GetPartitionRequest
        include JSON::Serializable

        # The name of the catalog database where the partition resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The values that define the partition.

        @[JSON::Field(key: "PartitionValues")]
        getter partition_values : Array(String)

        # The name of the partition's table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partition in question resides. If none is provided, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @partition_values : Array(String),
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct GetPartitionResponse
        include JSON::Serializable

        # The requested information, in the form of a Partition object.

        @[JSON::Field(key: "Partition")]
        getter partition : Types::Partition?

        def initialize(
          @partition : Types::Partition? = nil
        )
        end
      end


      struct GetPartitionsRequest
        include JSON::Serializable

        # The name of the catalog database where the partitions reside.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the partitions' table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partitions in question reside. If none is provided, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # When true, specifies not returning the partition column schema. Useful when you are interested only
        # in other partition attributes such as partition values or location. This approach avoids the problem
        # of a large response by not returning duplicate data.

        @[JSON::Field(key: "ExcludeColumnSchema")]
        getter exclude_column_schema : Bool?

        # An expression that filters the partitions to be returned. The expression uses SQL syntax similar to
        # the SQL WHERE filter clause. The SQL statement parser JSQLParser parses the expression. Operators :
        # The following are the operators that you can use in the Expression API call: = Checks whether the
        # values of the two operands are equal; if yes, then the condition becomes true. Example: Assume
        # 'variable a' holds 10 and 'variable b' holds 20. (a = b) is not true. &lt; &gt; Checks whether the
        # values of two operands are equal; if the values are not equal, then the condition becomes true.
        # Example: (a &lt; &gt; b) is true. &gt; Checks whether the value of the left operand is greater than
        # the value of the right operand; if yes, then the condition becomes true. Example: (a &gt; b) is not
        # true. &lt; Checks whether the value of the left operand is less than the value of the right operand;
        # if yes, then the condition becomes true. Example: (a &lt; b) is true. &gt;= Checks whether the value
        # of the left operand is greater than or equal to the value of the right operand; if yes, then the
        # condition becomes true. Example: (a &gt;= b) is not true. &lt;= Checks whether the value of the left
        # operand is less than or equal to the value of the right operand; if yes, then the condition becomes
        # true. Example: (a &lt;= b) is true. AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL Logical operators.
        # Supported Partition Key Types : The following are the supported partition keys. string date
        # timestamp int bigint long tinyint smallint decimal If an type is encountered that is not valid, an
        # exception is thrown. The following list shows the valid operators on each type. When you define a
        # crawler, the partitionKey type is created as a STRING , to be compatible with the catalog
        # partitions. Sample API Call :

        @[JSON::Field(key: "Expression")]
        getter expression : String?

        # The maximum number of partitions to return in a single response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is not the first call to retrieve these partitions.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The time as of when to read the partition contents. If not set, the most recent transaction commit
        # time will be used. Cannot be specified along with TransactionId .

        @[JSON::Field(key: "QueryAsOfTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter query_as_of_time : Time?

        # The segment of the table's partitions to scan in this request.

        @[JSON::Field(key: "Segment")]
        getter segment : Types::Segment?

        # The transaction ID at which to read the partition contents.

        @[JSON::Field(key: "TransactionId")]
        getter transaction_id : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @catalog_id : String? = nil,
          @exclude_column_schema : Bool? = nil,
          @expression : String? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @query_as_of_time : Time? = nil,
          @segment : Types::Segment? = nil,
          @transaction_id : String? = nil
        )
        end
      end


      struct GetPartitionsResponse
        include JSON::Serializable

        # A continuation token, if the returned list of partitions does not include the last one.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of requested partitions.

        @[JSON::Field(key: "Partitions")]
        getter partitions : Array(Types::Partition)?

        def initialize(
          @next_token : String? = nil,
          @partitions : Array(Types::Partition)? = nil
        )
        end
      end


      struct GetPlanRequest
        include JSON::Serializable

        # The list of mappings from a source table to target tables.

        @[JSON::Field(key: "Mapping")]
        getter mapping : Array(Types::MappingEntry)

        # The source table.

        @[JSON::Field(key: "Source")]
        getter source : Types::CatalogEntry

        # A map to hold additional optional key-value parameters. Currently, these key-value pairs are
        # supported: inferSchema  Specifies whether to set inferSchema to true or false for the default
        # script generated by an Glue job. For example, to set inferSchema to true, pass the following key
        # value pair: --additional-plan-options-map '{"inferSchema":"true"}'

        @[JSON::Field(key: "AdditionalPlanOptionsMap")]
        getter additional_plan_options_map : Hash(String, String)?

        # The programming language of the code to perform the mapping.

        @[JSON::Field(key: "Language")]
        getter language : String?

        # The parameters for the mapping.

        @[JSON::Field(key: "Location")]
        getter location : Types::Location?

        # The target tables.

        @[JSON::Field(key: "Sinks")]
        getter sinks : Array(Types::CatalogEntry)?

        def initialize(
          @mapping : Array(Types::MappingEntry),
          @source : Types::CatalogEntry,
          @additional_plan_options_map : Hash(String, String)? = nil,
          @language : String? = nil,
          @location : Types::Location? = nil,
          @sinks : Array(Types::CatalogEntry)? = nil
        )
        end
      end


      struct GetPlanResponse
        include JSON::Serializable

        # A Python script to perform the mapping.

        @[JSON::Field(key: "PythonScript")]
        getter python_script : String?

        # The Scala code to perform the mapping.

        @[JSON::Field(key: "ScalaCode")]
        getter scala_code : String?

        def initialize(
          @python_script : String? = nil,
          @scala_code : String? = nil
        )
        end
      end


      struct GetRegistryInput
        include JSON::Serializable

        # This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).

        @[JSON::Field(key: "RegistryId")]
        getter registry_id : Types::RegistryId

        def initialize(
          @registry_id : Types::RegistryId
        )
        end
      end


      struct GetRegistryResponse
        include JSON::Serializable

        # The date and time the registry was created.

        @[JSON::Field(key: "CreatedTime")]
        getter created_time : String?

        # A description of the registry.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The Amazon Resource Name (ARN) of the registry.

        @[JSON::Field(key: "RegistryArn")]
        getter registry_arn : String?

        # The name of the registry.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The status of the registry.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The date and time the registry was updated.

        @[JSON::Field(key: "UpdatedTime")]
        getter updated_time : String?

        def initialize(
          @created_time : String? = nil,
          @description : String? = nil,
          @registry_arn : String? = nil,
          @registry_name : String? = nil,
          @status : String? = nil,
          @updated_time : String? = nil
        )
        end
      end


      struct GetResourcePoliciesRequest
        include JSON::Serializable

        # The maximum size of a list to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation request.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetResourcePoliciesResponse
        include JSON::Serializable

        # A list of the individual resource policies and the account-level resource policy.

        @[JSON::Field(key: "GetResourcePoliciesResponseList")]
        getter get_resource_policies_response_list : Array(Types::GluePolicy)?

        # A continuation token, if the returned list does not contain the last resource policy available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @get_resource_policies_response_list : Array(Types::GluePolicy)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetResourcePolicyRequest
        include JSON::Serializable

        # The ARN of the Glue resource for which to retrieve the resource policy. If not supplied, the Data
        # Catalog resource policy is returned. Use GetResourcePolicies to view all existing resource policies.
        # For more information see Specifying Glue Resource ARNs .

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String?

        def initialize(
          @resource_arn : String? = nil
        )
        end
      end


      struct GetResourcePolicyResponse
        include JSON::Serializable

        # The date and time at which the policy was created.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time?

        # Contains the hash value associated with this policy.

        @[JSON::Field(key: "PolicyHash")]
        getter policy_hash : String?

        # Contains the requested policy document, in JSON format.

        @[JSON::Field(key: "PolicyInJson")]
        getter policy_in_json : String?

        # The date and time at which the policy was last updated.

        @[JSON::Field(key: "UpdateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter update_time : Time?

        def initialize(
          @create_time : Time? = nil,
          @policy_hash : String? = nil,
          @policy_in_json : String? = nil,
          @update_time : Time? = nil
        )
        end
      end


      struct GetSchemaByDefinitionInput
        include JSON::Serializable

        # The definition of the schema for which schema details are required.

        @[JSON::Field(key: "SchemaDefinition")]
        getter schema_definition : String

        # This is a wrapper structure to contain schema identity fields. The structure contains:
        # SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has
        # to be provided. SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to
        # be provided.

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId

        def initialize(
          @schema_definition : String,
          @schema_id : Types::SchemaId
        )
        end
      end


      struct GetSchemaByDefinitionResponse
        include JSON::Serializable

        # The date and time the schema was created.

        @[JSON::Field(key: "CreatedTime")]
        getter created_time : String?

        # The data format of the schema definition. Currently AVRO , JSON and PROTOBUF are supported.

        @[JSON::Field(key: "DataFormat")]
        getter data_format : String?

        # The Amazon Resource Name (ARN) of the schema.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The schema ID of the schema version.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The status of the schema version.

        @[JSON::Field(key: "Status")]
        getter status : String?

        def initialize(
          @created_time : String? = nil,
          @data_format : String? = nil,
          @schema_arn : String? = nil,
          @schema_version_id : String? = nil,
          @status : String? = nil
        )
        end
      end


      struct GetSchemaInput
        include JSON::Serializable

        # This is a wrapper structure to contain schema identity fields. The structure contains:
        # SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and
        # RegistryName has to be provided. SchemaId$SchemaName: The name of the schema. Either SchemaArn or
        # SchemaName and RegistryName has to be provided.

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId

        def initialize(
          @schema_id : Types::SchemaId
        )
        end
      end


      struct GetSchemaResponse
        include JSON::Serializable

        # The compatibility mode of the schema.

        @[JSON::Field(key: "Compatibility")]
        getter compatibility : String?

        # The date and time the schema was created.

        @[JSON::Field(key: "CreatedTime")]
        getter created_time : String?

        # The data format of the schema definition. Currently AVRO , JSON and PROTOBUF are supported.

        @[JSON::Field(key: "DataFormat")]
        getter data_format : String?

        # A description of schema if specified when created

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The latest version of the schema associated with the returned schema definition.

        @[JSON::Field(key: "LatestSchemaVersion")]
        getter latest_schema_version : Int64?

        # The next version of the schema associated with the returned schema definition.

        @[JSON::Field(key: "NextSchemaVersion")]
        getter next_schema_version : Int64?

        # The Amazon Resource Name (ARN) of the registry.

        @[JSON::Field(key: "RegistryArn")]
        getter registry_arn : String?

        # The name of the registry.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The Amazon Resource Name (ARN) of the schema.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The version number of the checkpoint (the last time the compatibility mode was changed).

        @[JSON::Field(key: "SchemaCheckpoint")]
        getter schema_checkpoint : Int64?

        # The name of the schema.

        @[JSON::Field(key: "SchemaName")]
        getter schema_name : String?

        # The status of the schema.

        @[JSON::Field(key: "SchemaStatus")]
        getter schema_status : String?

        # The date and time the schema was updated.

        @[JSON::Field(key: "UpdatedTime")]
        getter updated_time : String?

        def initialize(
          @compatibility : String? = nil,
          @created_time : String? = nil,
          @data_format : String? = nil,
          @description : String? = nil,
          @latest_schema_version : Int64? = nil,
          @next_schema_version : Int64? = nil,
          @registry_arn : String? = nil,
          @registry_name : String? = nil,
          @schema_arn : String? = nil,
          @schema_checkpoint : Int64? = nil,
          @schema_name : String? = nil,
          @schema_status : String? = nil,
          @updated_time : String? = nil
        )
        end
      end


      struct GetSchemaVersionInput
        include JSON::Serializable

        # This is a wrapper structure to contain schema identity fields. The structure contains:
        # SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and
        # RegistryName has to be provided. SchemaId$SchemaName: The name of the schema. Either SchemaArn or
        # SchemaName and RegistryName has to be provided.

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId?

        # The SchemaVersionId of the schema version. This field is required for fetching by schema ID. Either
        # this or the SchemaId wrapper has to be provided.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The version number of the schema.

        @[JSON::Field(key: "SchemaVersionNumber")]
        getter schema_version_number : Types::SchemaVersionNumber?

        def initialize(
          @schema_id : Types::SchemaId? = nil,
          @schema_version_id : String? = nil,
          @schema_version_number : Types::SchemaVersionNumber? = nil
        )
        end
      end


      struct GetSchemaVersionResponse
        include JSON::Serializable

        # The date and time the schema version was created.

        @[JSON::Field(key: "CreatedTime")]
        getter created_time : String?

        # The data format of the schema definition. Currently AVRO , JSON and PROTOBUF are supported.

        @[JSON::Field(key: "DataFormat")]
        getter data_format : String?

        # The Amazon Resource Name (ARN) of the schema.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The schema definition for the schema ID.

        @[JSON::Field(key: "SchemaDefinition")]
        getter schema_definition : String?

        # The SchemaVersionId of the schema version.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The status of the schema version.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The version number of the schema.

        @[JSON::Field(key: "VersionNumber")]
        getter version_number : Int64?

        def initialize(
          @created_time : String? = nil,
          @data_format : String? = nil,
          @schema_arn : String? = nil,
          @schema_definition : String? = nil,
          @schema_version_id : String? = nil,
          @status : String? = nil,
          @version_number : Int64? = nil
        )
        end
      end


      struct GetSchemaVersionsDiffInput
        include JSON::Serializable

        # The first of the two schema versions to be compared.

        @[JSON::Field(key: "FirstSchemaVersionNumber")]
        getter first_schema_version_number : Types::SchemaVersionNumber

        # Refers to SYNTAX_DIFF , which is the currently supported diff type.

        @[JSON::Field(key: "SchemaDiffType")]
        getter schema_diff_type : String

        # This is a wrapper structure to contain schema identity fields. The structure contains:
        # SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has
        # to be provided. SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to
        # be provided.

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId

        # The second of the two schema versions to be compared.

        @[JSON::Field(key: "SecondSchemaVersionNumber")]
        getter second_schema_version_number : Types::SchemaVersionNumber

        def initialize(
          @first_schema_version_number : Types::SchemaVersionNumber,
          @schema_diff_type : String,
          @schema_id : Types::SchemaId,
          @second_schema_version_number : Types::SchemaVersionNumber
        )
        end
      end


      struct GetSchemaVersionsDiffResponse
        include JSON::Serializable

        # The difference between schemas as a string in JsonPatch format.

        @[JSON::Field(key: "Diff")]
        getter diff : String?

        def initialize(
          @diff : String? = nil
        )
        end
      end


      struct GetSecurityConfigurationRequest
        include JSON::Serializable

        # The name of the security configuration to retrieve.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct GetSecurityConfigurationResponse
        include JSON::Serializable

        # The requested security configuration.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : Types::SecurityConfiguration?

        def initialize(
          @security_configuration : Types::SecurityConfiguration? = nil
        )
        end
      end


      struct GetSecurityConfigurationsRequest
        include JSON::Serializable

        # The maximum number of results to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetSecurityConfigurationsResponse
        include JSON::Serializable

        # A continuation token, if there are more security configurations to return.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of security configurations.

        @[JSON::Field(key: "SecurityConfigurations")]
        getter security_configurations : Array(Types::SecurityConfiguration)?

        def initialize(
          @next_token : String? = nil,
          @security_configurations : Array(Types::SecurityConfiguration)? = nil
        )
        end
      end


      struct GetSessionRequest
        include JSON::Serializable

        # The ID of the session.

        @[JSON::Field(key: "Id")]
        getter id : String

        # The origin of the request.

        @[JSON::Field(key: "RequestOrigin")]
        getter request_origin : String?

        def initialize(
          @id : String,
          @request_origin : String? = nil
        )
        end
      end


      struct GetSessionResponse
        include JSON::Serializable

        # The session object is returned in the response.

        @[JSON::Field(key: "Session")]
        getter session : Types::Session?

        def initialize(
          @session : Types::Session? = nil
        )
        end
      end


      struct GetStatementRequest
        include JSON::Serializable

        # The Id of the statement.

        @[JSON::Field(key: "Id")]
        getter id : Int32

        # The Session ID of the statement.

        @[JSON::Field(key: "SessionId")]
        getter session_id : String

        # The origin of the request.

        @[JSON::Field(key: "RequestOrigin")]
        getter request_origin : String?

        def initialize(
          @id : Int32,
          @session_id : String,
          @request_origin : String? = nil
        )
        end
      end


      struct GetStatementResponse
        include JSON::Serializable

        # Returns the statement.

        @[JSON::Field(key: "Statement")]
        getter statement : Types::Statement?

        def initialize(
          @statement : Types::Statement? = nil
        )
        end
      end


      struct GetTableOptimizerRequest
        include JSON::Serializable

        # The Catalog ID of the table.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # The name of the database in the catalog in which the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The type of table optimizer.

        @[JSON::Field(key: "Type")]
        getter type : String

        def initialize(
          @catalog_id : String,
          @database_name : String,
          @table_name : String,
          @type : String
        )
        end
      end


      struct GetTableOptimizerResponse
        include JSON::Serializable

        # The Catalog ID of the table.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The name of the database in the catalog in which the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # The name of the table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String?

        # The optimizer associated with the specified table.

        @[JSON::Field(key: "TableOptimizer")]
        getter table_optimizer : Types::TableOptimizer?

        def initialize(
          @catalog_id : String? = nil,
          @database_name : String? = nil,
          @table_name : String? = nil,
          @table_optimizer : Types::TableOptimizer? = nil
        )
        end
      end


      struct GetTableRequest
        include JSON::Serializable

        # The name of the database in the catalog in which the table resides. For Hive compatibility, this
        # name is entirely lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table for which to retrieve the definition. For Hive compatibility, this name is
        # entirely lowercase.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A structure containing the Lake Formation audit context .

        @[JSON::Field(key: "AuditContext")]
        getter audit_context : Types::AuditContext?

        # The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # Specifies whether to include status details related to a request to create or update an Glue Data
        # Catalog view.

        @[JSON::Field(key: "IncludeStatusDetails")]
        getter include_status_details : Bool?

        # The time as of when to read the table contents. If not set, the most recent transaction commit time
        # will be used. Cannot be specified along with TransactionId .

        @[JSON::Field(key: "QueryAsOfTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter query_as_of_time : Time?

        # The transaction ID at which to read the table contents.

        @[JSON::Field(key: "TransactionId")]
        getter transaction_id : String?

        def initialize(
          @database_name : String,
          @name : String,
          @audit_context : Types::AuditContext? = nil,
          @catalog_id : String? = nil,
          @include_status_details : Bool? = nil,
          @query_as_of_time : Time? = nil,
          @transaction_id : String? = nil
        )
        end
      end


      struct GetTableResponse
        include JSON::Serializable

        # The Table object that defines the specified table.

        @[JSON::Field(key: "Table")]
        getter table : Types::Table?

        def initialize(
          @table : Types::Table? = nil
        )
        end
      end


      struct GetTableVersionRequest
        include JSON::Serializable

        # The database in the catalog in which the table resides. For Hive compatibility, this name is
        # entirely lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table. For Hive compatibility, this name is entirely lowercase.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The ID value of the table version to be retrieved. A VersionID is a string representation of an
        # integer. Each version is incremented by 1.

        @[JSON::Field(key: "VersionId")]
        getter version_id : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @catalog_id : String? = nil,
          @version_id : String? = nil
        )
        end
      end


      struct GetTableVersionResponse
        include JSON::Serializable

        # The requested table version.

        @[JSON::Field(key: "TableVersion")]
        getter table_version : Types::TableVersion?

        def initialize(
          @table_version : Types::TableVersion? = nil
        )
        end
      end


      struct GetTableVersionsRequest
        include JSON::Serializable

        # The database in the catalog in which the table resides. For Hive compatibility, this name is
        # entirely lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table. For Hive compatibility, this name is entirely lowercase.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The maximum number of table versions to return in one response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is not the first call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @catalog_id : String? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetTableVersionsResponse
        include JSON::Serializable

        # A continuation token, if the list of available versions does not include the last one.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of strings identifying available versions of the specified table.

        @[JSON::Field(key: "TableVersions")]
        getter table_versions : Array(Types::TableVersion)?

        def initialize(
          @next_token : String? = nil,
          @table_versions : Array(Types::TableVersion)? = nil
        )
        end
      end


      struct GetTablesRequest
        include JSON::Serializable

        # The database in the catalog whose tables to list. For Hive compatibility, this name is entirely
        # lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # Specifies the table fields returned by the GetTables call. This parameter doesnt accept an empty
        # list. The request must include NAME . The following are the valid combinations of values: NAME -
        # Names of all tables in the database. NAME , TABLE_TYPE - Names of all tables and the table types.

        @[JSON::Field(key: "AttributesToGet")]
        getter attributes_to_get : Array(String)?

        # A structure containing the Lake Formation audit context .

        @[JSON::Field(key: "AuditContext")]
        getter audit_context : Types::AuditContext?

        # The ID of the Data Catalog where the tables reside. If none is provided, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # A regular expression pattern. If present, only those tables whose names match the pattern are
        # returned.

        @[JSON::Field(key: "Expression")]
        getter expression : String?

        # Specifies whether to include status details related to a request to create or update an Glue Data
        # Catalog view.

        @[JSON::Field(key: "IncludeStatusDetails")]
        getter include_status_details : Bool?

        # The maximum number of tables to return in a single response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, included if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The time as of when to read the table contents. If not set, the most recent transaction commit time
        # will be used. Cannot be specified along with TransactionId .

        @[JSON::Field(key: "QueryAsOfTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter query_as_of_time : Time?

        # The transaction ID at which to read the table contents.

        @[JSON::Field(key: "TransactionId")]
        getter transaction_id : String?

        def initialize(
          @database_name : String,
          @attributes_to_get : Array(String)? = nil,
          @audit_context : Types::AuditContext? = nil,
          @catalog_id : String? = nil,
          @expression : String? = nil,
          @include_status_details : Bool? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @query_as_of_time : Time? = nil,
          @transaction_id : String? = nil
        )
        end
      end


      struct GetTablesResponse
        include JSON::Serializable

        # A continuation token, present if the current list segment is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of the requested Table objects.

        @[JSON::Field(key: "TableList")]
        getter table_list : Array(Types::Table)?

        def initialize(
          @next_token : String? = nil,
          @table_list : Array(Types::Table)? = nil
        )
        end
      end


      struct GetTagsRequest
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the resource for which to retrieve tags.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        def initialize(
          @resource_arn : String
        )
        end
      end


      struct GetTagsResponse
        include JSON::Serializable

        # The requested tags.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct GetTriggerRequest
        include JSON::Serializable

        # The name of the trigger to retrieve.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct GetTriggerResponse
        include JSON::Serializable

        # The requested trigger definition.

        @[JSON::Field(key: "Trigger")]
        getter trigger : Types::Trigger?

        def initialize(
          @trigger : Types::Trigger? = nil
        )
        end
      end


      struct GetTriggersRequest
        include JSON::Serializable

        # The name of the job to retrieve triggers for. The trigger that can start this job is returned, and
        # if there is no such trigger, all triggers are returned.

        @[JSON::Field(key: "DependentJobName")]
        getter dependent_job_name : String?

        # The maximum size of the response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @dependent_job_name : String? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetTriggersResponse
        include JSON::Serializable

        # A continuation token, if not all the requested triggers have yet been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of triggers for the specified job.

        @[JSON::Field(key: "Triggers")]
        getter triggers : Array(Types::Trigger)?

        def initialize(
          @next_token : String? = nil,
          @triggers : Array(Types::Trigger)? = nil
        )
        end
      end


      struct GetUnfilteredPartitionMetadataRequest
        include JSON::Serializable

        # The catalog ID where the partition resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # (Required) Specifies the name of a database that contains the partition.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # (Required) A list of partition key values.

        @[JSON::Field(key: "PartitionValues")]
        getter partition_values : Array(String)

        # (Required) A list of supported permission types.

        @[JSON::Field(key: "SupportedPermissionTypes")]
        getter supported_permission_types : Array(String)

        # (Required) Specifies the name of a table that contains the partition.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # A structure containing Lake Formation audit context information.

        @[JSON::Field(key: "AuditContext")]
        getter audit_context : Types::AuditContext?

        # A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a
        # Lake Formation generated authorization identifier and information from the request's authorization
        # context.

        @[JSON::Field(key: "QuerySessionContext")]
        getter query_session_context : Types::QuerySessionContext?

        # Specified only if the base tables belong to a different Amazon Web Services Region.

        @[JSON::Field(key: "Region")]
        getter region : String?

        def initialize(
          @catalog_id : String,
          @database_name : String,
          @partition_values : Array(String),
          @supported_permission_types : Array(String),
          @table_name : String,
          @audit_context : Types::AuditContext? = nil,
          @query_session_context : Types::QuerySessionContext? = nil,
          @region : String? = nil
        )
        end
      end


      struct GetUnfilteredPartitionMetadataResponse
        include JSON::Serializable

        # A list of column names that the user has been granted access to.

        @[JSON::Field(key: "AuthorizedColumns")]
        getter authorized_columns : Array(String)?

        # A Boolean value that indicates whether the partition location is registered with Lake Formation.

        @[JSON::Field(key: "IsRegisteredWithLakeFormation")]
        getter is_registered_with_lake_formation : Bool?

        # A Partition object containing the partition metadata.

        @[JSON::Field(key: "Partition")]
        getter partition : Types::Partition?

        def initialize(
          @authorized_columns : Array(String)? = nil,
          @is_registered_with_lake_formation : Bool? = nil,
          @partition : Types::Partition? = nil
        )
        end
      end


      struct GetUnfilteredPartitionsMetadataRequest
        include JSON::Serializable

        # The ID of the Data Catalog where the partitions in question reside. If none is provided, the AWS
        # account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # The name of the catalog database where the partitions reside.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A list of supported permission types.

        @[JSON::Field(key: "SupportedPermissionTypes")]
        getter supported_permission_types : Array(String)

        # The name of the table that contains the partition.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # A structure containing Lake Formation audit context information.

        @[JSON::Field(key: "AuditContext")]
        getter audit_context : Types::AuditContext?

        # An expression that filters the partitions to be returned. The expression uses SQL syntax similar to
        # the SQL WHERE filter clause. The SQL statement parser JSQLParser parses the expression. Operators :
        # The following are the operators that you can use in the Expression API call: = Checks whether the
        # values of the two operands are equal; if yes, then the condition becomes true. Example: Assume
        # 'variable a' holds 10 and 'variable b' holds 20. (a = b) is not true. &lt; &gt; Checks whether the
        # values of two operands are equal; if the values are not equal, then the condition becomes true.
        # Example: (a &lt; &gt; b) is true. &gt; Checks whether the value of the left operand is greater than
        # the value of the right operand; if yes, then the condition becomes true. Example: (a &gt; b) is not
        # true. &lt; Checks whether the value of the left operand is less than the value of the right operand;
        # if yes, then the condition becomes true. Example: (a &lt; b) is true. &gt;= Checks whether the value
        # of the left operand is greater than or equal to the value of the right operand; if yes, then the
        # condition becomes true. Example: (a &gt;= b) is not true. &lt;= Checks whether the value of the left
        # operand is less than or equal to the value of the right operand; if yes, then the condition becomes
        # true. Example: (a &lt;= b) is true. AND, OR, IN, BETWEEN, LIKE, NOT, IS NULL Logical operators.
        # Supported Partition Key Types : The following are the supported partition keys. string date
        # timestamp int bigint long tinyint smallint decimal If an type is encountered that is not valid, an
        # exception is thrown.

        @[JSON::Field(key: "Expression")]
        getter expression : String?

        # The maximum number of partitions to return in a single response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is not the first call to retrieve these partitions.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a
        # Lake Formation generated authorization identifier and information from the request's authorization
        # context.

        @[JSON::Field(key: "QuerySessionContext")]
        getter query_session_context : Types::QuerySessionContext?

        # Specified only if the base tables belong to a different Amazon Web Services Region.

        @[JSON::Field(key: "Region")]
        getter region : String?

        # The segment of the table's partitions to scan in this request.

        @[JSON::Field(key: "Segment")]
        getter segment : Types::Segment?

        def initialize(
          @catalog_id : String,
          @database_name : String,
          @supported_permission_types : Array(String),
          @table_name : String,
          @audit_context : Types::AuditContext? = nil,
          @expression : String? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @query_session_context : Types::QuerySessionContext? = nil,
          @region : String? = nil,
          @segment : Types::Segment? = nil
        )
        end
      end


      struct GetUnfilteredPartitionsMetadataResponse
        include JSON::Serializable

        # A continuation token, if the returned list of partitions does not include the last one.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of requested partitions.

        @[JSON::Field(key: "UnfilteredPartitions")]
        getter unfiltered_partitions : Array(Types::UnfilteredPartition)?

        def initialize(
          @next_token : String? = nil,
          @unfiltered_partitions : Array(Types::UnfilteredPartition)? = nil
        )
        end
      end


      struct GetUnfilteredTableMetadataRequest
        include JSON::Serializable

        # The catalog ID where the table resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # (Required) Specifies the name of a database that contains the table.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # (Required) Specifies the name of a table for which you are requesting metadata.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Indicates the level of filtering a third-party analytical engine is capable of enforcing when
        # calling the GetUnfilteredTableMetadata API operation. Accepted values are: COLUMN_PERMISSION -
        # Column permissions ensure that users can access only specific columns in the table. If there are
        # particular columns contain sensitive data, data lake administrators can define column filters that
        # exclude access to specific columns. CELL_FILTER_PERMISSION - Cell-level filtering combines column
        # filtering (include or exclude columns) and row filter expressions to restrict access to individual
        # elements in the table. NESTED_PERMISSION - Nested permissions combines cell-level filtering and
        # nested column filtering to restrict access to columns and/or nested columns in specific rows based
        # on row filter expressions. NESTED_CELL_PERMISSION - Nested cell permissions combines nested
        # permission with nested cell-level filtering. This allows different subsets of nested columns to be
        # restricted based on an array of row filter expressions. Note: Each of these permission types follows
        # a hierarchical order where each subsequent permission type includes all permission of the previous
        # type. Important: If you provide a supported permission type that doesn't match the user's level of
        # permissions on the table, then Lake Formation raises an exception. For example, if the third-party
        # engine calling the GetUnfilteredTableMetadata operation can enforce only column-level filtering, and
        # the user has nested cell filtering applied on the table, Lake Formation throws an exception, and
        # will not return unfiltered table metadata and data access credentials.

        @[JSON::Field(key: "SupportedPermissionTypes")]
        getter supported_permission_types : Array(String)

        # A structure containing Lake Formation audit context information.

        @[JSON::Field(key: "AuditContext")]
        getter audit_context : Types::AuditContext?

        # The resource ARN of the view.

        @[JSON::Field(key: "ParentResourceArn")]
        getter parent_resource_arn : String?

        # The Lake Formation data permissions of the caller on the table. Used to authorize the call when no
        # view context is found.

        @[JSON::Field(key: "Permissions")]
        getter permissions : Array(String)?

        # A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a
        # Lake Formation generated authorization identifier and information from the request's authorization
        # context.

        @[JSON::Field(key: "QuerySessionContext")]
        getter query_session_context : Types::QuerySessionContext?

        # Specified only if the base tables belong to a different Amazon Web Services Region.

        @[JSON::Field(key: "Region")]
        getter region : String?

        # The resource ARN of the root view in a chain of nested views.

        @[JSON::Field(key: "RootResourceArn")]
        getter root_resource_arn : String?

        # A structure specifying the dialect and dialect version used by the query engine.

        @[JSON::Field(key: "SupportedDialect")]
        getter supported_dialect : Types::SupportedDialect?

        def initialize(
          @catalog_id : String,
          @database_name : String,
          @name : String,
          @supported_permission_types : Array(String),
          @audit_context : Types::AuditContext? = nil,
          @parent_resource_arn : String? = nil,
          @permissions : Array(String)? = nil,
          @query_session_context : Types::QuerySessionContext? = nil,
          @region : String? = nil,
          @root_resource_arn : String? = nil,
          @supported_dialect : Types::SupportedDialect? = nil
        )
        end
      end


      struct GetUnfilteredTableMetadataResponse
        include JSON::Serializable

        # A list of column names that the user has been granted access to.

        @[JSON::Field(key: "AuthorizedColumns")]
        getter authorized_columns : Array(String)?

        # A list of column row filters.

        @[JSON::Field(key: "CellFilters")]
        getter cell_filters : Array(Types::ColumnRowFilter)?

        # Indicates if a table is a materialized view.

        @[JSON::Field(key: "IsMaterializedView")]
        getter is_materialized_view : Bool?

        # Specifies whether the view supports the SQL dialects of one or more different query engines and can
        # therefore be read by those engines.

        @[JSON::Field(key: "IsMultiDialectView")]
        getter is_multi_dialect_view : Bool?

        # A flag that instructs the engine not to push user-provided operations into the logical plan of the
        # view during query planning. However, if set this flag does not guarantee that the engine will
        # comply. Refer to the engine's documentation to understand the guarantees provided, if any.

        @[JSON::Field(key: "IsProtected")]
        getter is_protected : Bool?

        # A Boolean value that indicates whether the partition location is registered with Lake Formation.

        @[JSON::Field(key: "IsRegisteredWithLakeFormation")]
        getter is_registered_with_lake_formation : Bool?

        # The Lake Formation data permissions of the caller on the table. Used to authorize the call when no
        # view context is found.

        @[JSON::Field(key: "Permissions")]
        getter permissions : Array(String)?

        # A cryptographically generated query identifier generated by Glue or Lake Formation.

        @[JSON::Field(key: "QueryAuthorizationId")]
        getter query_authorization_id : String?

        # The resource ARN of the parent resource extracted from the request.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String?

        # The filter that applies to the table. For example when applying the filter in SQL, it would go in
        # the WHERE clause and can be evaluated by using an AND operator with any other predicates applied by
        # the user querying the table.

        @[JSON::Field(key: "RowFilter")]
        getter row_filter : String?

        # A Table object containing the table metadata.

        @[JSON::Field(key: "Table")]
        getter table : Types::Table?

        def initialize(
          @authorized_columns : Array(String)? = nil,
          @cell_filters : Array(Types::ColumnRowFilter)? = nil,
          @is_materialized_view : Bool? = nil,
          @is_multi_dialect_view : Bool? = nil,
          @is_protected : Bool? = nil,
          @is_registered_with_lake_formation : Bool? = nil,
          @permissions : Array(String)? = nil,
          @query_authorization_id : String? = nil,
          @resource_arn : String? = nil,
          @row_filter : String? = nil,
          @table : Types::Table? = nil
        )
        end
      end


      struct GetUsageProfileRequest
        include JSON::Serializable

        # The name of the usage profile to retrieve.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct GetUsageProfileResponse
        include JSON::Serializable

        # A ProfileConfiguration object specifying the job and session values for the profile.

        @[JSON::Field(key: "Configuration")]
        getter configuration : Types::ProfileConfiguration?

        # The date and time when the usage profile was created.

        @[JSON::Field(key: "CreatedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_on : Time?

        # A description of the usage profile.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The date and time when the usage profile was last modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The name of the usage profile.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @configuration : Types::ProfileConfiguration? = nil,
          @created_on : Time? = nil,
          @description : String? = nil,
          @last_modified_on : Time? = nil,
          @name : String? = nil
        )
        end
      end


      struct GetUserDefinedFunctionRequest
        include JSON::Serializable

        # The name of the catalog database where the function is located.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the function.

        @[JSON::Field(key: "FunctionName")]
        getter function_name : String

        # The ID of the Data Catalog where the function to be retrieved is located. If none is provided, the
        # Amazon Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @function_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct GetUserDefinedFunctionResponse
        include JSON::Serializable

        # The requested function definition.

        @[JSON::Field(key: "UserDefinedFunction")]
        getter user_defined_function : Types::UserDefinedFunction?

        def initialize(
          @user_defined_function : Types::UserDefinedFunction? = nil
        )
        end
      end


      struct GetUserDefinedFunctionsRequest
        include JSON::Serializable

        # An optional function-name pattern string that filters the function definitions returned.

        @[JSON::Field(key: "Pattern")]
        getter pattern : String

        # The ID of the Data Catalog where the functions to be retrieved are located. If none is provided, the
        # Amazon Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The name of the catalog database where the functions are located. If none is provided, functions
        # from all the databases across the catalog will be returned.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # An optional function-type pattern string that filters the function definitions returned from Amazon
        # Redshift Federated Permissions Catalog. Specify a value of REGULAR_FUNCTION or STORED_PROCEDURE .
        # The STORED_PROCEDURE function type is only compatible with Amazon Redshift Federated Permissions
        # Catalog.

        @[JSON::Field(key: "FunctionType")]
        getter function_type : String?

        # The maximum number of functions to return in one response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @pattern : String,
          @catalog_id : String? = nil,
          @database_name : String? = nil,
          @function_type : String? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetUserDefinedFunctionsResponse
        include JSON::Serializable

        # A continuation token, if the list of functions returned does not include the last requested
        # function.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of requested function definitions.

        @[JSON::Field(key: "UserDefinedFunctions")]
        getter user_defined_functions : Array(Types::UserDefinedFunction)?

        def initialize(
          @next_token : String? = nil,
          @user_defined_functions : Array(Types::UserDefinedFunction)? = nil
        )
        end
      end


      struct GetWorkflowRequest
        include JSON::Serializable

        # The name of the workflow to retrieve.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Specifies whether to include a graph when returning the workflow resource metadata.

        @[JSON::Field(key: "IncludeGraph")]
        getter include_graph : Bool?

        def initialize(
          @name : String,
          @include_graph : Bool? = nil
        )
        end
      end


      struct GetWorkflowResponse
        include JSON::Serializable

        # The resource metadata for the workflow.

        @[JSON::Field(key: "Workflow")]
        getter workflow : Types::Workflow?

        def initialize(
          @workflow : Types::Workflow? = nil
        )
        end
      end


      struct GetWorkflowRunPropertiesRequest
        include JSON::Serializable

        # Name of the workflow which was run.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the workflow run whose run properties should be returned.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        def initialize(
          @name : String,
          @run_id : String
        )
        end
      end


      struct GetWorkflowRunPropertiesResponse
        include JSON::Serializable

        # The workflow run properties which were set during the specified run.

        @[JSON::Field(key: "RunProperties")]
        getter run_properties : Hash(String, String)?

        def initialize(
          @run_properties : Hash(String, String)? = nil
        )
        end
      end


      struct GetWorkflowRunRequest
        include JSON::Serializable

        # Name of the workflow being run.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the workflow run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        # Specifies whether to include the workflow graph in response or not.

        @[JSON::Field(key: "IncludeGraph")]
        getter include_graph : Bool?

        def initialize(
          @name : String,
          @run_id : String,
          @include_graph : Bool? = nil
        )
        end
      end


      struct GetWorkflowRunResponse
        include JSON::Serializable

        # The requested workflow run metadata.

        @[JSON::Field(key: "Run")]
        getter run : Types::WorkflowRun?

        def initialize(
          @run : Types::WorkflowRun? = nil
        )
        end
      end


      struct GetWorkflowRunsRequest
        include JSON::Serializable

        # Name of the workflow whose metadata of runs should be returned.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Specifies whether to include the workflow graph in response or not.

        @[JSON::Field(key: "IncludeGraph")]
        getter include_graph : Bool?

        # The maximum number of workflow runs to be included in the response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # The maximum size of the response.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @name : String,
          @include_graph : Bool? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct GetWorkflowRunsResponse
        include JSON::Serializable

        # A continuation token, if not all requested workflow runs have been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of workflow run metadata objects.

        @[JSON::Field(key: "Runs")]
        getter runs : Array(Types::WorkflowRun)?

        def initialize(
          @next_token : String? = nil,
          @runs : Array(Types::WorkflowRun)? = nil
        )
        end
      end

      # An encryption operation failed.

      struct GlueEncryptionException
        include JSON::Serializable

        # The message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # A structure for returning a resource policy.

      struct GluePolicy
        include JSON::Serializable

        # The date and time at which the policy was created.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time?

        # Contains the hash value associated with this policy.

        @[JSON::Field(key: "PolicyHash")]
        getter policy_hash : String?

        # Contains the requested policy document, in JSON format.

        @[JSON::Field(key: "PolicyInJson")]
        getter policy_in_json : String?

        # The date and time at which the policy was last updated.

        @[JSON::Field(key: "UpdateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter update_time : Time?

        def initialize(
          @create_time : Time? = nil,
          @policy_hash : String? = nil,
          @policy_in_json : String? = nil,
          @update_time : Time? = nil
        )
        end
      end

      # Specifies a user-defined schema when a schema cannot be determined by Glue.

      struct GlueSchema
        include JSON::Serializable

        # Specifies the column definitions that make up a Glue schema.

        @[JSON::Field(key: "Columns")]
        getter columns : Array(Types::GlueStudioSchemaColumn)?

        def initialize(
          @columns : Array(Types::GlueStudioSchemaColumn)? = nil
        )
        end
      end

      # Specifies a single column in a Glue schema definition.

      struct GlueStudioSchemaColumn
        include JSON::Serializable

        # The name of the column in the Glue Studio schema.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The data type of the column as defined in Glue Studio.

        @[JSON::Field(key: "GlueStudioType")]
        getter glue_studio_type : String?

        # The hive type for this column in the Glue Studio schema.

        @[JSON::Field(key: "Type")]
        getter type : String?

        def initialize(
          @name : String,
          @glue_studio_type : String? = nil,
          @type : String? = nil
        )
        end
      end

      # The database and table in the Glue Data Catalog that is used for input or output data.

      struct GlueTable
        include JSON::Serializable

        # A database name in the Glue Data Catalog.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A table name in the Glue Data Catalog.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # Additional options for the table. Currently there are two keys supported: pushDownPredicate : to
        # filter on partitions without having to list and read all the files in your dataset.
        # catalogPartitionPredicate : to use server-side partition pruning using partition indexes in the Glue
        # Data Catalog.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?

        # A unique identifier for the Glue Data Catalog.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The name of the connection to the Glue Data Catalog.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @additional_options : Hash(String, String)? = nil,
          @catalog_id : String? = nil,
          @connection_name : String? = nil
        )
        end
      end

      # Specifies the data store in the governed Glue Data Catalog.

      struct GovernedCatalogSource
        include JSON::Serializable

        # The database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data store.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The database table to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Types::S3SourceAdditionalOptions?

        # Partitions satisfying this predicate are deleted. Files within the retention period in these
        # partitions are not deleted. Set to ""  empty by default.

        @[JSON::Field(key: "PartitionPredicate")]
        getter partition_predicate : String?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @additional_options : Types::S3SourceAdditionalOptions? = nil,
          @partition_predicate : String? = nil
        )
        end
      end

      # Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.

      struct GovernedCatalogTarget
        include JSON::Serializable

        # The name of the database to write to.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to write to.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies native partitioning using a sequence of keys.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # A policy that specifies update behavior for the governed catalog.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::CatalogSchemaChangePolicy?

        def initialize(
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::CatalogSchemaChangePolicy? = nil
        )
        end
      end

      # A classifier that uses grok patterns.

      struct GrokClassifier
        include JSON::Serializable

        # An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs,
        # and so on.

        @[JSON::Field(key: "Classification")]
        getter classification : String

        # The grok pattern applied to a data store by this classifier. For more information, see built-in
        # patterns in Writing Custom Classifiers .

        @[JSON::Field(key: "GrokPattern")]
        getter grok_pattern : String

        # The name of the classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The time that this classifier was registered.

        @[JSON::Field(key: "CreationTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter creation_time : Time?

        # Optional custom grok patterns defined by this classifier. For more information, see custom patterns
        # in Writing Custom Classifiers .

        @[JSON::Field(key: "CustomPatterns")]
        getter custom_patterns : String?

        # The time that this classifier was last updated.

        @[JSON::Field(key: "LastUpdated", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_updated : Time?

        # The version of this classifier.

        @[JSON::Field(key: "Version")]
        getter version : Int64?

        def initialize(
          @classification : String,
          @grok_pattern : String,
          @name : String,
          @creation_time : Time? = nil,
          @custom_patterns : String? = nil,
          @last_updated : Time? = nil,
          @version : Int64? = nil
        )
        end
      end

      # Specifies a group of filters with a logical operator that determines how the filters are combined to
      # evaluate routing conditions.

      struct GroupFilters
        include JSON::Serializable

        # A list of filter expressions that define the conditions for this group.

        @[JSON::Field(key: "Filters")]
        getter filters : Array(Types::FilterExpression)

        # The name of the filter group.

        @[JSON::Field(key: "GroupName")]
        getter group_name : String

        # The logical operator used to combine the filters in this group. Determines whether all filters must
        # match (AND) or any filter can match (OR).

        @[JSON::Field(key: "LogicalOperator")]
        getter logical_operator : String

        def initialize(
          @filters : Array(Types::FilterExpression),
          @group_name : String,
          @logical_operator : String
        )
        end
      end

      # Specifies an Apache Hudi data source.

      struct HudiTarget
        include JSON::Serializable

        # The name of the connection to use to connect to the Hudi target. If your Hudi files are stored in
        # buckets that require VPC authorization, you can set their connection properties here.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables
        # with a Crawler .

        @[JSON::Field(key: "Exclusions")]
        getter exclusions : Array(String)?

        # The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Hudi metadata
        # folder in your Amazon S3 path. Used to limit the crawler run time.

        @[JSON::Field(key: "MaximumTraversalDepth")]
        getter maximum_traversal_depth : Int32?

        # An array of Amazon S3 location strings for Hudi, each indicating the root folder with which the
        # metadata files for a Hudi table resides. The Hudi folder may be located in a child folder of the
        # root folder. The crawler will scan all folders underneath a path for a Hudi folder.

        @[JSON::Field(key: "Paths")]
        getter paths : Array(String)?

        def initialize(
          @connection_name : String? = nil,
          @exclusions : Array(String)? = nil,
          @maximum_traversal_depth : Int32? = nil,
          @paths : Array(String)? = nil
        )
        end
      end

      # The configuration for an Iceberg compaction optimizer. This configuration defines parameters for
      # optimizing the layout of data files in Iceberg tables.

      struct IcebergCompactionConfiguration
        include JSON::Serializable

        # The minimum number of deletes that must be present in a data file to make it eligible for
        # compaction. This parameter helps optimize compaction by focusing on files that contain a significant
        # number of delete operations, which can improve query performance by removing deleted records. If an
        # input is not provided, the default value 1 will be used.

        @[JSON::Field(key: "deleteFileThreshold")]
        getter delete_file_threshold : Int32?

        # The minimum number of data files that must be present in a partition before compaction will actually
        # compact files. This parameter helps control when compaction is triggered, preventing unnecessary
        # compaction operations on partitions with few files. If an input is not provided, the default value
        # 100 will be used.

        @[JSON::Field(key: "minInputFiles")]
        getter min_input_files : Int32?

        # The strategy to use for compaction. Valid values are: binpack : Combines small files into larger
        # files, typically targeting sizes over 100MB, while applying any pending deletes. This is the
        # recommended compaction strategy for most use cases. sort : Organizes data based on specified columns
        # which are sorted hierarchically during compaction, improving query performance for filtered
        # operations. This strategy is recommended when your queries frequently filter on specific columns. To
        # use this strategy, you must first define a sort order in your Iceberg table properties using the
        # sort_order table property. z-order : Optimizes data organization by blending multiple attributes
        # into a single scalar value that can be used for sorting, allowing efficient querying across multiple
        # dimensions. This strategy is recommended when you need to query data across multiple dimensions
        # simultaneously. To use this strategy, you must first define a sort order in your Iceberg table
        # properties using the sort_order table property. If an input is not provided, the default value
        # 'binpack' will be used.

        @[JSON::Field(key: "strategy")]
        getter strategy : String?

        def initialize(
          @delete_file_threshold : Int32? = nil,
          @min_input_files : Int32? = nil,
          @strategy : String? = nil
        )
        end
      end

      # Compaction metrics for Iceberg for the optimizer run.

      struct IcebergCompactionMetrics
        include JSON::Serializable

        # The number of DPU hours consumed by the job.

        @[JSON::Field(key: "DpuHours")]
        getter dpu_hours : Float64?

        # The duration of the job in hours.

        @[JSON::Field(key: "JobDurationInHour")]
        getter job_duration_in_hour : Float64?

        # The number of bytes removed by the compaction job run.

        @[JSON::Field(key: "NumberOfBytesCompacted")]
        getter number_of_bytes_compacted : Int64?

        # The number of DPUs consumed by the job, rounded up to the nearest whole number.

        @[JSON::Field(key: "NumberOfDpus")]
        getter number_of_dpus : Int32?

        # The number of files removed by the compaction job run.

        @[JSON::Field(key: "NumberOfFilesCompacted")]
        getter number_of_files_compacted : Int64?

        def initialize(
          @dpu_hours : Float64? = nil,
          @job_duration_in_hour : Float64? = nil,
          @number_of_bytes_compacted : Int64? = nil,
          @number_of_dpus : Int32? = nil,
          @number_of_files_compacted : Int64? = nil
        )
        end
      end


      struct IcebergDocument
        include JSON::Serializable

        def initialize
        end
      end

      # Encryption key structure used for Iceberg table encryption. Contains the key ID, encrypted key
      # metadata, optional reference to the encrypting key, and additional properties for the table's
      # encryption scheme.

      struct IcebergEncryptedKey
        include JSON::Serializable

        # Encrypted key and metadata, base64 encoded. The format of encrypted key metadata is determined by
        # the table's encryption scheme and can be a wrapped format specific to the table's KMS provider.

        @[JSON::Field(key: "EncryptedKeyMetadata")]
        getter encrypted_key_metadata : String

        # Unique identifier of the encryption key used for Iceberg table encryption. This ID is used to
        # reference the key in table metadata and track which key was used to encrypt specific data.

        @[JSON::Field(key: "KeyId")]
        getter key_id : String

        # Optional ID of the key used to encrypt or wrap the key metadata in Iceberg table encryption. This
        # field references another encryption key that was used to encrypt the current key's metadata.

        @[JSON::Field(key: "EncryptedById")]
        getter encrypted_by_id : String?

        # A string to string map of additional metadata used by the table's encryption scheme. These
        # properties provide additional context and configuration for the encryption key implementation.

        @[JSON::Field(key: "Properties")]
        getter properties : Hash(String, String)?

        def initialize(
          @encrypted_key_metadata : String,
          @key_id : String,
          @encrypted_by_id : String? = nil,
          @properties : Hash(String, String)? = nil
        )
        end
      end

      # A structure that defines an Apache Iceberg metadata table to create in the catalog.

      struct IcebergInput
        include JSON::Serializable

        # A required metadata operation. Can only be set to CREATE .

        @[JSON::Field(key: "MetadataOperation")]
        getter metadata_operation : String

        # The configuration parameters required to create a new Iceberg table in the Glue Data Catalog,
        # including table properties and metadata specifications.

        @[JSON::Field(key: "CreateIcebergTableInput")]
        getter create_iceberg_table_input : Types::CreateIcebergTableInput?

        # The table version for the Iceberg table. Defaults to 2.

        @[JSON::Field(key: "Version")]
        getter version : String?

        def initialize(
          @metadata_operation : String,
          @create_iceberg_table_input : Types::CreateIcebergTableInput? = nil,
          @version : String? = nil
        )
        end
      end

      # A structure that specifies Iceberg table optimization properties for the catalog, including
      # configurations for compaction, retention, and orphan file deletion operations.

      struct IcebergOptimizationProperties
        include JSON::Serializable

        # A map of key-value pairs that specify configuration parameters for Iceberg table compaction
        # operations, which optimize the layout of data files to improve query performance.

        @[JSON::Field(key: "Compaction")]
        getter compaction : Hash(String, String)?

        # A map of key-value pairs that specify configuration parameters for Iceberg orphan file deletion
        # operations, which identify and remove files that are no longer referenced by the table metadata.

        @[JSON::Field(key: "OrphanFileDeletion")]
        getter orphan_file_deletion : Hash(String, String)?

        # A map of key-value pairs that specify configuration parameters for Iceberg table retention
        # operations, which manage the lifecycle of table snapshots to control storage costs.

        @[JSON::Field(key: "Retention")]
        getter retention : Hash(String, String)?

        # The Amazon Resource Name (ARN) of the IAM role that will be assumed to perform Iceberg table
        # optimization operations.

        @[JSON::Field(key: "RoleArn")]
        getter role_arn : String?

        def initialize(
          @compaction : Hash(String, String)? = nil,
          @orphan_file_deletion : Hash(String, String)? = nil,
          @retention : Hash(String, String)? = nil,
          @role_arn : String? = nil
        )
        end
      end

      # A structure that contains the output properties of Iceberg table optimization configuration for your
      # catalog resource in the Glue Data Catalog.

      struct IcebergOptimizationPropertiesOutput
        include JSON::Serializable

        # A map of key-value pairs that specify configuration parameters for Iceberg table compaction
        # operations, which optimize the layout of data files to improve query performance.

        @[JSON::Field(key: "Compaction")]
        getter compaction : Hash(String, String)?

        # The timestamp when the Iceberg optimization properties were last updated.

        @[JSON::Field(key: "LastUpdatedTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_updated_time : Time?

        # A map of key-value pairs that specify configuration parameters for Iceberg orphan file deletion
        # operations, which identify and remove files that are no longer referenced by the table metadata.

        @[JSON::Field(key: "OrphanFileDeletion")]
        getter orphan_file_deletion : Hash(String, String)?

        # A map of key-value pairs that specify configuration parameters for Iceberg table retention
        # operations, which manage the lifecycle of table snapshots to control storage costs.

        @[JSON::Field(key: "Retention")]
        getter retention : Hash(String, String)?

        # The Amazon Resource Name (ARN) of the IAM role that is used to perform Iceberg table optimization
        # operations.

        @[JSON::Field(key: "RoleArn")]
        getter role_arn : String?

        def initialize(
          @compaction : Hash(String, String)? = nil,
          @last_updated_time : Time? = nil,
          @orphan_file_deletion : Hash(String, String)? = nil,
          @retention : Hash(String, String)? = nil,
          @role_arn : String? = nil
        )
        end
      end

      # The configuration for an Iceberg orphan file deletion optimizer.

      struct IcebergOrphanFileDeletionConfiguration
        include JSON::Serializable

        # Specifies a directory in which to look for files (defaults to the table's location). You may choose
        # a sub-directory rather than the top-level table location.

        @[JSON::Field(key: "location")]
        getter location : String?

        # The number of days that orphan files should be retained before file deletion. If an input is not
        # provided, the default value 3 will be used.

        @[JSON::Field(key: "orphanFileRetentionPeriodInDays")]
        getter orphan_file_retention_period_in_days : Int32?

        # The interval in hours between orphan file deletion job runs. This parameter controls how frequently
        # the orphan file deletion optimizer will run to clean up orphan files. The value must be between 3
        # and 168 hours (7 days). If an input is not provided, the default value 24 will be used.

        @[JSON::Field(key: "runRateInHours")]
        getter run_rate_in_hours : Int32?

        def initialize(
          @location : String? = nil,
          @orphan_file_retention_period_in_days : Int32? = nil,
          @run_rate_in_hours : Int32? = nil
        )
        end
      end

      # Orphan file deletion metrics for Iceberg for the optimizer run.

      struct IcebergOrphanFileDeletionMetrics
        include JSON::Serializable

        # The number of DPU hours consumed by the job.

        @[JSON::Field(key: "DpuHours")]
        getter dpu_hours : Float64?

        # The duration of the job in hours.

        @[JSON::Field(key: "JobDurationInHour")]
        getter job_duration_in_hour : Float64?

        # The number of DPUs consumed by the job, rounded up to the nearest whole number.

        @[JSON::Field(key: "NumberOfDpus")]
        getter number_of_dpus : Int32?

        # The number of orphan files deleted by the orphan file deletion job run.

        @[JSON::Field(key: "NumberOfOrphanFilesDeleted")]
        getter number_of_orphan_files_deleted : Int64?

        def initialize(
          @dpu_hours : Float64? = nil,
          @job_duration_in_hour : Float64? = nil,
          @number_of_dpus : Int32? = nil,
          @number_of_orphan_files_deleted : Int64? = nil
        )
        end
      end

      # Defines a single partition field within an Iceberg partition specification, including the source
      # field, transformation function, partition name, and unique identifier.

      struct IcebergPartitionField
        include JSON::Serializable

        # The name of the partition field as it will appear in the partitioned table structure.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The identifier of the source field from the table schema that this partition field is based on.

        @[JSON::Field(key: "SourceId")]
        getter source_id : Int32

        # The transformation function applied to the source field to create the partition, such as identity,
        # bucket, truncate, year, month, day, or hour.

        @[JSON::Field(key: "Transform")]
        getter transform : String

        # The unique identifier assigned to this partition field within the Iceberg table's partition
        # specification.

        @[JSON::Field(key: "FieldId")]
        getter field_id : Int32?

        def initialize(
          @name : String,
          @source_id : Int32,
          @transform : String,
          @field_id : Int32? = nil
        )
        end
      end

      # Defines the partitioning specification for an Iceberg table, determining how table data will be
      # organized and partitioned for optimal query performance.

      struct IcebergPartitionSpec
        include JSON::Serializable

        # The list of partition fields that define how the table data should be partitioned, including source
        # fields and their transformations.

        @[JSON::Field(key: "Fields")]
        getter fields : Array(Types::IcebergPartitionField)

        # The unique identifier for this partition specification within the Iceberg table's metadata history.

        @[JSON::Field(key: "SpecId")]
        getter spec_id : Int32?

        def initialize(
          @fields : Array(Types::IcebergPartitionField),
          @spec_id : Int32? = nil
        )
        end
      end

      # The configuration for an Iceberg snapshot retention optimizer.

      struct IcebergRetentionConfiguration
        include JSON::Serializable

        # If set to false, snapshots are only deleted from table metadata, and the underlying data and
        # metadata files are not deleted.

        @[JSON::Field(key: "cleanExpiredFiles")]
        getter clean_expired_files : Bool?

        # The number of Iceberg snapshots to retain within the retention period. If an input is not provided,
        # the corresponding Iceberg table configuration field will be used or if not present, the default
        # value 1 will be used.

        @[JSON::Field(key: "numberOfSnapshotsToRetain")]
        getter number_of_snapshots_to_retain : Int32?

        # The interval in hours between retention job runs. This parameter controls how frequently the
        # retention optimizer will run to clean up expired snapshots. The value must be between 3 and 168
        # hours (7 days). If an input is not provided, the default value 24 will be used.

        @[JSON::Field(key: "runRateInHours")]
        getter run_rate_in_hours : Int32?

        # The number of days to retain the Iceberg snapshots. If an input is not provided, the corresponding
        # Iceberg table configuration field will be used or if not present, the default value 5 will be used.

        @[JSON::Field(key: "snapshotRetentionPeriodInDays")]
        getter snapshot_retention_period_in_days : Int32?

        def initialize(
          @clean_expired_files : Bool? = nil,
          @number_of_snapshots_to_retain : Int32? = nil,
          @run_rate_in_hours : Int32? = nil,
          @snapshot_retention_period_in_days : Int32? = nil
        )
        end
      end

      # Snapshot retention metrics for Iceberg for the optimizer run.

      struct IcebergRetentionMetrics
        include JSON::Serializable

        # The number of DPU hours consumed by the job.

        @[JSON::Field(key: "DpuHours")]
        getter dpu_hours : Float64?

        # The duration of the job in hours.

        @[JSON::Field(key: "JobDurationInHour")]
        getter job_duration_in_hour : Float64?

        # The number of data files deleted by the retention job run.

        @[JSON::Field(key: "NumberOfDataFilesDeleted")]
        getter number_of_data_files_deleted : Int64?

        # The number of DPUs consumed by the job, rounded up to the nearest whole number.

        @[JSON::Field(key: "NumberOfDpus")]
        getter number_of_dpus : Int32?

        # The number of manifest files deleted by the retention job run.

        @[JSON::Field(key: "NumberOfManifestFilesDeleted")]
        getter number_of_manifest_files_deleted : Int64?

        # The number of manifest lists deleted by the retention job run.

        @[JSON::Field(key: "NumberOfManifestListsDeleted")]
        getter number_of_manifest_lists_deleted : Int64?

        def initialize(
          @dpu_hours : Float64? = nil,
          @job_duration_in_hour : Float64? = nil,
          @number_of_data_files_deleted : Int64? = nil,
          @number_of_dpus : Int32? = nil,
          @number_of_manifest_files_deleted : Int64? = nil,
          @number_of_manifest_lists_deleted : Int64? = nil
        )
        end
      end

      # Defines the schema structure for an Iceberg table, including field definitions, data types, and
      # schema metadata.

      struct IcebergSchema
        include JSON::Serializable

        # The list of field definitions that make up the table schema, including field names, types, and
        # metadata.

        @[JSON::Field(key: "Fields")]
        getter fields : Array(Types::IcebergStructField)

        # The list of field identifiers that uniquely identify records in the table, used for row-level
        # operations and deduplication.

        @[JSON::Field(key: "IdentifierFieldIds")]
        getter identifier_field_ids : Array(Int32)?

        # The unique identifier for this schema version within the Iceberg table's schema evolution history.

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Int32?

        # The root type of the schema structure, typically "struct" for Iceberg table schemas.

        @[JSON::Field(key: "Type")]
        getter type : String?

        def initialize(
          @fields : Array(Types::IcebergStructField),
          @identifier_field_ids : Array(Int32)? = nil,
          @schema_id : Int32? = nil,
          @type : String? = nil
        )
        end
      end

      # Defines a single field within an Iceberg sort order specification, including the source field,
      # transformation, sort direction, and null value ordering.

      struct IcebergSortField
        include JSON::Serializable

        # The sort direction for this field, either ascending or descending.

        @[JSON::Field(key: "Direction")]
        getter direction : String

        # The ordering behavior for null values in this field, specifying whether nulls should appear first or
        # last in the sort order.

        @[JSON::Field(key: "NullOrder")]
        getter null_order : String

        # The identifier of the source field from the table schema that this sort field is based on.

        @[JSON::Field(key: "SourceId")]
        getter source_id : Int32

        # The transformation function applied to the source field before sorting, such as identity, bucket, or
        # truncate.

        @[JSON::Field(key: "Transform")]
        getter transform : String

        def initialize(
          @direction : String,
          @null_order : String,
          @source_id : Int32,
          @transform : String
        )
        end
      end

      # Defines the sort order specification for an Iceberg table, determining how data should be ordered
      # within partitions to optimize query performance.

      struct IcebergSortOrder
        include JSON::Serializable

        # The list of fields and their sort directions that define the ordering criteria for the Iceberg table
        # data.

        @[JSON::Field(key: "Fields")]
        getter fields : Array(Types::IcebergSortField)

        # The unique identifier for this sort order specification within the Iceberg table's metadata.

        @[JSON::Field(key: "OrderId")]
        getter order_id : Int32

        def initialize(
          @fields : Array(Types::IcebergSortField),
          @order_id : Int32
        )
        end
      end

      # Defines a single field within an Iceberg table schema, including its identifier, name, data type,
      # nullability, and documentation.

      struct IcebergStructField
        include JSON::Serializable

        # The unique identifier assigned to this field within the Iceberg table schema, used for schema
        # evolution and field tracking.

        @[JSON::Field(key: "Id")]
        getter id : Int32

        # The name of the field as it appears in the table schema and query operations.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Indicates whether this field is required (non-nullable) or optional (nullable) in the table schema.

        @[JSON::Field(key: "Required")]
        getter required : Bool

        # The data type definition for this field, specifying the structure and format of the data it
        # contains.

        @[JSON::Field(key: "Type")]
        getter type : Types::IcebergDocument

        # Optional documentation or description text that provides additional context about the purpose and
        # usage of this field.

        @[JSON::Field(key: "Doc")]
        getter doc : String?

        # Default value used to populate the field's value for all records that were written before the field
        # was added to the schema. This enables backward compatibility when adding new fields to existing
        # Iceberg tables.

        @[JSON::Field(key: "InitialDefault")]
        getter initial_default : Types::IcebergDocument?

        # Default value used to populate the field's value for any records written after the field was added
        # to the schema, if the writer does not supply the field's value. This can be changed through schema
        # evolution.

        @[JSON::Field(key: "WriteDefault")]
        getter write_default : Types::IcebergDocument?

        def initialize(
          @id : Int32,
          @name : String,
          @required : Bool,
          @type : Types::IcebergDocument,
          @doc : String? = nil,
          @initial_default : Types::IcebergDocument? = nil,
          @write_default : Types::IcebergDocument? = nil
        )
        end
      end

      # Defines a complete set of updates to be applied to an Iceberg table, including schema changes,
      # partitioning modifications, sort order adjustments, location updates, and property changes.

      struct IcebergTableUpdate
        include JSON::Serializable

        # The updated S3 location where the Iceberg table data will be stored.

        @[JSON::Field(key: "Location")]
        getter location : String

        # The updated schema definition for the Iceberg table, specifying any changes to field structure, data
        # types, or schema metadata.

        @[JSON::Field(key: "Schema")]
        getter schema : Types::IcebergSchema

        # The type of update action to be performed on the Iceberg table. Defines the specific operation such
        # as adding schema, setting current schema, adding partition spec, or managing encryption keys.

        @[JSON::Field(key: "Action")]
        getter action : String?

        # Encryption key information associated with an Iceberg table update operation. Used when adding or
        # removing encryption keys from the table metadata during table evolution.

        @[JSON::Field(key: "EncryptionKey")]
        getter encryption_key : Types::IcebergEncryptedKey?

        # Identifier of the encryption key involved in an Iceberg table update operation. References the
        # specific key being added to or removed from the table's encryption configuration.

        @[JSON::Field(key: "KeyId")]
        getter key_id : String?

        # The updated partitioning specification that defines how the table data should be reorganized and
        # partitioned.

        @[JSON::Field(key: "PartitionSpec")]
        getter partition_spec : Types::IcebergPartitionSpec?

        # Updated key-value pairs of table properties and configuration settings for the Iceberg table.

        @[JSON::Field(key: "Properties")]
        getter properties : Hash(String, String)?

        # The updated sort order specification that defines how data should be ordered within partitions for
        # optimal query performance.

        @[JSON::Field(key: "SortOrder")]
        getter sort_order : Types::IcebergSortOrder?

        def initialize(
          @location : String,
          @schema : Types::IcebergSchema,
          @action : String? = nil,
          @encryption_key : Types::IcebergEncryptedKey? = nil,
          @key_id : String? = nil,
          @partition_spec : Types::IcebergPartitionSpec? = nil,
          @properties : Hash(String, String)? = nil,
          @sort_order : Types::IcebergSortOrder? = nil
        )
        end
      end

      # Specifies an Apache Iceberg data source where Iceberg tables are stored in Amazon S3.

      struct IcebergTarget
        include JSON::Serializable

        # The name of the connection to use to connect to the Iceberg target.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables
        # with a Crawler .

        @[JSON::Field(key: "Exclusions")]
        getter exclusions : Array(String)?

        # The maximum depth of Amazon S3 paths that the crawler can traverse to discover the Iceberg metadata
        # folder in your Amazon S3 path. Used to limit the crawler run time.

        @[JSON::Field(key: "MaximumTraversalDepth")]
        getter maximum_traversal_depth : Int32?

        # One or more Amazon S3 paths that contains Iceberg metadata folders as s3://bucket/prefix .

        @[JSON::Field(key: "Paths")]
        getter paths : Array(String)?

        def initialize(
          @connection_name : String? = nil,
          @exclusions : Array(String)? = nil,
          @maximum_traversal_depth : Int32? = nil,
          @paths : Array(String)? = nil
        )
        end
      end

      # The same unique identifier was associated with two different records.

      struct IdempotentParameterMismatchException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The blueprint is in an invalid state to perform a requested operation.

      struct IllegalBlueprintStateException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The session is in an invalid state to perform a requested operation.

      struct IllegalSessionStateException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The workflow is in an invalid state to perform a requested operation.

      struct IllegalWorkflowStateException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end


      struct ImportCatalogToGlueRequest
        include JSON::Serializable

        # The ID of the catalog to import. Currently, this should be the Amazon Web Services account ID.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @catalog_id : String? = nil
        )
        end
      end


      struct ImportCatalogToGlueResponse
        include JSON::Serializable

        def initialize
        end
      end

      # Specifies configuration properties for an importing labels task run.

      struct ImportLabelsTaskRunProperties
        include JSON::Serializable

        # The Amazon Simple Storage Service (Amazon S3) path from where you will import the labels.

        @[JSON::Field(key: "InputS3Path")]
        getter input_s3_path : String?

        # Indicates whether to overwrite your existing labels.

        @[JSON::Field(key: "Replace")]
        getter replace : Bool?

        def initialize(
          @input_s3_path : String? = nil,
          @replace : Bool? = nil
        )
        end
      end

      # A structure for an integration that writes data into a resource.

      struct InboundIntegration
        include JSON::Serializable

        # The time that the integration was created, in UTC.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time

        # The ARN of the zero-ETL integration.

        @[JSON::Field(key: "IntegrationArn")]
        getter integration_arn : String

        # The ARN of the source resource for the integration.

        @[JSON::Field(key: "SourceArn")]
        getter source_arn : String

        # The possible statuses are: CREATING: The integration is being created. ACTIVE: The integration
        # creation succeeds. MODIFYING: The integration is being modified. FAILED: The integration creation
        # fails. DELETING: The integration is deleted. SYNCING: The integration is synchronizing.
        # NEEDS_ATTENTION: The integration needs attention, such as synchronization.

        @[JSON::Field(key: "Status")]
        getter status : String

        # The ARN of the target resource for the integration.

        @[JSON::Field(key: "TargetArn")]
        getter target_arn : String

        # A list of errors associated with the integration.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::IntegrationError)?

        # Properties associated with the integration.

        @[JSON::Field(key: "IntegrationConfig")]
        getter integration_config : Types::IntegrationConfig?

        def initialize(
          @create_time : Time,
          @integration_arn : String,
          @source_arn : String,
          @status : String,
          @target_arn : String,
          @errors : Array(Types::IntegrationError)? = nil,
          @integration_config : Types::IntegrationConfig? = nil
        )
        end
      end

      # Describes a zero-ETL integration.

      struct Integration
        include JSON::Serializable

        # The time that the integration was created, in UTC.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time

        # The Amazon Resource Name (ARN) for the integration.

        @[JSON::Field(key: "IntegrationArn")]
        getter integration_arn : String

        # A unique name for the integration.

        @[JSON::Field(key: "IntegrationName")]
        getter integration_name : String

        # The ARN for the source of the integration.

        @[JSON::Field(key: "SourceArn")]
        getter source_arn : String

        # The possible statuses are: CREATING: The integration is being created. ACTIVE: The integration
        # creation succeeds. MODIFYING: The integration is being modified. FAILED: The integration creation
        # fails. DELETING: The integration is deleted. SYNCING: The integration is synchronizing.
        # NEEDS_ATTENTION: The integration needs attention, such as synchronization.

        @[JSON::Field(key: "Status")]
        getter status : String

        # The ARN for the target of the integration.

        @[JSON::Field(key: "TargetArn")]
        getter target_arn : String

        # An optional set of non-secret keyvalue pairs that contains additional contextual information for
        # encryption. This can only be provided if KMSKeyId is provided.

        @[JSON::Field(key: "AdditionalEncryptionContext")]
        getter additional_encryption_context : Hash(String, String)?

        # Selects source tables for the integration using Maxwell filter syntax.

        @[JSON::Field(key: "DataFilter")]
        getter data_filter : String?

        # A description for the integration.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A list of errors associated with the integration.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::IntegrationError)?

        # Properties associated with the integration.

        @[JSON::Field(key: "IntegrationConfig")]
        getter integration_config : Types::IntegrationConfig?

        # The ARN of a KMS key used for encrypting the channel.

        @[JSON::Field(key: "KmsKeyId")]
        getter kms_key_id : String?

        # Metadata assigned to the resource consisting of a list of key-value pairs.

        @[JSON::Field(key: "Tags")]
        getter tags : Array(Types::Tag)?

        def initialize(
          @create_time : Time,
          @integration_arn : String,
          @integration_name : String,
          @source_arn : String,
          @status : String,
          @target_arn : String,
          @additional_encryption_context : Hash(String, String)? = nil,
          @data_filter : String? = nil,
          @description : String? = nil,
          @errors : Array(Types::IntegrationError)? = nil,
          @integration_config : Types::IntegrationConfig? = nil,
          @kms_key_id : String? = nil,
          @tags : Array(Types::Tag)? = nil
        )
        end
      end

      # Properties associated with the integration.

      struct IntegrationConfig
        include JSON::Serializable

        # Enables continuous synchronization for on-demand data extractions from SaaS applications to Amazon
        # Web Services data services like Amazon Redshift and Amazon S3.

        @[JSON::Field(key: "ContinuousSync")]
        getter continuous_sync : Bool?

        # Specifies the frequency at which CDC (Change Data Capture) pulls or incremental loads should occur.
        # This parameter provides flexibility to align the refresh rate with your specific data update
        # patterns, system load considerations, and performance optimization goals. Time increment can be set
        # from 15 minutes to 8640 minutes (six days).

        @[JSON::Field(key: "RefreshInterval")]
        getter refresh_interval : String?

        # A collection of key-value pairs that specify additional properties for the integration source. These
        # properties provide configuration options that can be used to customize the behavior of the ODB
        # source during data integration operations.

        @[JSON::Field(key: "SourceProperties")]
        getter source_properties : Hash(String, String)?

        def initialize(
          @continuous_sync : Bool? = nil,
          @refresh_interval : String? = nil,
          @source_properties : Hash(String, String)? = nil
        )
        end
      end

      # The requested operation conflicts with another operation.

      struct IntegrationConflictOperationFault
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # An error associated with a zero-ETL integration.

      struct IntegrationError
        include JSON::Serializable

        # The code associated with this error.

        @[JSON::Field(key: "ErrorCode")]
        getter error_code : String?

        # A message describing the error.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        def initialize(
          @error_code : String? = nil,
          @error_message : String? = nil
        )
        end
      end

      # A filter that can be used when invoking a DescribeIntegrations request.

      struct IntegrationFilter
        include JSON::Serializable

        # The name of the filter.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # A list of filter values.

        @[JSON::Field(key: "Values")]
        getter values : Array(String)?

        def initialize(
          @name : String? = nil,
          @values : Array(String)? = nil
        )
        end
      end

      # The specified integration could not be found.

      struct IntegrationNotFoundFault
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # A structure that describes how data is partitioned on the target.

      struct IntegrationPartition
        include JSON::Serializable

        # Specifies the timestamp format of the source data. Valid values are: epoch_sec - Unix epoch
        # timestamp in seconds epoch_milli - Unix epoch timestamp in milliseconds iso - ISO 8601 formatted
        # timestamp Only specify ConversionSpec when using timestamp-based partition functions (year, month,
        # day, or hour). Glue Zero-ETL uses this parameter to correctly transform source data into timestamp
        # format before partitioning. Do not use high-cardinality columns with the identity partition
        # function. High-cardinality columns include: Primary keys Timestamp fields (such as
        # LastModifiedTimestamp , CreatedDate ) System-generated timestamps Using high-cardinality columns
        # with identity partitioning creates many small partitions, which can significantly degrade ingestion
        # performance.

        @[JSON::Field(key: "ConversionSpec")]
        getter conversion_spec : String?

        # The field name used to partition data on the target. Avoid using columns that have unique values for
        # each row (for example, `LastModifiedTimestamp`, `SystemModTimeStamp`) as the partition column. These
        # columns are not suitable for partitioning because they create a large number of small partitions,
        # which can lead to performance issues.

        @[JSON::Field(key: "FieldName")]
        getter field_name : String?

        # Specifies the function used to partition data on the target. The accepted values for this parameter
        # are: identity - Uses source values directly without transformation year - Extracts the year from
        # timestamp values (e.g., 2023) month - Extracts the month from timestamp values (e.g., 2023-01) day -
        # Extracts the day from timestamp values (e.g., 2023-01-15) hour - Extracts the hour from timestamp
        # values (e.g., 2023-01-15-14)

        @[JSON::Field(key: "FunctionSpec")]
        getter function_spec : String?

        def initialize(
          @conversion_spec : String? = nil,
          @field_name : String? = nil,
          @function_spec : String? = nil
        )
        end
      end

      # The data processed through your integration exceeded your quota.

      struct IntegrationQuotaExceededFault
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # A structure representing an integration resource property.

      struct IntegrationResourceProperty
        include JSON::Serializable

        # The connection ARN of the source, or the database ARN of the target.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        # The resource ARN created through this create API. The format is something like
        # arn:aws:glue:&lt;region&gt;:&lt;account_id&gt;:integrationresourceproperty/*

        @[JSON::Field(key: "ResourcePropertyArn")]
        getter resource_property_arn : String?

        # The resource properties associated with the integration source.

        @[JSON::Field(key: "SourceProcessingProperties")]
        getter source_processing_properties : Types::SourceProcessingProperties?

        # The resource properties associated with the integration target.

        @[JSON::Field(key: "TargetProcessingProperties")]
        getter target_processing_properties : Types::TargetProcessingProperties?

        def initialize(
          @resource_arn : String,
          @resource_property_arn : String? = nil,
          @source_processing_properties : Types::SourceProcessingProperties? = nil,
          @target_processing_properties : Types::TargetProcessingProperties? = nil
        )
        end
      end

      # A filter for integration resource properties.

      struct IntegrationResourcePropertyFilter
        include JSON::Serializable

        # The name of the filter. Supported filter keys are SourceArn and TargetArn .

        @[JSON::Field(key: "Name")]
        getter name : String?

        # A list of filter values.

        @[JSON::Field(key: "Values")]
        getter values : Array(String)?

        def initialize(
          @name : String? = nil,
          @values : Array(String)? = nil
        )
        end
      end

      # An internal server error occurred.

      struct InternalServerException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # An internal service error occurred.

      struct InternalServiceException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The input provided was not valid.

      struct InvalidInputException
        include JSON::Serializable

        # Indicates whether or not the exception relates to a federated source.

        @[JSON::Field(key: "FromFederationSource")]
        getter from_federation_source : Bool?

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @from_federation_source : Bool? = nil,
          @message : String? = nil
        )
        end
      end

      # The integration is in an invalid state.

      struct InvalidIntegrationStateFault
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # An error that indicates your data is in an invalid state.

      struct InvalidStateException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Additional connection options for the connector.

      struct JDBCConnectorOptions
        include JSON::Serializable

        # Custom data type mapping that builds a mapping from a JDBC data type to an Glue data type. For
        # example, the option "dataTypeMapping":{"FLOAT":"STRING"} maps data fields of JDBC type FLOAT into
        # the Java String type by calling the ResultSet.getString() method of the driver, and uses it to build
        # the Glue record. The ResultSet object is implemented by each driver, so the behavior is specific to
        # the driver you use. Refer to the documentation for your JDBC driver to understand how the driver
        # performs the conversions.

        @[JSON::Field(key: "DataTypeMapping")]
        getter data_type_mapping : Hash(String, String)?

        # Extra condition clause to filter data from source. For example: BillingCity='Mountain View' When
        # using a query instead of a table name, you should validate that the query works with the specified
        # filterPredicate .

        @[JSON::Field(key: "FilterPredicate")]
        getter filter_predicate : String?

        # The name of the job bookmark keys on which to sort.

        @[JSON::Field(key: "JobBookmarkKeys")]
        getter job_bookmark_keys : Array(String)?

        # Specifies an ascending or descending sort order.

        @[JSON::Field(key: "JobBookmarkKeysSortOrder")]
        getter job_bookmark_keys_sort_order : String?

        # The minimum value of partitionColumn that is used to decide partition stride.

        @[JSON::Field(key: "LowerBound")]
        getter lower_bound : Int64?

        # The number of partitions. This value, along with lowerBound (inclusive) and upperBound (exclusive),
        # form partition strides for generated WHERE clause expressions that are used to split the
        # partitionColumn .

        @[JSON::Field(key: "NumPartitions")]
        getter num_partitions : Int64?

        # The name of an integer column that is used for partitioning. This option works only when it's
        # included with lowerBound , upperBound , and numPartitions . This option works the same way as in the
        # Spark SQL JDBC reader.

        @[JSON::Field(key: "PartitionColumn")]
        getter partition_column : String?

        # The maximum value of partitionColumn that is used to decide partition stride.

        @[JSON::Field(key: "UpperBound")]
        getter upper_bound : Int64?

        def initialize(
          @data_type_mapping : Hash(String, String)? = nil,
          @filter_predicate : String? = nil,
          @job_bookmark_keys : Array(String)? = nil,
          @job_bookmark_keys_sort_order : String? = nil,
          @lower_bound : Int64? = nil,
          @num_partitions : Int64? = nil,
          @partition_column : String? = nil,
          @upper_bound : Int64? = nil
        )
        end
      end

      # Specifies a connector to a JDBC data source.

      struct JDBCConnectorSource
        include JSON::Serializable

        # The name of the connection that is associated with the connector.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String

        # The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC
        # data store.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        # The name of a connector that assists with accessing the data store in Glue Studio.

        @[JSON::Field(key: "ConnectorName")]
        getter connector_name : String

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Additional connection options for the connector.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Types::JDBCConnectorOptions?

        # The name of the table in the data source.

        @[JSON::Field(key: "ConnectionTable")]
        getter connection_table : String?

        # Specifies the data schema for the custom JDBC source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # The table or SQL query to get the data from. You can specify either ConnectionTable or query , but
        # not both.

        @[JSON::Field(key: "Query")]
        getter query : String?

        def initialize(
          @connection_name : String,
          @connection_type : String,
          @connector_name : String,
          @name : String,
          @additional_options : Types::JDBCConnectorOptions? = nil,
          @connection_table : String? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @query : String? = nil
        )
        end
      end

      # Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.

      struct JDBCConnectorTarget
        include JSON::Serializable

        # The name of the connection that is associated with the connector.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String

        # The name of the table in the data target.

        @[JSON::Field(key: "ConnectionTable")]
        getter connection_table : String

        # The type of connection, such as marketplace.jdbc or custom.jdbc, designating a connection to a JDBC
        # data target.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        # The name of a connector that will be used.

        @[JSON::Field(key: "ConnectorName")]
        getter connector_name : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Additional connection options for the connector.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?

        # Specifies the data schema for the JDBC target.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @connection_name : String,
          @connection_table : String,
          @connection_type : String,
          @connector_name : String,
          @inputs : Array(String),
          @name : String,
          @additional_options : Hash(String, String)? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies a JDBC data store to crawl.

      struct JdbcTarget
        include JSON::Serializable

        # The name of the connection to use to connect to the JDBC target.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # Specify a value of RAWTYPES or COMMENTS to enable additional metadata in table responses. RAWTYPES
        # provides the native-level datatype. COMMENTS provides comments associated with a column or table in
        # the database. If you do not need additional metadata, keep the field empty.

        @[JSON::Field(key: "EnableAdditionalMetadata")]
        getter enable_additional_metadata : Array(String)?

        # A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables
        # with a Crawler .

        @[JSON::Field(key: "Exclusions")]
        getter exclusions : Array(String)?

        # The path of the JDBC target.

        @[JSON::Field(key: "Path")]
        getter path : String?

        def initialize(
          @connection_name : String? = nil,
          @enable_additional_metadata : Array(String)? = nil,
          @exclusions : Array(String)? = nil,
          @path : String? = nil
        )
        end
      end

      # Specifies a job definition.

      struct Job
        include JSON::Serializable

        # This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs)
        # allocated to runs of this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a
        # relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of
        # memory. For more information, see the Glue pricing page .

        @[JSON::Field(key: "AllocatedCapacity")]
        getter allocated_capacity : Int32?

        # The representation of a directed acyclic graph on which both the Glue Studio visual component and
        # Glue Studio code generation is based.

        @[JSON::Field(key: "CodeGenConfigurationNodes")]
        getter code_gen_configuration_nodes : Hash(String, Types::CodeGenConfigurationNode)?

        # The JobCommand that runs this job.

        @[JSON::Field(key: "Command")]
        getter command : Types::JobCommand?

        # The connections used for this job.

        @[JSON::Field(key: "Connections")]
        getter connections : Types::ConnectionsList?

        # The time and date that this job definition was created.

        @[JSON::Field(key: "CreatedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_on : Time?

        # The default arguments for every run of this job, specified as name-value pairs. You can specify
        # arguments here that your own job-execution script consumes, as well as arguments that Glue itself
        # consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets
        # from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep
        # them within the Job. For information about how to specify and consume your own Job arguments, see
        # the Calling Glue APIs in Python topic in the developer guide. For information about the arguments
        # you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue
        # topic in the developer guide. For information about the arguments you can provide to this field when
        # configuring Ray jobs, see Using job parameters in Ray jobs in the developer guide.

        @[JSON::Field(key: "DefaultArguments")]
        getter default_arguments : Hash(String, String)?

        # A description of the job.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Indicates whether the job is run with a standard or flexible execution class. The standard execution
        # class is ideal for time-sensitive workloads that require fast job startup and dedicated resources.
        # The flexible execution class is appropriate for time-insensitive jobs whose start and completion
        # times may vary. Only jobs with Glue version 3.0 and above and command type glueetl will be allowed
        # to set ExecutionClass to FLEX . The flexible execution class is available for Spark jobs.

        @[JSON::Field(key: "ExecutionClass")]
        getter execution_class : String?

        # An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.

        @[JSON::Field(key: "ExecutionProperty")]
        getter execution_property : Types::ExecutionProperty?

        # In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in
        # a job. The Python version indicates the version supported for jobs of type Spark. Ray jobs should
        # set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries
        # available in your Ray job are determined by the Runtime parameter of the Job command. For more
        # information about the available Glue versions and corresponding Spark and Python versions, see Glue
        # version in the developer guide. Jobs that are created without specifying a Glue version default to
        # Glue 0.9.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # A mode that describes how a job was created. Valid values are: SCRIPT - The job was created using
        # the Glue Studio script editor. VISUAL - The job was created using the Glue Studio visual editor.
        # NOTEBOOK - The job was created using an interactive sessions notebook. When the JobMode field is
        # missing or null, SCRIPT is assigned as the default value.

        @[JSON::Field(key: "JobMode")]
        getter job_mode : String?

        # Specifies whether job run queuing is enabled for the job runs for this job. A value of true means
        # job run queuing is enabled for the job runs. If false or not populated, the job runs will not be
        # considered for queueing. If this field does not match the value set in the job run, then the value
        # from the job run field will be used.

        @[JSON::Field(key: "JobRunQueuingEnabled")]
        getter job_run_queuing_enabled : Bool?

        # The last point in time when this job definition was modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # This field is reserved for future use.

        @[JSON::Field(key: "LogUri")]
        getter log_uri : String?

        # This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue
        # periodically performs maintenance activities. During these maintenance windows, Glue will need to
        # restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance
        # window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will
        # be restarted between 10:00AM GMT to 1:00PM GMT.

        @[JSON::Field(key: "MaintenanceWindow")]
        getter maintenance_window : String?

        # For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data
        # processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of
        # processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
        # information, see the Glue pricing page . For Glue version 2.0 or later jobs, you cannot specify a
        # Maximum capacity . Instead, you should specify a Worker type and the Number of workers . Do not set
        # MaxCapacity if using WorkerType and NumberOfWorkers . The value that can be allocated for
        # MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an
        # Apache Spark streaming ETL job: When you specify a Python shell job ( JobCommand.Name
        # ="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. When you
        # specify an Apache Spark ETL job ( JobCommand.Name ="glueetl") or Apache Spark streaming ETL job (
        # JobCommand.Name ="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This
        # job type cannot have a fractional DPU allocation.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # The maximum number of times to retry this job after a JobRun fails.

        @[JSON::Field(key: "MaxRetries")]
        getter max_retries : Int32?

        # The name you assign to this job definition.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # Arguments for this job that are not overridden when providing job arguments in a job run, specified
        # as name-value pairs.

        @[JSON::Field(key: "NonOverridableArguments")]
        getter non_overridable_arguments : Hash(String, String)?

        # Specifies configuration properties of a job notification.

        @[JSON::Field(key: "NotificationProperty")]
        getter notification_property : Types::NotificationProperty?

        # The number of workers of a defined workerType that are allocated when a job runs.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The name of an Glue usage profile associated with the job.

        @[JSON::Field(key: "ProfileName")]
        getter profile_name : String?

        # The name or Amazon Resource Name (ARN) of the IAM role associated with this job.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # The name of the SecurityConfiguration structure to be used with this job.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The details for a source control configuration for a job, allowing synchronization of job artifacts
        # to or from a remote repository.

        @[JSON::Field(key: "SourceControlDetails")]
        getter source_control_details : Types::SourceControlDetails?

        # The job timeout in minutes. This is the maximum time that a job run can consume resources before it
        # is terminated and enters TIMEOUT status. Jobs must have timeout values less than 7 days or 10080
        # minutes. Otherwise, the jobs will throw an exception. When the value is left blank, the timeout is
        # defaulted to 2880 minutes. Any existing Glue jobs that had a timeout value greater than 7 days will
        # be defaulted to 7 days. For instance if you have specified a timeout of 20 days for a batch job, it
        # will be stopped on the 7th day. For streaming jobs, if you have set up a maintenance window, it will
        # be restarted during the maintenance window after 7 days.

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        # The type of predefined worker that is allocated when a job runs. Glue provides multiple worker types
        # to accommodate different workload requirements: G Worker Types (General-purpose compute workers):
        # G.1X: 1 DPU (4 vCPUs, 16 GB memory, 94GB disk) G.2X: 2 DPU (8 vCPUs, 32 GB memory, 138GB disk) G.4X:
        # 4 DPU (16 vCPUs, 64 GB memory, 256GB disk) G.8X: 8 DPU (32 vCPUs, 128 GB memory, 512GB disk) G.12X:
        # 12 DPU (48 vCPUs, 192 GB memory, 768GB disk) G.16X: 16 DPU (64 vCPUs, 256 GB memory, 1024GB disk) R
        # Worker Types (Memory-optimized workers): R.1X: 1 M-DPU (4 vCPUs, 32 GB memory) R.2X: 2 M-DPU (8
        # vCPUs, 64 GB memory) R.4X: 4 M-DPU (16 vCPUs, 128 GB memory) R.8X: 8 M-DPU (32 vCPUs, 256 GB memory)

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @allocated_capacity : Int32? = nil,
          @code_gen_configuration_nodes : Hash(String, Types::CodeGenConfigurationNode)? = nil,
          @command : Types::JobCommand? = nil,
          @connections : Types::ConnectionsList? = nil,
          @created_on : Time? = nil,
          @default_arguments : Hash(String, String)? = nil,
          @description : String? = nil,
          @execution_class : String? = nil,
          @execution_property : Types::ExecutionProperty? = nil,
          @glue_version : String? = nil,
          @job_mode : String? = nil,
          @job_run_queuing_enabled : Bool? = nil,
          @last_modified_on : Time? = nil,
          @log_uri : String? = nil,
          @maintenance_window : String? = nil,
          @max_capacity : Float64? = nil,
          @max_retries : Int32? = nil,
          @name : String? = nil,
          @non_overridable_arguments : Hash(String, String)? = nil,
          @notification_property : Types::NotificationProperty? = nil,
          @number_of_workers : Int32? = nil,
          @profile_name : String? = nil,
          @role : String? = nil,
          @security_configuration : String? = nil,
          @source_control_details : Types::SourceControlDetails? = nil,
          @timeout : Int32? = nil,
          @worker_type : String? = nil
        )
        end
      end

      # Defines a point that a job can resume processing.

      struct JobBookmarkEntry
        include JSON::Serializable

        # The attempt ID number.

        @[JSON::Field(key: "Attempt")]
        getter attempt : Int32?

        # The bookmark itself.

        @[JSON::Field(key: "JobBookmark")]
        getter job_bookmark : String?

        # The name of the job in question.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # The unique run identifier associated with the previous job run.

        @[JSON::Field(key: "PreviousRunId")]
        getter previous_run_id : String?

        # The run ID number.

        @[JSON::Field(key: "Run")]
        getter run : Int32?

        # The run ID number.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        # The version of the job.

        @[JSON::Field(key: "Version")]
        getter version : Int32?

        def initialize(
          @attempt : Int32? = nil,
          @job_bookmark : String? = nil,
          @job_name : String? = nil,
          @previous_run_id : String? = nil,
          @run : Int32? = nil,
          @run_id : String? = nil,
          @version : Int32? = nil
        )
        end
      end

      # Specifies how job bookmark data should be encrypted.

      struct JobBookmarksEncryption
        include JSON::Serializable

        # The encryption mode to use for job bookmarks data.

        @[JSON::Field(key: "JobBookmarksEncryptionMode")]
        getter job_bookmarks_encryption_mode : String?

        # The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.

        @[JSON::Field(key: "KmsKeyArn")]
        getter kms_key_arn : String?

        def initialize(
          @job_bookmarks_encryption_mode : String? = nil,
          @kms_key_arn : String? = nil
        )
        end
      end

      # Specifies code that runs when a job is run.

      struct JobCommand
        include JSON::Serializable

        # The name of the job command. For an Apache Spark ETL job, this must be glueetl . For a Python shell
        # job, it must be pythonshell . For an Apache Spark streaming ETL job, this must be gluestreaming .
        # For a Ray job, this must be glueray .

        @[JSON::Field(key: "Name")]
        getter name : String?

        # The Python version being used to run a Python shell job. Allowed values are 2 or 3.

        @[JSON::Field(key: "PythonVersion")]
        getter python_version : String?

        # In Ray jobs, Runtime is used to specify the versions of Ray, Python and additional libraries
        # available in your environment. This field is not used in other job types. For supported runtime
        # environment values, see Supported Ray runtime environments in the Glue Developer Guide.

        @[JSON::Field(key: "Runtime")]
        getter runtime : String?

        # Specifies the Amazon Simple Storage Service (Amazon S3) path to a script that runs a job.

        @[JSON::Field(key: "ScriptLocation")]
        getter script_location : String?

        def initialize(
          @name : String? = nil,
          @python_version : String? = nil,
          @runtime : String? = nil,
          @script_location : String? = nil
        )
        end
      end

      # The details of a Job node present in the workflow.

      struct JobNodeDetails
        include JSON::Serializable

        # The information for the job runs represented by the job node.

        @[JSON::Field(key: "JobRuns")]
        getter job_runs : Array(Types::JobRun)?

        def initialize(
          @job_runs : Array(Types::JobRun)? = nil
        )
        end
      end

      # Contains information about a job run.

      struct JobRun
        include JSON::Serializable

        # This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs)
        # allocated to this JobRun. From 2 to 100 DPUs can be allocated; the default is 10. A DPU is a
        # relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of
        # memory. For more information, see the Glue pricing page .

        @[JSON::Field(key: "AllocatedCapacity")]
        getter allocated_capacity : Int32?

        # The job arguments associated with this run. For this job run, they replace the default arguments set
        # in the job definition itself. You can specify arguments here that your own job-execution script
        # consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass
        # plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other
        # secret management mechanism if you intend to keep them within the Job. For information about how to
        # specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the
        # developer guide. For information about the arguments you can provide to this field when configuring
        # Spark jobs, see the Special Parameters Used by Glue topic in the developer guide. For information
        # about the arguments you can provide to this field when configuring Ray jobs, see Using job
        # parameters in Ray jobs in the developer guide.

        @[JSON::Field(key: "Arguments")]
        getter arguments : Hash(String, String)?

        # The number of the attempt to run this job.

        @[JSON::Field(key: "Attempt")]
        getter attempt : Int32?

        # The date and time that this job run completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # This field can be set for either job runs with execution class FLEX or when Auto Scaling is enabled,
        # and represents the total time each executor ran during the lifecycle of a job run in seconds,
        # multiplied by a DPU factor (1 for G.1X , 2 for G.2X , or 0.25 for G.025X workers). This value may be
        # different than the executionEngineRuntime * MaxCapacity as in the case of Auto Scaling jobs, as the
        # number of executors running at a given time may be less than the MaxCapacity . Therefore, it is
        # possible that the value of DPUSeconds is less than executionEngineRuntime * MaxCapacity .

        @[JSON::Field(key: "DPUSeconds")]
        getter dpu_seconds : Float64?

        # An error message associated with this job run.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # Indicates whether the job is run with a standard or flexible execution class. The standard
        # execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated
        # resources. The flexible execution class is appropriate for time-insensitive jobs whose start and
        # completion times may vary. Only jobs with Glue version 3.0 and above and command type glueetl will
        # be allowed to set ExecutionClass to FLEX . The flexible execution class is available for Spark jobs.

        @[JSON::Field(key: "ExecutionClass")]
        getter execution_class : String?

        # This inline session policy to the StartJobRun API allows you to dynamically restrict the permissions
        # of the specified execution role for the scope of the job, without requiring the creation of
        # additional IAM roles.

        @[JSON::Field(key: "ExecutionRoleSessionPolicy")]
        getter execution_role_session_policy : String?

        # The amount of time (in seconds) that the job run consumed resources.

        @[JSON::Field(key: "ExecutionTime")]
        getter execution_time : Int32?

        # In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in
        # a job. The Python version indicates the version supported for jobs of type Spark. Ray jobs should
        # set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries
        # available in your Ray job are determined by the Runtime parameter of the Job command. For more
        # information about the available Glue versions and corresponding Spark and Python versions, see Glue
        # version in the developer guide. Jobs that are created without specifying a Glue version default to
        # Glue 0.9.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # The ID of this job run.

        @[JSON::Field(key: "Id")]
        getter id : String?

        # A mode that describes how a job was created. Valid values are: SCRIPT - The job was created using
        # the Glue Studio script editor. VISUAL - The job was created using the Glue Studio visual editor.
        # NOTEBOOK - The job was created using an interactive sessions notebook. When the JobMode field is
        # missing or null, SCRIPT is assigned as the default value.

        @[JSON::Field(key: "JobMode")]
        getter job_mode : String?

        # The name of the job definition being used in this run.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # Specifies whether job run queuing is enabled for the job run. A value of true means job run queuing
        # is enabled for the job run. If false or not populated, the job run will not be considered for
        # queueing.

        @[JSON::Field(key: "JobRunQueuingEnabled")]
        getter job_run_queuing_enabled : Bool?

        # The current state of the job run. For more information about the statuses of jobs that have
        # terminated abnormally, see Glue Job Run Statuses .

        @[JSON::Field(key: "JobRunState")]
        getter job_run_state : String?

        # The last time that this job run was modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The name of the log group for secure logging that can be server-side encrypted in Amazon CloudWatch
        # using KMS. This name can be /aws-glue/jobs/ , in which case the default encryption is NONE . If you
        # add a role name and SecurityConfiguration name (in other words,
        # /aws-glue/jobs-yourRoleName-yourSecurityConfigurationName/ ), then that security configuration is
        # used to encrypt the log group.

        @[JSON::Field(key: "LogGroupName")]
        getter log_group_name : String?

        # This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue
        # periodically performs maintenance activities. During these maintenance windows, Glue will need to
        # restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance
        # window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will
        # be restarted between 10:00AM GMT to 1:00PM GMT.

        @[JSON::Field(key: "MaintenanceWindow")]
        getter maintenance_window : String?

        # For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data
        # processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of
        # processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
        # information, see the Glue pricing page . For Glue version 2.0+ jobs, you cannot specify a Maximum
        # capacity . Instead, you should specify a Worker type and the Number of workers . Do not set
        # MaxCapacity if using WorkerType and NumberOfWorkers . The value that can be allocated for
        # MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an
        # Apache Spark streaming ETL job: When you specify a Python shell job ( JobCommand.Name
        # ="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. When you
        # specify an Apache Spark ETL job ( JobCommand.Name ="glueetl") or Apache Spark streaming ETL job (
        # JobCommand.Name ="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This
        # job type cannot have a fractional DPU allocation.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # Specifies configuration properties of a job run notification.

        @[JSON::Field(key: "NotificationProperty")]
        getter notification_property : Types::NotificationProperty?

        # The number of workers of a defined workerType that are allocated when a job runs.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # A list of predecessors to this job run.

        @[JSON::Field(key: "PredecessorRuns")]
        getter predecessor_runs : Array(Types::Predecessor)?

        # The ID of the previous run of this job. For example, the JobRunId specified in the StartJobRun
        # action.

        @[JSON::Field(key: "PreviousRunId")]
        getter previous_run_id : String?

        # The name of an Glue usage profile associated with the job run.

        @[JSON::Field(key: "ProfileName")]
        getter profile_name : String?

        # The name of the SecurityConfiguration structure to be used with this job run.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The date and time at which this job run was started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # This field holds details that pertain to the state of a job run. The field is nullable. For example,
        # when a job run is in a WAITING state as a result of job run queuing, the field has the reason why
        # the job run is in that state.

        @[JSON::Field(key: "StateDetail")]
        getter state_detail : String?

        # The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before
        # it is terminated and enters TIMEOUT status. This value overrides the timeout value set in the parent
        # job. Jobs must have timeout values less than 7 days or 10080 minutes. Otherwise, the jobs will throw
        # an exception. When the value is left blank, the timeout is defaulted to 2880 minutes. Any existing
        # Glue jobs that had a timeout value greater than 7 days will be defaulted to 7 days. For instance if
        # you have specified a timeout of 20 days for a batch job, it will be stopped on the 7th day. For
        # streaming jobs, if you have set up a maintenance window, it will be restarted during the maintenance
        # window after 7 days.

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        # The name of the trigger that started this job run.

        @[JSON::Field(key: "TriggerName")]
        getter trigger_name : String?

        # The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X,
        # G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs. For the G.1X worker type,
        # each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 94GB disk, and provides 1 executor per
        # worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to
        # offers a scalable and cost effective way to run most jobs. For the G.2X worker type, each worker
        # maps to 2 DPU (8 vCPUs, 32 GB of memory) with 138GB disk, and provides 1 executor per worker. We
        # recommend this worker type for workloads such as data transforms, joins, and queries, to offers a
        # scalable and cost effective way to run most jobs. For the G.4X worker type, each worker maps to 4
        # DPU (16 vCPUs, 64 GB of memory) with 256GB disk, and provides 1 executor per worker. We recommend
        # this worker type for jobs whose workloads contain your most demanding transforms, aggregations,
        # joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs
        # in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West
        # (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central),
        # Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm). For the G.8X worker type, each worker
        # maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk, and provides 1 executor per worker. We
        # recommend this worker type for jobs whose workloads contain your most demanding transforms,
        # aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later
        # Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type. For
        # the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk, and
        # provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This
        # worker type is only available for Glue version 3.0 or later streaming jobs. For the Z.2X worker
        # type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk, and provides up to 8
        # Ray workers based on the autoscaler.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @allocated_capacity : Int32? = nil,
          @arguments : Hash(String, String)? = nil,
          @attempt : Int32? = nil,
          @completed_on : Time? = nil,
          @dpu_seconds : Float64? = nil,
          @error_message : String? = nil,
          @execution_class : String? = nil,
          @execution_role_session_policy : String? = nil,
          @execution_time : Int32? = nil,
          @glue_version : String? = nil,
          @id : String? = nil,
          @job_mode : String? = nil,
          @job_name : String? = nil,
          @job_run_queuing_enabled : Bool? = nil,
          @job_run_state : String? = nil,
          @last_modified_on : Time? = nil,
          @log_group_name : String? = nil,
          @maintenance_window : String? = nil,
          @max_capacity : Float64? = nil,
          @notification_property : Types::NotificationProperty? = nil,
          @number_of_workers : Int32? = nil,
          @predecessor_runs : Array(Types::Predecessor)? = nil,
          @previous_run_id : String? = nil,
          @profile_name : String? = nil,
          @security_configuration : String? = nil,
          @started_on : Time? = nil,
          @state_detail : String? = nil,
          @timeout : Int32? = nil,
          @trigger_name : String? = nil,
          @worker_type : String? = nil
        )
        end
      end

      # Specifies information used to update an existing job definition. The previous job definition is
      # completely overwritten by this information.

      struct JobUpdate
        include JSON::Serializable

        # This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs)
        # to allocate to this job. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a
        # relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of
        # memory. For more information, see the Glue pricing page .

        @[JSON::Field(key: "AllocatedCapacity")]
        getter allocated_capacity : Int32?

        # The representation of a directed acyclic graph on which both the Glue Studio visual component and
        # Glue Studio code generation is based.

        @[JSON::Field(key: "CodeGenConfigurationNodes")]
        getter code_gen_configuration_nodes : Hash(String, Types::CodeGenConfigurationNode)?

        # The JobCommand that runs this job (required).

        @[JSON::Field(key: "Command")]
        getter command : Types::JobCommand?

        # The connections used for this job.

        @[JSON::Field(key: "Connections")]
        getter connections : Types::ConnectionsList?

        # The default arguments for every run of this job, specified as name-value pairs. You can specify
        # arguments here that your own job-execution script consumes, as well as arguments that Glue itself
        # consumes. Job arguments may be logged. Do not pass plaintext secrets as arguments. Retrieve secrets
        # from a Glue Connection, Secrets Manager or other secret management mechanism if you intend to keep
        # them within the Job. For information about how to specify and consume your own Job arguments, see
        # the Calling Glue APIs in Python topic in the developer guide. For information about the arguments
        # you can provide to this field when configuring Spark jobs, see the Special Parameters Used by Glue
        # topic in the developer guide. For information about the arguments you can provide to this field when
        # configuring Ray jobs, see Using job parameters in Ray jobs in the developer guide.

        @[JSON::Field(key: "DefaultArguments")]
        getter default_arguments : Hash(String, String)?

        # Description of the job being defined.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Indicates whether the job is run with a standard or flexible execution class. The standard
        # execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated
        # resources. The flexible execution class is appropriate for time-insensitive jobs whose start and
        # completion times may vary. Only jobs with Glue version 3.0 and above and command type glueetl will
        # be allowed to set ExecutionClass to FLEX . The flexible execution class is available for Spark jobs.

        @[JSON::Field(key: "ExecutionClass")]
        getter execution_class : String?

        # An ExecutionProperty specifying the maximum number of concurrent runs allowed for this job.

        @[JSON::Field(key: "ExecutionProperty")]
        getter execution_property : Types::ExecutionProperty?

        # In Spark jobs, GlueVersion determines the versions of Apache Spark and Python that Glue available in
        # a job. The Python version indicates the version supported for jobs of type Spark. Ray jobs should
        # set GlueVersion to 4.0 or greater. However, the versions of Ray, Python and additional libraries
        # available in your Ray job are determined by the Runtime parameter of the Job command. For more
        # information about the available Glue versions and corresponding Spark and Python versions, see Glue
        # version in the developer guide. Jobs that are created without specifying a Glue version default to
        # Glue 0.9.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # A mode that describes how a job was created. Valid values are: SCRIPT - The job was created using
        # the Glue Studio script editor. VISUAL - The job was created using the Glue Studio visual editor.
        # NOTEBOOK - The job was created using an interactive sessions notebook. When the JobMode field is
        # missing or null, SCRIPT is assigned as the default value.

        @[JSON::Field(key: "JobMode")]
        getter job_mode : String?

        # Specifies whether job run queuing is enabled for the job runs for this job. A value of true means
        # job run queuing is enabled for the job runs. If false or not populated, the job runs will not be
        # considered for queueing. If this field does not match the value set in the job run, then the value
        # from the job run field will be used.

        @[JSON::Field(key: "JobRunQueuingEnabled")]
        getter job_run_queuing_enabled : Bool?

        # This field is reserved for future use.

        @[JSON::Field(key: "LogUri")]
        getter log_uri : String?

        # This field specifies a day of the week and hour for a maintenance window for streaming jobs. Glue
        # periodically performs maintenance activities. During these maintenance windows, Glue will need to
        # restart your streaming jobs. Glue will restart the job within 3 hours of the specified maintenance
        # window. For instance, if you set up the maintenance window for Monday at 10:00AM GMT, your jobs will
        # be restarted between 10:00AM GMT to 1:00PM GMT.

        @[JSON::Field(key: "MaintenanceWindow")]
        getter maintenance_window : String?

        # For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data
        # processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of
        # processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
        # information, see the Glue pricing page . For Glue version 2.0+ jobs, you cannot specify a Maximum
        # capacity . Instead, you should specify a Worker type and the Number of workers . Do not set
        # MaxCapacity if using WorkerType and NumberOfWorkers . The value that can be allocated for
        # MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an
        # Apache Spark streaming ETL job: When you specify a Python shell job ( JobCommand.Name
        # ="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. When you
        # specify an Apache Spark ETL job ( JobCommand.Name ="glueetl") or Apache Spark streaming ETL job (
        # JobCommand.Name ="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This
        # job type cannot have a fractional DPU allocation.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # The maximum number of times to retry this job if it fails.

        @[JSON::Field(key: "MaxRetries")]
        getter max_retries : Int32?

        # Arguments for this job that are not overridden when providing job arguments in a job run, specified
        # as name-value pairs.

        @[JSON::Field(key: "NonOverridableArguments")]
        getter non_overridable_arguments : Hash(String, String)?

        # Specifies the configuration properties of a job notification.

        @[JSON::Field(key: "NotificationProperty")]
        getter notification_property : Types::NotificationProperty?

        # The number of workers of a defined workerType that are allocated when a job runs.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The name or Amazon Resource Name (ARN) of the IAM role associated with this job (required).

        @[JSON::Field(key: "Role")]
        getter role : String?

        # The name of the SecurityConfiguration structure to be used with this job.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The details for a source control configuration for a job, allowing synchronization of job artifacts
        # to or from a remote repository.

        @[JSON::Field(key: "SourceControlDetails")]
        getter source_control_details : Types::SourceControlDetails?

        # The job timeout in minutes. This is the maximum time that a job run can consume resources before it
        # is terminated and enters TIMEOUT status. Jobs must have timeout values less than 7 days or 10080
        # minutes. Otherwise, the jobs will throw an exception. When the value is left blank, the timeout is
        # defaulted to 2880 minutes. Any existing Glue jobs that had a timeout value greater than 7 days will
        # be defaulted to 7 days. For instance if you have specified a timeout of 20 days for a batch job, it
        # will be stopped on the 7th day. For streaming jobs, if you have set up a maintenance window, it will
        # be restarted during the maintenance window after 7 days.

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        # The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X,
        # G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs. For more information, see
        # Defining job properties for Spark jobs

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @allocated_capacity : Int32? = nil,
          @code_gen_configuration_nodes : Hash(String, Types::CodeGenConfigurationNode)? = nil,
          @command : Types::JobCommand? = nil,
          @connections : Types::ConnectionsList? = nil,
          @default_arguments : Hash(String, String)? = nil,
          @description : String? = nil,
          @execution_class : String? = nil,
          @execution_property : Types::ExecutionProperty? = nil,
          @glue_version : String? = nil,
          @job_mode : String? = nil,
          @job_run_queuing_enabled : Bool? = nil,
          @log_uri : String? = nil,
          @maintenance_window : String? = nil,
          @max_capacity : Float64? = nil,
          @max_retries : Int32? = nil,
          @non_overridable_arguments : Hash(String, String)? = nil,
          @notification_property : Types::NotificationProperty? = nil,
          @number_of_workers : Int32? = nil,
          @role : String? = nil,
          @security_configuration : String? = nil,
          @source_control_details : Types::SourceControlDetails? = nil,
          @timeout : Int32? = nil,
          @worker_type : String? = nil
        )
        end
      end

      # Specifies a transform that joins two datasets into one dataset using a comparison phrase on the
      # specified data property keys. You can use inner, outer, left, right, left semi, and left anti joins.

      struct Join
        include JSON::Serializable

        # A list of the two columns to be joined.

        @[JSON::Field(key: "Columns")]
        getter columns : Array(Types::JoinColumn)

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # Specifies the type of join to be performed on the datasets.

        @[JSON::Field(key: "JoinType")]
        getter join_type : String

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @columns : Array(Types::JoinColumn),
          @inputs : Array(String),
          @join_type : String,
          @name : String
        )
        end
      end

      # Specifies a column to be joined.

      struct JoinColumn
        include JSON::Serializable

        # The column to be joined.

        @[JSON::Field(key: "From")]
        getter from : String

        # The key of the column to be joined.

        @[JSON::Field(key: "Keys")]
        getter keys : Array(Array(String))

        def initialize(
          @from : String,
          @keys : Array(Array(String))
        )
        end
      end

      # A classifier for JSON content.

      struct JsonClassifier
        include JSON::Serializable

        # A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of
        # JsonPath, as described in Writing JsonPath Custom Classifiers .

        @[JSON::Field(key: "JsonPath")]
        getter json_path : String

        # The name of the classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The time that this classifier was registered.

        @[JSON::Field(key: "CreationTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter creation_time : Time?

        # The time that this classifier was last updated.

        @[JSON::Field(key: "LastUpdated", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_updated : Time?

        # The version of this classifier.

        @[JSON::Field(key: "Version")]
        getter version : Int64?

        def initialize(
          @json_path : String,
          @name : String,
          @creation_time : Time? = nil,
          @last_updated : Time? = nil,
          @version : Int64? = nil
        )
        end
      end

      # The KMS key specified is not accessible.

      struct KMSKeyNotAccessibleFault
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Additional options for streaming.

      struct KafkaStreamingSourceOptions
        include JSON::Serializable

        # When this option is set to 'true', the data output will contain an additional column named
        # "__src_timestamp" that indicates the time when the corresponding record received by the topic. The
        # default value is 'false'. This option is supported in Glue version 4.0 or later.

        @[JSON::Field(key: "AddRecordTimestamp")]
        getter add_record_timestamp : String?

        # The specific TopicPartitions to consume. You must specify at least one of "topicName" , "assign" or
        # "subscribePattern" .

        @[JSON::Field(key: "Assign")]
        getter assign : String?

        # A list of bootstrap server URLs, for example, as
        # b-1.vpc-test-2.o4q88o.c6.kafka.us-east-1.amazonaws.com:9094 . This option must be specified in the
        # API call or defined in the table metadata in the Data Catalog.

        @[JSON::Field(key: "BootstrapServers")]
        getter bootstrap_servers : String?

        # An optional classification.

        @[JSON::Field(key: "Classification")]
        getter classification : String?

        # The name of the connection.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # Specifies the delimiter character.

        @[JSON::Field(key: "Delimiter")]
        getter delimiter : String?

        # When this option is set to 'true', for each batch, it will emit the metrics for the duration between
        # the oldest record received by the topic and the time it arrives in Glue to CloudWatch. The metric's
        # name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is
        # supported in Glue version 4.0 or later.

        @[JSON::Field(key: "EmitConsumerLagMetrics")]
        getter emit_consumer_lag_metrics : String?

        # The end point when a batch query is ended. Possible values are either "latest" or a JSON string that
        # specifies an ending offset for each TopicPartition .

        @[JSON::Field(key: "EndingOffsets")]
        getter ending_offsets : String?

        # Whether to include the Kafka headers. When the option is set to "true", the data output will contain
        # an additional column named "glue_streaming_kafka_headers" with type Array[Struct(key: String, value:
        # String)] . The default value is "false". This option is available in Glue version 3.0 or later only.

        @[JSON::Field(key: "IncludeHeaders")]
        getter include_headers : Bool?

        # The rate limit on the maximum number of offsets that are processed per trigger interval. The
        # specified total number of offsets is proportionally split across topicPartitions of different
        # volumes. The default value is null, which means that the consumer reads all offsets until the known
        # latest offset.

        @[JSON::Field(key: "MaxOffsetsPerTrigger")]
        getter max_offsets_per_trigger : Int64?

        # The desired minimum number of partitions to read from Kafka. The default value is null, which means
        # that the number of spark partitions is equal to the number of Kafka partitions.

        @[JSON::Field(key: "MinPartitions")]
        getter min_partitions : Int32?

        # The number of times to retry before failing to fetch Kafka offsets. The default value is 3 .

        @[JSON::Field(key: "NumRetries")]
        getter num_retries : Int32?

        # The timeout in milliseconds to poll data from Kafka in Spark job executors. The default value is 512
        # .

        @[JSON::Field(key: "PollTimeoutMs")]
        getter poll_timeout_ms : Int64?

        # The time in milliseconds to wait before retrying to fetch Kafka offsets. The default value is 10 .

        @[JSON::Field(key: "RetryIntervalMs")]
        getter retry_interval_ms : Int64?

        # The protocol used to communicate with brokers. The possible values are "SSL" or "PLAINTEXT" .

        @[JSON::Field(key: "SecurityProtocol")]
        getter security_protocol : String?

        # The starting position in the Kafka topic to read data from. The possible values are "earliest" or
        # "latest" . The default value is "latest" .

        @[JSON::Field(key: "StartingOffsets")]
        getter starting_offsets : String?

        # The timestamp of the record in the Kafka topic to start reading data from. The possible values are a
        # timestamp string in UTC format of the pattern yyyy-mm-ddTHH:MM:SSZ (where Z represents a UTC
        # timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00"). Only one of StartingTimestamp
        # or StartingOffsets must be set.

        @[JSON::Field(key: "StartingTimestamp", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter starting_timestamp : Time?

        # A Java regex string that identifies the topic list to subscribe to. You must specify at least one of
        # "topicName" , "assign" or "subscribePattern" .

        @[JSON::Field(key: "SubscribePattern")]
        getter subscribe_pattern : String?

        # The topic name as specified in Apache Kafka. You must specify at least one of "topicName" , "assign"
        # or "subscribePattern" .

        @[JSON::Field(key: "TopicName")]
        getter topic_name : String?

        def initialize(
          @add_record_timestamp : String? = nil,
          @assign : String? = nil,
          @bootstrap_servers : String? = nil,
          @classification : String? = nil,
          @connection_name : String? = nil,
          @delimiter : String? = nil,
          @emit_consumer_lag_metrics : String? = nil,
          @ending_offsets : String? = nil,
          @include_headers : Bool? = nil,
          @max_offsets_per_trigger : Int64? = nil,
          @min_partitions : Int32? = nil,
          @num_retries : Int32? = nil,
          @poll_timeout_ms : Int64? = nil,
          @retry_interval_ms : Int64? = nil,
          @security_protocol : String? = nil,
          @starting_offsets : String? = nil,
          @starting_timestamp : Time? = nil,
          @subscribe_pattern : String? = nil,
          @topic_name : String? = nil
        )
        end
      end

      # A partition key pair consisting of a name and a type.

      struct KeySchemaElement
        include JSON::Serializable

        # The name of a partition key.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The type of a partition key.

        @[JSON::Field(key: "Type")]
        getter type : String

        def initialize(
          @name : String,
          @type : String
        )
        end
      end

      # Additional options for the Amazon Kinesis streaming data source.

      struct KinesisStreamingSourceOptions
        include JSON::Serializable

        # Adds a time delay between two consecutive getRecords operations. The default value is "False" . This
        # option is only configurable for Glue version 2.0 and above.

        @[JSON::Field(key: "AddIdleTimeBetweenReads")]
        getter add_idle_time_between_reads : Bool?

        # When this option is set to 'true', the data output will contain an additional column named
        # "__src_timestamp" that indicates the time when the corresponding record received by the stream. The
        # default value is 'false'. This option is supported in Glue version 4.0 or later.

        @[JSON::Field(key: "AddRecordTimestamp")]
        getter add_record_timestamp : String?

        # Avoids creating an empty microbatch job by checking for unread data in the Kinesis data stream
        # before the batch is started. The default value is "False" .

        @[JSON::Field(key: "AvoidEmptyBatches")]
        getter avoid_empty_batches : Bool?

        # An optional classification.

        @[JSON::Field(key: "Classification")]
        getter classification : String?

        # Specifies the delimiter character.

        @[JSON::Field(key: "Delimiter")]
        getter delimiter : String?

        # The minimum time interval between two ListShards API calls for your script to consider resharding.
        # The default value is 1s .

        @[JSON::Field(key: "DescribeShardInterval")]
        getter describe_shard_interval : Int64?

        # When this option is set to 'true', for each batch, it will emit the metrics for the duration between
        # the oldest record received by the stream and the time it arrives in Glue to CloudWatch. The metric's
        # name is "glue.driver.streaming.maxConsumerLagInMs". The default value is 'false'. This option is
        # supported in Glue version 4.0 or later.

        @[JSON::Field(key: "EmitConsumerLagMetrics")]
        getter emit_consumer_lag_metrics : String?

        # The URL of the Kinesis endpoint.

        @[JSON::Field(key: "EndpointUrl")]
        getter endpoint_url : String?

        # The Amazon Resource Name (ARN) of the Kinesis Data Streams enhanced fan-out consumer. When
        # specified, enables enhanced fan-out for dedicated throughput and lower latency data consumption.

        @[JSON::Field(key: "FanoutConsumerARN")]
        getter fanout_consumer_arn : String?

        # The minimum time delay between two consecutive getRecords operations, specified in ms. The default
        # value is 1000 . This option is only configurable for Glue version 2.0 and above.

        @[JSON::Field(key: "IdleTimeBetweenReadsInMs")]
        getter idle_time_between_reads_in_ms : Int64?

        # The maximum number of records to fetch per shard in the Kinesis data stream per microbatch. Note:
        # The client can exceed this limit if the streaming job has already read extra records from Kinesis
        # (in the same get-records call). If MaxFetchRecordsPerShard needs to be strict then it needs to be a
        # multiple of MaxRecordPerRead . The default value is 100000 .

        @[JSON::Field(key: "MaxFetchRecordsPerShard")]
        getter max_fetch_records_per_shard : Int64?

        # The maximum time spent for the job executor to read records for the current batch from the Kinesis
        # data stream, specified in milliseconds (ms). Multiple GetRecords API calls may be made within this
        # time. The default value is 1000 .

        @[JSON::Field(key: "MaxFetchTimeInMs")]
        getter max_fetch_time_in_ms : Int64?

        # The maximum number of records to fetch from the Kinesis data stream in each getRecords operation.
        # The default value is 10000 .

        @[JSON::Field(key: "MaxRecordPerRead")]
        getter max_record_per_read : Int64?

        # The maximum cool-off time period (specified in ms) between two retries of a Kinesis Data Streams API
        # call. The default value is 10000 .

        @[JSON::Field(key: "MaxRetryIntervalMs")]
        getter max_retry_interval_ms : Int64?

        # The maximum number of retries for Kinesis Data Streams API requests. The default value is 3 .

        @[JSON::Field(key: "NumRetries")]
        getter num_retries : Int32?

        # The cool-off time period (specified in ms) before retrying the Kinesis Data Streams API call. The
        # default value is 1000 .

        @[JSON::Field(key: "RetryIntervalMs")]
        getter retry_interval_ms : Int64?

        # The Amazon Resource Name (ARN) of the role to assume using AWS Security Token Service (AWS STS).
        # This role must have permissions for describe or read record operations for the Kinesis data stream.
        # You must use this parameter when accessing a data stream in a different account. Used in conjunction
        # with "awsSTSSessionName" .

        @[JSON::Field(key: "RoleArn")]
        getter role_arn : String?

        # An identifier for the session assuming the role using AWS STS. You must use this parameter when
        # accessing a data stream in a different account. Used in conjunction with "awsSTSRoleARN" .

        @[JSON::Field(key: "RoleSessionName")]
        getter role_session_name : String?

        # The starting position in the Kinesis data stream to read data from. The possible values are "latest"
        # , "trim_horizon" , "earliest" , or a timestamp string in UTC format in the pattern
        # yyyy-mm-ddTHH:MM:SSZ (where Z represents a UTC timezone offset with a +/-. For example:
        # "2023-04-04T08:00:00-04:00"). The default value is "latest" . Note: Using a value that is a
        # timestamp string in UTC format for "startingPosition" is supported only for Glue version 4.0 or
        # later.

        @[JSON::Field(key: "StartingPosition")]
        getter starting_position : String?

        # The timestamp of the record in the Kinesis data stream to start reading data from. The possible
        # values are a timestamp string in UTC format of the pattern yyyy-mm-ddTHH:MM:SSZ (where Z represents
        # a UTC timezone offset with a +/-. For example: "2023-04-04T08:00:00+08:00").

        @[JSON::Field(key: "StartingTimestamp", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter starting_timestamp : Time?

        # The Amazon Resource Name (ARN) of the Kinesis data stream.

        @[JSON::Field(key: "StreamArn")]
        getter stream_arn : String?

        # The name of the Kinesis data stream.

        @[JSON::Field(key: "StreamName")]
        getter stream_name : String?

        def initialize(
          @add_idle_time_between_reads : Bool? = nil,
          @add_record_timestamp : String? = nil,
          @avoid_empty_batches : Bool? = nil,
          @classification : String? = nil,
          @delimiter : String? = nil,
          @describe_shard_interval : Int64? = nil,
          @emit_consumer_lag_metrics : String? = nil,
          @endpoint_url : String? = nil,
          @fanout_consumer_arn : String? = nil,
          @idle_time_between_reads_in_ms : Int64? = nil,
          @max_fetch_records_per_shard : Int64? = nil,
          @max_fetch_time_in_ms : Int64? = nil,
          @max_record_per_read : Int64? = nil,
          @max_retry_interval_ms : Int64? = nil,
          @num_retries : Int32? = nil,
          @retry_interval_ms : Int64? = nil,
          @role_arn : String? = nil,
          @role_session_name : String? = nil,
          @starting_position : String? = nil,
          @starting_timestamp : Time? = nil,
          @stream_arn : String? = nil,
          @stream_name : String? = nil
        )
        end
      end

      # Specifies configuration properties for a labeling set generation task run.

      struct LabelingSetGenerationTaskRunProperties
        include JSON::Serializable

        # The Amazon Simple Storage Service (Amazon S3) path where you will generate the labeling set.

        @[JSON::Field(key: "OutputS3Path")]
        getter output_s3_path : String?

        def initialize(
          @output_s3_path : String? = nil
        )
        end
      end

      # Specifies Lake Formation configuration settings for the crawler.

      struct LakeFormationConfiguration
        include JSON::Serializable

        # Required for cross account crawls. For same account crawls as the target data, this can be left as
        # null.

        @[JSON::Field(key: "AccountId")]
        getter account_id : String?

        # Specifies whether to use Lake Formation credentials for the crawler instead of the IAM role
        # credentials.

        @[JSON::Field(key: "UseLakeFormationCredentials")]
        getter use_lake_formation_credentials : Bool?

        def initialize(
          @account_id : String? = nil,
          @use_lake_formation_credentials : Bool? = nil
        )
        end
      end

      # When there are multiple versions of a blueprint and the latest version has some errors, this
      # attribute indicates the last successful blueprint definition that is available with the service.

      struct LastActiveDefinition
        include JSON::Serializable

        # Specifies a path in Amazon S3 where the blueprint is published by the Glue developer.

        @[JSON::Field(key: "BlueprintLocation")]
        getter blueprint_location : String?

        # Specifies a path in Amazon S3 where the blueprint is copied when you create or update the blueprint.

        @[JSON::Field(key: "BlueprintServiceLocation")]
        getter blueprint_service_location : String?

        # The description of the blueprint.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The date and time the blueprint was last modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # A JSON string specifying the parameters for the blueprint.

        @[JSON::Field(key: "ParameterSpec")]
        getter parameter_spec : String?

        def initialize(
          @blueprint_location : String? = nil,
          @blueprint_service_location : String? = nil,
          @description : String? = nil,
          @last_modified_on : Time? = nil,
          @parameter_spec : String? = nil
        )
        end
      end

      # Status and error information about the most recent crawl.

      struct LastCrawlInfo
        include JSON::Serializable

        # If an error occurred, the error information about the last crawl.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # The log group for the last crawl.

        @[JSON::Field(key: "LogGroup")]
        getter log_group : String?

        # The log stream for the last crawl.

        @[JSON::Field(key: "LogStream")]
        getter log_stream : String?

        # The prefix for a message about this crawl.

        @[JSON::Field(key: "MessagePrefix")]
        getter message_prefix : String?

        # The time at which the crawl started.

        @[JSON::Field(key: "StartTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter start_time : Time?

        # Status of the last crawl.

        @[JSON::Field(key: "Status")]
        getter status : String?

        def initialize(
          @error_message : String? = nil,
          @log_group : String? = nil,
          @log_stream : String? = nil,
          @message_prefix : String? = nil,
          @start_time : Time? = nil,
          @status : String? = nil
        )
        end
      end

      # Specifies data lineage configuration settings for the crawler.

      struct LineageConfiguration
        include JSON::Serializable

        # Specifies whether data lineage is enabled for the crawler. Valid values are: ENABLE: enables data
        # lineage for the crawler DISABLE: disables data lineage for the crawler

        @[JSON::Field(key: "CrawlerLineageSettings")]
        getter crawler_lineage_settings : String?

        def initialize(
          @crawler_lineage_settings : String? = nil
        )
        end
      end


      struct ListBlueprintsRequest
        include JSON::Serializable

        # The maximum size of a list to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation request.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # Filters the list by an Amazon Web Services resource tag.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct ListBlueprintsResponse
        include JSON::Serializable

        # List of names of blueprints in the account.

        @[JSON::Field(key: "Blueprints")]
        getter blueprints : Array(String)?

        # A continuation token, if not all blueprint names have been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @blueprints : Array(String)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListColumnStatisticsTaskRunsRequest
        include JSON::Serializable

        # The maximum size of the response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListColumnStatisticsTaskRunsResponse
        include JSON::Serializable

        # A list of column statistics task run IDs.

        @[JSON::Field(key: "ColumnStatisticsTaskRunIds")]
        getter column_statistics_task_run_ids : Array(String)?

        # A continuation token, if not all task run IDs have yet been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @column_statistics_task_run_ids : Array(String)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListConnectionTypesRequest
        include JSON::Serializable

        # The maximum number of results to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListConnectionTypesResponse
        include JSON::Serializable

        # A list of ConnectionTypeBrief objects containing brief information about the supported connection
        # types.

        @[JSON::Field(key: "ConnectionTypes")]
        getter connection_types : Array(Types::ConnectionTypeBrief)?

        # A continuation token, if the current list segment is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @connection_types : Array(Types::ConnectionTypeBrief)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListCrawlersRequest
        include JSON::Serializable

        # The maximum size of a list to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation request.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # Specifies to return only these tagged resources.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct ListCrawlersResponse
        include JSON::Serializable

        # The names of all crawlers in the account, or the crawlers with the specified tags.

        @[JSON::Field(key: "CrawlerNames")]
        getter crawler_names : Array(String)?

        # A continuation token, if the returned list does not contain the last metric available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @crawler_names : Array(String)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListCrawlsRequest
        include JSON::Serializable

        # The name of the crawler whose runs you want to retrieve.

        @[JSON::Field(key: "CrawlerName")]
        getter crawler_name : String

        # Filters the crawls by the criteria you specify in a list of CrawlsFilter objects.

        @[JSON::Field(key: "Filters")]
        getter filters : Array(Types::CrawlsFilter)?

        # The maximum number of results to return. The default is 20, and maximum is 100.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @crawler_name : String,
          @filters : Array(Types::CrawlsFilter)? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListCrawlsResponse
        include JSON::Serializable

        # A list of CrawlerHistory objects representing the crawl runs that meet your criteria.

        @[JSON::Field(key: "Crawls")]
        getter crawls : Array(Types::CrawlerHistory)?

        # A continuation token for paginating the returned list of tokens, returned if the current segment of
        # the list is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @crawls : Array(Types::CrawlerHistory)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListCustomEntityTypesRequest
        include JSON::Serializable

        # The maximum number of results to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A paginated token to offset the results.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of key-value pair tags.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct ListCustomEntityTypesResponse
        include JSON::Serializable

        # A list of CustomEntityType objects representing custom patterns.

        @[JSON::Field(key: "CustomEntityTypes")]
        getter custom_entity_types : Array(Types::CustomEntityType)?

        # A pagination token, if more results are available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @custom_entity_types : Array(Types::CustomEntityType)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListDataQualityResultsRequest
        include JSON::Serializable

        # The filter criteria.

        @[JSON::Field(key: "Filter")]
        getter filter : Types::DataQualityResultFilterCriteria?

        # The maximum number of results to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A paginated token to offset the results.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @filter : Types::DataQualityResultFilterCriteria? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListDataQualityResultsResponse
        include JSON::Serializable

        # A list of DataQualityResultDescription objects.

        @[JSON::Field(key: "Results")]
        getter results : Array(Types::DataQualityResultDescription)

        # A pagination token, if more results are available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @results : Array(Types::DataQualityResultDescription),
          @next_token : String? = nil
        )
        end
      end


      struct ListDataQualityRuleRecommendationRunsRequest
        include JSON::Serializable

        # The filter criteria.

        @[JSON::Field(key: "Filter")]
        getter filter : Types::DataQualityRuleRecommendationRunFilter?

        # The maximum number of results to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A paginated token to offset the results.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @filter : Types::DataQualityRuleRecommendationRunFilter? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListDataQualityRuleRecommendationRunsResponse
        include JSON::Serializable

        # A pagination token, if more results are available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of DataQualityRuleRecommendationRunDescription objects.

        @[JSON::Field(key: "Runs")]
        getter runs : Array(Types::DataQualityRuleRecommendationRunDescription)?

        def initialize(
          @next_token : String? = nil,
          @runs : Array(Types::DataQualityRuleRecommendationRunDescription)? = nil
        )
        end
      end


      struct ListDataQualityRulesetEvaluationRunsRequest
        include JSON::Serializable

        # The filter criteria.

        @[JSON::Field(key: "Filter")]
        getter filter : Types::DataQualityRulesetEvaluationRunFilter?

        # The maximum number of results to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A paginated token to offset the results.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @filter : Types::DataQualityRulesetEvaluationRunFilter? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListDataQualityRulesetEvaluationRunsResponse
        include JSON::Serializable

        # A pagination token, if more results are available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of DataQualityRulesetEvaluationRunDescription objects representing data quality ruleset runs.

        @[JSON::Field(key: "Runs")]
        getter runs : Array(Types::DataQualityRulesetEvaluationRunDescription)?

        def initialize(
          @next_token : String? = nil,
          @runs : Array(Types::DataQualityRulesetEvaluationRunDescription)? = nil
        )
        end
      end


      struct ListDataQualityRulesetsRequest
        include JSON::Serializable

        # The filter criteria.

        @[JSON::Field(key: "Filter")]
        getter filter : Types::DataQualityRulesetFilterCriteria?

        # The maximum number of results to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A paginated token to offset the results.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of key-value pair tags.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @filter : Types::DataQualityRulesetFilterCriteria? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct ListDataQualityRulesetsResponse
        include JSON::Serializable

        # A pagination token, if more results are available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A paginated list of rulesets for the specified list of Glue tables.

        @[JSON::Field(key: "Rulesets")]
        getter rulesets : Array(Types::DataQualityRulesetListDetails)?

        def initialize(
          @next_token : String? = nil,
          @rulesets : Array(Types::DataQualityRulesetListDetails)? = nil
        )
        end
      end


      struct ListDataQualityStatisticAnnotationsRequest
        include JSON::Serializable

        # The maximum number of results to return in this request.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A pagination token to retrieve the next set of results.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The Profile ID.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String?

        # The Statistic ID.

        @[JSON::Field(key: "StatisticId")]
        getter statistic_id : String?

        # A timestamp filter.

        @[JSON::Field(key: "TimestampFilter")]
        getter timestamp_filter : Types::TimestampFilter?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @profile_id : String? = nil,
          @statistic_id : String? = nil,
          @timestamp_filter : Types::TimestampFilter? = nil
        )
        end
      end


      struct ListDataQualityStatisticAnnotationsResponse
        include JSON::Serializable

        # A list of StatisticAnnotation applied to the Statistic

        @[JSON::Field(key: "Annotations")]
        getter annotations : Array(Types::StatisticAnnotation)?

        # A pagination token to retrieve the next set of results.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @annotations : Array(Types::StatisticAnnotation)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListDataQualityStatisticsRequest
        include JSON::Serializable

        # The maximum number of results to return in this request.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A pagination token to request the next page of results.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The Profile ID.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String?

        # The Statistic ID.

        @[JSON::Field(key: "StatisticId")]
        getter statistic_id : String?

        # A timestamp filter.

        @[JSON::Field(key: "TimestampFilter")]
        getter timestamp_filter : Types::TimestampFilter?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @profile_id : String? = nil,
          @statistic_id : String? = nil,
          @timestamp_filter : Types::TimestampFilter? = nil
        )
        end
      end


      struct ListDataQualityStatisticsResponse
        include JSON::Serializable

        # A pagination token to request the next page of results.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A StatisticSummaryList .

        @[JSON::Field(key: "Statistics")]
        getter statistics : Array(Types::StatisticSummary)?

        def initialize(
          @next_token : String? = nil,
          @statistics : Array(Types::StatisticSummary)? = nil
        )
        end
      end


      struct ListDevEndpointsRequest
        include JSON::Serializable

        # The maximum size of a list to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation request.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # Specifies to return only these tagged resources.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct ListDevEndpointsResponse
        include JSON::Serializable

        # The names of all the DevEndpoint s in the account, or the DevEndpoint s with the specified tags.

        @[JSON::Field(key: "DevEndpointNames")]
        getter dev_endpoint_names : Array(String)?

        # A continuation token, if the returned list does not contain the last metric available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @dev_endpoint_names : Array(String)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListEntitiesRequest
        include JSON::Serializable

        # The catalog ID of the catalog that contains the connection. This can be null, By default, the Amazon
        # Web Services Account ID is the catalog ID.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # A name for the connection that has required credentials to query any connection type.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # The API version of the SaaS connector.

        @[JSON::Field(key: "DataStoreApiVersion")]
        getter data_store_api_version : String?

        # A continuation token, included if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # Name of the parent entity for which you want to list the children. This parameter takes a
        # fully-qualified path of the entity in order to list the child entities.

        @[JSON::Field(key: "ParentEntityName")]
        getter parent_entity_name : String?

        def initialize(
          @catalog_id : String? = nil,
          @connection_name : String? = nil,
          @data_store_api_version : String? = nil,
          @next_token : String? = nil,
          @parent_entity_name : String? = nil
        )
        end
      end


      struct ListEntitiesResponse
        include JSON::Serializable

        # A list of Entity objects.

        @[JSON::Field(key: "Entities")]
        getter entities : Array(Types::Entity)?

        # A continuation token, present if the current segment is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @entities : Array(Types::Entity)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListIntegrationResourcePropertiesRequest
        include JSON::Serializable

        # A list of filters, supported filter Key is SourceArn and TargetArn .

        @[JSON::Field(key: "Filters")]
        getter filters : Array(Types::IntegrationResourcePropertyFilter)?

        # This is the pagination token for next page, initial value is null .

        @[JSON::Field(key: "Marker")]
        getter marker : String?

        # This is total number of items to be evaluated.

        @[JSON::Field(key: "MaxRecords")]
        getter max_records : Int32?

        def initialize(
          @filters : Array(Types::IntegrationResourcePropertyFilter)? = nil,
          @marker : String? = nil,
          @max_records : Int32? = nil
        )
        end
      end


      struct ListIntegrationResourcePropertiesResponse
        include JSON::Serializable

        # A list of integration resource property meeting the filter criteria.

        @[JSON::Field(key: "IntegrationResourcePropertyList")]
        getter integration_resource_property_list : Array(Types::IntegrationResourceProperty)?

        # This is the pagination token for the next page.

        @[JSON::Field(key: "Marker")]
        getter marker : String?

        def initialize(
          @integration_resource_property_list : Array(Types::IntegrationResourceProperty)? = nil,
          @marker : String? = nil
        )
        end
      end


      struct ListJobsRequest
        include JSON::Serializable

        # The maximum size of a list to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation request.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # Specifies to return only these tagged resources.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct ListJobsResponse
        include JSON::Serializable

        # The names of all jobs in the account, or the jobs with the specified tags.

        @[JSON::Field(key: "JobNames")]
        getter job_names : Array(String)?

        # A continuation token, if the returned list does not contain the last metric available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @job_names : Array(String)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListMLTransformsRequest
        include JSON::Serializable

        # A TransformFilterCriteria used to filter the machine learning transforms.

        @[JSON::Field(key: "Filter")]
        getter filter : Types::TransformFilterCriteria?

        # The maximum size of a list to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation request.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A TransformSortCriteria used to sort the machine learning transforms.

        @[JSON::Field(key: "Sort")]
        getter sort : Types::TransformSortCriteria?

        # Specifies to return only these tagged resources.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @filter : Types::TransformFilterCriteria? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @sort : Types::TransformSortCriteria? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct ListMLTransformsResponse
        include JSON::Serializable

        # The identifiers of all the machine learning transforms in the account, or the machine learning
        # transforms with the specified tags.

        @[JSON::Field(key: "TransformIds")]
        getter transform_ids : Array(String)

        # A continuation token, if the returned list does not contain the last metric available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @transform_ids : Array(String),
          @next_token : String? = nil
        )
        end
      end


      struct ListMaterializedViewRefreshTaskRunsRequest
        include JSON::Serializable

        # The ID of the Data Catalog where the table resides. If none is supplied, the account ID is used by
        # default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # The database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # The maximum size of the response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The name of the table for which statistics is generated.

        @[JSON::Field(key: "TableName")]
        getter table_name : String?

        def initialize(
          @catalog_id : String,
          @database_name : String? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @table_name : String? = nil
        )
        end
      end


      struct ListMaterializedViewRefreshTaskRunsResponse
        include JSON::Serializable

        # The results of the ListMaterializedViewRefreshTaskRuns action.

        @[JSON::Field(key: "MaterializedViewRefreshTaskRuns")]
        getter materialized_view_refresh_task_runs : Array(Types::MaterializedViewRefreshTaskRun)?

        # A continuation token, if not all task run IDs have yet been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @materialized_view_refresh_task_runs : Array(Types::MaterializedViewRefreshTaskRun)? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListRegistriesInput
        include JSON::Serializable

        # Maximum number of results required per page. If the value is not supplied, this will be defaulted to
        # 25 per page.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListRegistriesResponse
        include JSON::Serializable

        # A continuation token for paginating the returned list of tokens, returned if the current segment of
        # the list is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # An array of RegistryDetailedListItem objects containing minimal details of each registry.

        @[JSON::Field(key: "Registries")]
        getter registries : Array(Types::RegistryListItem)?

        def initialize(
          @next_token : String? = nil,
          @registries : Array(Types::RegistryListItem)? = nil
        )
        end
      end


      struct ListSchemaVersionsInput
        include JSON::Serializable

        # This is a wrapper structure to contain schema identity fields. The structure contains:
        # SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and
        # RegistryName has to be provided. SchemaId$SchemaName: The name of the schema. Either SchemaArn or
        # SchemaName and RegistryName has to be provided.

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId

        # Maximum number of results required per page. If the value is not supplied, this will be defaulted to
        # 25 per page.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @schema_id : Types::SchemaId,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListSchemaVersionsResponse
        include JSON::Serializable

        # A continuation token for paginating the returned list of tokens, returned if the current segment of
        # the list is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # An array of SchemaVersionList objects containing details of each schema version.

        @[JSON::Field(key: "Schemas")]
        getter schemas : Array(Types::SchemaVersionListItem)?

        def initialize(
          @next_token : String? = nil,
          @schemas : Array(Types::SchemaVersionListItem)? = nil
        )
        end
      end


      struct ListSchemasInput
        include JSON::Serializable

        # Maximum number of results required per page. If the value is not supplied, this will be defaulted to
        # 25 per page.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).

        @[JSON::Field(key: "RegistryId")]
        getter registry_id : Types::RegistryId?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @registry_id : Types::RegistryId? = nil
        )
        end
      end


      struct ListSchemasResponse
        include JSON::Serializable

        # A continuation token for paginating the returned list of tokens, returned if the current segment of
        # the list is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # An array of SchemaListItem objects containing details of each schema.

        @[JSON::Field(key: "Schemas")]
        getter schemas : Array(Types::SchemaListItem)?

        def initialize(
          @next_token : String? = nil,
          @schemas : Array(Types::SchemaListItem)? = nil
        )
        end
      end


      struct ListSessionsRequest
        include JSON::Serializable

        # The maximum number of results.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # The token for the next set of results, or null if there are no more result.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The origin of the request.

        @[JSON::Field(key: "RequestOrigin")]
        getter request_origin : String?

        # Tags belonging to the session.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @request_origin : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct ListSessionsResponse
        include JSON::Serializable

        # Returns the ID of the session.

        @[JSON::Field(key: "Ids")]
        getter ids : Array(String)?

        # The token for the next set of results, or null if there are no more result.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # Returns the session object.

        @[JSON::Field(key: "Sessions")]
        getter sessions : Array(Types::Session)?

        def initialize(
          @ids : Array(String)? = nil,
          @next_token : String? = nil,
          @sessions : Array(Types::Session)? = nil
        )
        end
      end


      struct ListStatementsRequest
        include JSON::Serializable

        # The Session ID of the statements.

        @[JSON::Field(key: "SessionId")]
        getter session_id : String

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The origin of the request to list statements.

        @[JSON::Field(key: "RequestOrigin")]
        getter request_origin : String?

        def initialize(
          @session_id : String,
          @next_token : String? = nil,
          @request_origin : String? = nil
        )
        end
      end


      struct ListStatementsResponse
        include JSON::Serializable

        # A continuation token, if not all statements have yet been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # Returns the list of statements.

        @[JSON::Field(key: "Statements")]
        getter statements : Array(Types::Statement)?

        def initialize(
          @next_token : String? = nil,
          @statements : Array(Types::Statement)? = nil
        )
        end
      end


      struct ListTableOptimizerRunsRequest
        include JSON::Serializable

        # The Catalog ID of the table.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # The name of the database in the catalog in which the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The type of table optimizer.

        @[JSON::Field(key: "Type")]
        getter type : String

        # The maximum number of optimizer runs to return on each call.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @catalog_id : String,
          @database_name : String,
          @table_name : String,
          @type : String,
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListTableOptimizerRunsResponse
        include JSON::Serializable

        # The Catalog ID of the table.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The name of the database in the catalog in which the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # A continuation token for paginating the returned list of optimizer runs, returned if the current
        # segment of the list is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The name of the table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String?

        # A list of the optimizer runs associated with a table.

        @[JSON::Field(key: "TableOptimizerRuns")]
        getter table_optimizer_runs : Array(Types::TableOptimizerRun)?

        def initialize(
          @catalog_id : String? = nil,
          @database_name : String? = nil,
          @next_token : String? = nil,
          @table_name : String? = nil,
          @table_optimizer_runs : Array(Types::TableOptimizerRun)? = nil
        )
        end
      end


      struct ListTriggersRequest
        include JSON::Serializable

        # The name of the job for which to retrieve triggers. The trigger that can start this job is returned.
        # If there is no such trigger, all triggers are returned.

        @[JSON::Field(key: "DependentJobName")]
        getter dependent_job_name : String?

        # The maximum size of a list to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation request.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # Specifies to return only these tagged resources.

        @[JSON::Field(key: "Tags")]
        getter tags : Hash(String, String)?

        def initialize(
          @dependent_job_name : String? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @tags : Hash(String, String)? = nil
        )
        end
      end


      struct ListTriggersResponse
        include JSON::Serializable

        # A continuation token, if the returned list does not contain the last metric available.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The names of all triggers in the account, or the triggers with the specified tags.

        @[JSON::Field(key: "TriggerNames")]
        getter trigger_names : Array(String)?

        def initialize(
          @next_token : String? = nil,
          @trigger_names : Array(String)? = nil
        )
        end
      end


      struct ListUsageProfilesRequest
        include JSON::Serializable

        # The maximum number of usage profiles to return in a single response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, included if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListUsageProfilesResponse
        include JSON::Serializable

        # A continuation token, present if the current list segment is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of usage profile ( UsageProfileDefinition ) objects.

        @[JSON::Field(key: "Profiles")]
        getter profiles : Array(Types::UsageProfileDefinition)?

        def initialize(
          @next_token : String? = nil,
          @profiles : Array(Types::UsageProfileDefinition)? = nil
        )
        end
      end


      struct ListWorkflowsRequest
        include JSON::Serializable

        # The maximum size of a list to return.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, if this is a continuation request.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        def initialize(
          @max_results : Int32? = nil,
          @next_token : String? = nil
        )
        end
      end


      struct ListWorkflowsResponse
        include JSON::Serializable

        # A continuation token, if not all workflow names have been returned.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # List of names of workflows in the account.

        @[JSON::Field(key: "Workflows")]
        getter workflows : Array(String)?

        def initialize(
          @next_token : String? = nil,
          @workflows : Array(String)? = nil
        )
        end
      end

      # The location of resources.

      struct Location
        include JSON::Serializable

        # An Amazon DynamoDB table location.

        @[JSON::Field(key: "DynamoDB")]
        getter dynamo_db : Array(Types::CodeGenNodeArg)?

        # A JDBC location.

        @[JSON::Field(key: "Jdbc")]
        getter jdbc : Array(Types::CodeGenNodeArg)?

        # An Amazon Simple Storage Service (Amazon S3) location.

        @[JSON::Field(key: "S3")]
        getter s3 : Array(Types::CodeGenNodeArg)?

        def initialize(
          @dynamo_db : Array(Types::CodeGenNodeArg)? = nil,
          @jdbc : Array(Types::CodeGenNodeArg)? = nil,
          @s3 : Array(Types::CodeGenNodeArg)? = nil
        )
        end
      end

      # Defines column statistics supported for integer data columns.

      struct LongColumnStatisticsData
        include JSON::Serializable

        # The number of distinct values in a column.

        @[JSON::Field(key: "NumberOfDistinctValues")]
        getter number_of_distinct_values : Int64

        # The number of null values in the column.

        @[JSON::Field(key: "NumberOfNulls")]
        getter number_of_nulls : Int64

        # The highest value in the column.

        @[JSON::Field(key: "MaximumValue")]
        getter maximum_value : Int64?

        # The lowest value in the column.

        @[JSON::Field(key: "MinimumValue")]
        getter minimum_value : Int64?

        def initialize(
          @number_of_distinct_values : Int64,
          @number_of_nulls : Int64,
          @maximum_value : Int64? = nil,
          @minimum_value : Int64? = nil
        )
        end
      end

      # A structure for a machine learning transform.

      struct MLTransform
        include JSON::Serializable

        # A timestamp. The time and date that this machine learning transform was created.

        @[JSON::Field(key: "CreatedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_on : Time?

        # A user-defined, long-form description text for the machine learning transform. Descriptions are not
        # guaranteed to be unique and can be changed at any time.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # An EvaluationMetrics object. Evaluation metrics provide an estimate of the quality of your machine
        # learning transform.

        @[JSON::Field(key: "EvaluationMetrics")]
        getter evaluation_metrics : Types::EvaluationMetrics?

        # This value determines which version of Glue this machine learning transform is compatible with. Glue
        # 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to
        # Glue 0.9. For more information, see Glue Versions in the developer guide.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # A list of Glue table definitions used by the transform.

        @[JSON::Field(key: "InputRecordTables")]
        getter input_record_tables : Array(Types::GlueTable)?

        # A count identifier for the labeling files generated by Glue for this transform. As you create a
        # better transform, you can iteratively download, label, and upload the labeling file.

        @[JSON::Field(key: "LabelCount")]
        getter label_count : Int32?

        # A timestamp. The last point in time when this machine learning transform was modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The number of Glue data processing units (DPUs) that are allocated to task runs for this transform.
        # You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing
        # power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see
        # the Glue pricing page . MaxCapacity is a mutually exclusive option with NumberOfWorkers and
        # WorkerType . If either NumberOfWorkers or WorkerType is set, then MaxCapacity cannot be set. If
        # MaxCapacity is set then neither NumberOfWorkers or WorkerType can be set. If WorkerType is set, then
        # NumberOfWorkers is required (and vice versa). MaxCapacity and NumberOfWorkers must both be at least
        # 1. When the WorkerType field is set to a value other than Standard , the MaxCapacity field is set
        # automatically and becomes read-only.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # The maximum number of times to retry after an MLTaskRun of the machine learning transform fails.

        @[JSON::Field(key: "MaxRetries")]
        getter max_retries : Int32?

        # A user-defined name for the machine learning transform. Names are not guaranteed unique and can be
        # changed at any time.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # The number of workers of a defined workerType that are allocated when a task of the transform runs.
        # If WorkerType is set, then NumberOfWorkers is required (and vice versa).

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # A TransformParameters object. You can use parameters to tune (customize) the behavior of the machine
        # learning transform by specifying what data it learns from and your preference on various tradeoffs
        # (such as precious vs. recall, or accuracy vs. cost).

        @[JSON::Field(key: "Parameters")]
        getter parameters : Types::TransformParameters?

        # The name or Amazon Resource Name (ARN) of the IAM role with the required permissions. The required
        # permissions include both Glue service role permissions to Glue resources, and Amazon S3 permissions
        # required by the transform. This role needs Glue service role permissions to allow access to
        # resources in Glue. See Attach a Policy to IAM Users That Access Glue . This role needs permission to
        # your Amazon Simple Storage Service (Amazon S3) sources, targets, temporary directory, scripts, and
        # any libraries used by the task run for this transform.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # A map of key-value pairs representing the columns and data types that this transform can run
        # against. Has an upper bound of 100 columns.

        @[JSON::Field(key: "Schema")]
        getter schema : Array(Types::SchemaColumn)?

        # The current status of the machine learning transform.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The timeout in minutes of the machine learning transform.

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        # The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning
        # transforms can access user data encrypted in Amazon S3 using KMS.

        @[JSON::Field(key: "TransformEncryption")]
        getter transform_encryption : Types::TransformEncryption?

        # The unique transform ID that is generated for the machine learning transform. The ID is guaranteed
        # to be unique and does not change.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String?

        # The type of predefined worker that is allocated when a task of this transform runs. Accepts a value
        # of Standard, G.1X, or G.2X. For the Standard worker type, each worker provides 4 vCPU, 16 GB of
        # memory and a 50GB disk, and 2 executors per worker. For the G.1X worker type, each worker provides 4
        # vCPU, 16 GB of memory and a 64GB disk, and 1 executor per worker. For the G.2X worker type, each
        # worker provides 8 vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker. MaxCapacity is
        # a mutually exclusive option with NumberOfWorkers and WorkerType . If either NumberOfWorkers or
        # WorkerType is set, then MaxCapacity cannot be set. If MaxCapacity is set then neither
        # NumberOfWorkers or WorkerType can be set. If WorkerType is set, then NumberOfWorkers is required
        # (and vice versa). MaxCapacity and NumberOfWorkers must both be at least 1.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @created_on : Time? = nil,
          @description : String? = nil,
          @evaluation_metrics : Types::EvaluationMetrics? = nil,
          @glue_version : String? = nil,
          @input_record_tables : Array(Types::GlueTable)? = nil,
          @label_count : Int32? = nil,
          @last_modified_on : Time? = nil,
          @max_capacity : Float64? = nil,
          @max_retries : Int32? = nil,
          @name : String? = nil,
          @number_of_workers : Int32? = nil,
          @parameters : Types::TransformParameters? = nil,
          @role : String? = nil,
          @schema : Array(Types::SchemaColumn)? = nil,
          @status : String? = nil,
          @timeout : Int32? = nil,
          @transform_encryption : Types::TransformEncryption? = nil,
          @transform_id : String? = nil,
          @worker_type : String? = nil
        )
        end
      end

      # The machine learning transform is not ready to run.

      struct MLTransformNotReadyException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The encryption-at-rest settings of the transform that apply to accessing user data.

      struct MLUserDataEncryption
        include JSON::Serializable

        # The encryption mode applied to user data. Valid values are: DISABLED: encryption is disabled SSEKMS:
        # use of server-side encryption with Key Management Service (SSE-KMS) for user data stored in Amazon
        # S3.

        @[JSON::Field(key: "MlUserDataEncryptionMode")]
        getter ml_user_data_encryption_mode : String

        # The ID for the customer-provided KMS key.

        @[JSON::Field(key: "KmsKeyId")]
        getter kms_key_id : String?

        def initialize(
          @ml_user_data_encryption_mode : String,
          @kms_key_id : String? = nil
        )
        end
      end

      # Specifies the mapping of data property keys.

      struct Mapping
        include JSON::Serializable

        # Only applicable to nested data structures. If you want to change the parent structure, but also one
        # of its children, you can fill out this data strucutre. It is also Mapping , but its FromPath will be
        # the parent's FromPath plus the FromPath from this structure. For the children part, suppose you have
        # the structure: { "FromPath": "OuterStructure", "ToKey": "OuterStructure", "ToType": "Struct",
        # "Dropped": false, "Chidlren": [{ "FromPath": "inner", "ToKey": "inner", "ToType": "Double",
        # "Dropped": false, }] } You can specify a Mapping that looks like: { "FromPath": "OuterStructure",
        # "ToKey": "OuterStructure", "ToType": "Struct", "Dropped": false, "Chidlren": [{ "FromPath": "inner",
        # "ToKey": "inner", "ToType": "Double", "Dropped": false, }] }

        @[JSON::Field(key: "Children")]
        getter children : Array(Types::Mapping)?

        # If true, then the column is removed.

        @[JSON::Field(key: "Dropped")]
        getter dropped : Bool?

        # The table or column to be modified.

        @[JSON::Field(key: "FromPath")]
        getter from_path : Array(String)?

        # The type of the data to be modified.

        @[JSON::Field(key: "FromType")]
        getter from_type : String?

        # After the apply mapping, what the name of the column should be. Can be the same as FromPath .

        @[JSON::Field(key: "ToKey")]
        getter to_key : String?

        # The data type that the data is to be modified to.

        @[JSON::Field(key: "ToType")]
        getter to_type : String?

        def initialize(
          @children : Array(Types::Mapping)? = nil,
          @dropped : Bool? = nil,
          @from_path : Array(String)? = nil,
          @from_type : String? = nil,
          @to_key : String? = nil,
          @to_type : String? = nil
        )
        end
      end

      # Defines a mapping.

      struct MappingEntry
        include JSON::Serializable

        # The source path.

        @[JSON::Field(key: "SourcePath")]
        getter source_path : String?

        # The name of the source table.

        @[JSON::Field(key: "SourceTable")]
        getter source_table : String?

        # The source type.

        @[JSON::Field(key: "SourceType")]
        getter source_type : String?

        # The target path.

        @[JSON::Field(key: "TargetPath")]
        getter target_path : String?

        # The target table.

        @[JSON::Field(key: "TargetTable")]
        getter target_table : String?

        # The target type.

        @[JSON::Field(key: "TargetType")]
        getter target_type : String?

        def initialize(
          @source_path : String? = nil,
          @source_table : String? = nil,
          @source_type : String? = nil,
          @target_path : String? = nil,
          @target_table : String? = nil,
          @target_type : String? = nil
        )
        end
      end

      # Exception thrown when stopping a task that is not in running state.

      struct MaterializedViewRefreshTaskNotRunningException
        include JSON::Serializable


        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The object that shows the details of the materialized view refresh task run.

      struct MaterializedViewRefreshTaskRun
        include JSON::Serializable

        # The ID of the Data Catalog where the table resides. If none is supplied, the account ID is used by
        # default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The time that this task was created.

        @[JSON::Field(key: "CreationTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter creation_time : Time?

        # The Amazon Web Services account ID.

        @[JSON::Field(key: "CustomerId")]
        getter customer_id : String?

        # The calculated DPU usage in seconds for all autoscaled workers.

        @[JSON::Field(key: "DPUSeconds")]
        getter dpu_seconds : Float64?

        # The database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # The end time of the task.

        @[JSON::Field(key: "EndTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter end_time : Time?

        # The error message for the job.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # The last point in time when this task was modified.

        @[JSON::Field(key: "LastUpdated", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_updated : Time?

        # The identifier of the materialized view refresh task run.

        @[JSON::Field(key: "MaterializedViewRefreshTaskRunId")]
        getter materialized_view_refresh_task_run_id : String?

        # The number of bytes the refresh task run has scanned to refresh the materialized view.

        @[JSON::Field(key: "ProcessedBytes")]
        getter processed_bytes : Int64?

        # The type of the refresh task run. Either FULL or INCREMENTAL.

        @[JSON::Field(key: "RefreshType")]
        getter refresh_type : String?

        # The IAM role that the service assumes to generate statistics.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # The start time of the task.

        @[JSON::Field(key: "StartTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter start_time : Time?

        # The status of the task run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The name of the table for which statistics is generated.

        @[JSON::Field(key: "TableName")]
        getter table_name : String?

        def initialize(
          @catalog_id : String? = nil,
          @creation_time : Time? = nil,
          @customer_id : String? = nil,
          @dpu_seconds : Float64? = nil,
          @database_name : String? = nil,
          @end_time : Time? = nil,
          @error_message : String? = nil,
          @last_updated : Time? = nil,
          @materialized_view_refresh_task_run_id : String? = nil,
          @processed_bytes : Int64? = nil,
          @refresh_type : String? = nil,
          @role : String? = nil,
          @start_time : Time? = nil,
          @status : String? = nil,
          @table_name : String? = nil
        )
        end
      end

      # Exception thrown when a task is already in running state.

      struct MaterializedViewRefreshTaskRunningException
        include JSON::Serializable


        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Exception thrown when a task is already in stopping state.

      struct MaterializedViewRefreshTaskStoppingException
        include JSON::Serializable


        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Specifies a transform that merges a DynamicFrame with a staging DynamicFrame based on the specified
      # primary keys to identify records. Duplicate records (records with the same primary keys) are not
      # de-duplicated.

      struct Merge
        include JSON::Serializable

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The list of primary key fields to match records from the source and staging dynamic frames.

        @[JSON::Field(key: "PrimaryKeys")]
        getter primary_keys : Array(Array(String))

        # The source DynamicFrame that will be merged with a staging DynamicFrame .

        @[JSON::Field(key: "Source")]
        getter source : String

        def initialize(
          @inputs : Array(String),
          @name : String,
          @primary_keys : Array(Array(String)),
          @source : String
        )
        end
      end

      # A structure containing metadata information for a schema version.

      struct MetadataInfo
        include JSON::Serializable

        # The time at which the entry was created.

        @[JSON::Field(key: "CreatedTime")]
        getter created_time : String?

        # The metadata keys corresponding value.

        @[JSON::Field(key: "MetadataValue")]
        getter metadata_value : String?

        # Other metadata belonging to the same metadata key.

        @[JSON::Field(key: "OtherMetadataValueList")]
        getter other_metadata_value_list : Array(Types::OtherMetadataValueListItem)?

        def initialize(
          @created_time : String? = nil,
          @metadata_value : String? = nil,
          @other_metadata_value_list : Array(Types::OtherMetadataValueListItem)? = nil
        )
        end
      end

      # A structure containing a key value pair for metadata.

      struct MetadataKeyValuePair
        include JSON::Serializable

        # A metadata key.

        @[JSON::Field(key: "MetadataKey")]
        getter metadata_key : String?

        # A metadata keys corresponding value.

        @[JSON::Field(key: "MetadataValue")]
        getter metadata_value : String?

        def initialize(
          @metadata_key : String? = nil,
          @metadata_value : String? = nil
        )
        end
      end

      # Describes the metric based observation generated based on evaluated data quality metrics.

      struct MetricBasedObservation
        include JSON::Serializable

        # The name of the data quality metric used for generating the observation.

        @[JSON::Field(key: "MetricName")]
        getter metric_name : String?

        # An object of type DataQualityMetricValues representing the analysis of the data quality metric
        # value.

        @[JSON::Field(key: "MetricValues")]
        getter metric_values : Types::DataQualityMetricValues?

        # A list of new data quality rules generated as part of the observation based on the data quality
        # metric value.

        @[JSON::Field(key: "NewRules")]
        getter new_rules : Array(String)?

        # The Statistic ID.

        @[JSON::Field(key: "StatisticId")]
        getter statistic_id : String?

        def initialize(
          @metric_name : String? = nil,
          @metric_values : Types::DataQualityMetricValues? = nil,
          @new_rules : Array(String)? = nil,
          @statistic_id : String? = nil
        )
        end
      end

      # Specifies a Microsoft SQL server data source in the Glue Data Catalog.

      struct MicrosoftSQLServerCatalogSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        def initialize(
          @database : String,
          @name : String,
          @table : String
        )
        end
      end

      # Specifies a target that uses Microsoft SQL.

      struct MicrosoftSQLServerCatalogTarget
        include JSON::Serializable

        # The name of the database to write to.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to write to.

        @[JSON::Field(key: "Table")]
        getter table : String

        def initialize(
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String
        )
        end
      end


      struct ModifyIntegrationRequest
        include JSON::Serializable

        # The Amazon Resource Name (ARN) for the integration.

        @[JSON::Field(key: "IntegrationIdentifier")]
        getter integration_identifier : String

        # Selects source tables for the integration using Maxwell filter syntax.

        @[JSON::Field(key: "DataFilter")]
        getter data_filter : String?

        # A description of the integration.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The configuration settings for the integration. Currently, only the RefreshInterval can be modified.

        @[JSON::Field(key: "IntegrationConfig")]
        getter integration_config : Types::IntegrationConfig?

        # A unique name for an integration in Glue.

        @[JSON::Field(key: "IntegrationName")]
        getter integration_name : String?

        def initialize(
          @integration_identifier : String,
          @data_filter : String? = nil,
          @description : String? = nil,
          @integration_config : Types::IntegrationConfig? = nil,
          @integration_name : String? = nil
        )
        end
      end


      struct ModifyIntegrationResponse
        include JSON::Serializable

        # The time when the integration was created, in UTC.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time

        # The Amazon Resource Name (ARN) for the integration.

        @[JSON::Field(key: "IntegrationArn")]
        getter integration_arn : String

        # A unique name for an integration in Glue.

        @[JSON::Field(key: "IntegrationName")]
        getter integration_name : String

        # The ARN of the source for the integration.

        @[JSON::Field(key: "SourceArn")]
        getter source_arn : String

        # The status of the integration being modified. The possible statuses are: CREATING: The integration
        # is being created. ACTIVE: The integration creation succeeds. MODIFYING: The integration is being
        # modified. FAILED: The integration creation fails. DELETING: The integration is deleted. SYNCING: The
        # integration is synchronizing. NEEDS_ATTENTION: The integration needs attention, such as
        # synchronization.

        @[JSON::Field(key: "Status")]
        getter status : String

        # The ARN of the target for the integration.

        @[JSON::Field(key: "TargetArn")]
        getter target_arn : String

        # An optional set of non-secret keyvalue pairs that contains additional contextual information for
        # encryption.

        @[JSON::Field(key: "AdditionalEncryptionContext")]
        getter additional_encryption_context : Hash(String, String)?

        # Selects source tables for the integration using Maxwell filter syntax.

        @[JSON::Field(key: "DataFilter")]
        getter data_filter : String?

        # A description of the integration.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A list of errors associated with the integration modification.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::IntegrationError)?

        # The updated configuration settings for the integration.

        @[JSON::Field(key: "IntegrationConfig")]
        getter integration_config : Types::IntegrationConfig?

        # The ARN of a KMS key used for encrypting the channel.

        @[JSON::Field(key: "KmsKeyId")]
        getter kms_key_id : String?

        # Metadata assigned to the resource consisting of a list of key-value pairs.

        @[JSON::Field(key: "Tags")]
        getter tags : Array(Types::Tag)?

        def initialize(
          @create_time : Time,
          @integration_arn : String,
          @integration_name : String,
          @source_arn : String,
          @status : String,
          @target_arn : String,
          @additional_encryption_context : Hash(String, String)? = nil,
          @data_filter : String? = nil,
          @description : String? = nil,
          @errors : Array(Types::IntegrationError)? = nil,
          @integration_config : Types::IntegrationConfig? = nil,
          @kms_key_id : String? = nil,
          @tags : Array(Types::Tag)? = nil
        )
        end
      end

      # Specifies an Amazon DocumentDB or MongoDB data store to crawl.

      struct MongoDBTarget
        include JSON::Serializable

        # The name of the connection to use to connect to the Amazon DocumentDB or MongoDB target.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # The path of the Amazon DocumentDB or MongoDB target (database/collection).

        @[JSON::Field(key: "Path")]
        getter path : String?

        # Indicates whether to scan all the records, or to sample rows from the table. Scanning all the
        # records can take a long time when the table is not a high throughput table. A value of true means to
        # scan all records, while a value of false means to sample the records. If no value is specified, the
        # value defaults to true .

        @[JSON::Field(key: "ScanAll")]
        getter scan_all : Bool?

        def initialize(
          @connection_name : String? = nil,
          @path : String? = nil,
          @scan_all : Bool? = nil
        )
        end
      end

      # Specifies a MySQL data source in the Glue Data Catalog.

      struct MySQLCatalogSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        def initialize(
          @database : String,
          @name : String,
          @table : String
        )
        end
      end

      # Specifies a target that uses MySQL.

      struct MySQLCatalogTarget
        include JSON::Serializable

        # The name of the database to write to.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to write to.

        @[JSON::Field(key: "Table")]
        getter table : String

        def initialize(
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String
        )
        end
      end

      # There is no applicable schedule.

      struct NoScheduleException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # A node represents an Glue component (trigger, crawler, or job) on a workflow graph.

      struct Node
        include JSON::Serializable

        # Details of the crawler when the node represents a crawler.

        @[JSON::Field(key: "CrawlerDetails")]
        getter crawler_details : Types::CrawlerNodeDetails?

        # Details of the Job when the node represents a Job.

        @[JSON::Field(key: "JobDetails")]
        getter job_details : Types::JobNodeDetails?

        # The name of the Glue component represented by the node.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # Details of the Trigger when the node represents a Trigger.

        @[JSON::Field(key: "TriggerDetails")]
        getter trigger_details : Types::TriggerNodeDetails?

        # The type of Glue component represented by the node.

        @[JSON::Field(key: "Type")]
        getter type : String?

        # The unique Id assigned to the node within the workflow.

        @[JSON::Field(key: "UniqueId")]
        getter unique_id : String?

        def initialize(
          @crawler_details : Types::CrawlerNodeDetails? = nil,
          @job_details : Types::JobNodeDetails? = nil,
          @name : String? = nil,
          @trigger_details : Types::TriggerNodeDetails? = nil,
          @type : String? = nil,
          @unique_id : String? = nil
        )
        end
      end

      # Specifies configuration properties of a notification.

      struct NotificationProperty
        include JSON::Serializable

        # After a job run starts, the number of minutes to wait before sending a job run delay notification.

        @[JSON::Field(key: "NotifyDelayAfter")]
        getter notify_delay_after : Int32?

        def initialize(
          @notify_delay_after : Int32? = nil
        )
        end
      end

      # Represents whether certain values are recognized as null values for removal.

      struct NullCheckBoxList
        include JSON::Serializable

        # Specifies that an empty string is considered as a null value.

        @[JSON::Field(key: "IsEmpty")]
        getter is_empty : Bool?

        # Specifies that an integer value of -1 is considered as a null value.

        @[JSON::Field(key: "IsNegOne")]
        getter is_neg_one : Bool?

        # Specifies that a value spelling out the word 'null' is considered as a null value.

        @[JSON::Field(key: "IsNullString")]
        getter is_null_string : Bool?

        def initialize(
          @is_empty : Bool? = nil,
          @is_neg_one : Bool? = nil,
          @is_null_string : Bool? = nil
        )
        end
      end

      # Represents a custom null value such as a zeros or other value being used as a null placeholder
      # unique to the dataset.

      struct NullValueField
        include JSON::Serializable

        # The datatype of the value.

        @[JSON::Field(key: "Datatype")]
        getter datatype : Types::Datatype

        # The value of the null placeholder.

        @[JSON::Field(key: "Value")]
        getter value : String

        def initialize(
          @datatype : Types::Datatype,
          @value : String
        )
        end
      end

      # The OAuth2 client app used for the connection.

      struct OAuth2ClientApplication
        include JSON::Serializable

        # The reference to the SaaS-side client app that is Amazon Web Services managed.

        @[JSON::Field(key: "AWSManagedClientApplicationReference")]
        getter aws_managed_client_application_reference : String?

        # The client application clientID if the ClientAppType is USER_MANAGED .

        @[JSON::Field(key: "UserManagedClientApplicationClientId")]
        getter user_managed_client_application_client_id : String?

        def initialize(
          @aws_managed_client_application_reference : String? = nil,
          @user_managed_client_application_client_id : String? = nil
        )
        end
      end

      # The credentials used when the authentication type is OAuth2 authentication.

      struct OAuth2Credentials
        include JSON::Serializable

        # The access token used when the authentication type is OAuth2.

        @[JSON::Field(key: "AccessToken")]
        getter access_token : String?

        # The JSON Web Token (JWT) used when the authentication type is OAuth2.

        @[JSON::Field(key: "JwtToken")]
        getter jwt_token : String?

        # The refresh token used when the authentication type is OAuth2.

        @[JSON::Field(key: "RefreshToken")]
        getter refresh_token : String?

        # The client application client secret if the client application is user managed.

        @[JSON::Field(key: "UserManagedClientApplicationClientSecret")]
        getter user_managed_client_application_client_secret : String?

        def initialize(
          @access_token : String? = nil,
          @jwt_token : String? = nil,
          @refresh_token : String? = nil,
          @user_managed_client_application_client_secret : String? = nil
        )
        end
      end

      # A structure containing properties for OAuth2 authentication.

      struct OAuth2Properties
        include JSON::Serializable

        # The client application type. For example, AWS_MANAGED or USER_MANAGED.

        @[JSON::Field(key: "OAuth2ClientApplication")]
        getter o_auth2_client_application : Types::OAuth2ClientApplication?

        # The OAuth2 grant type. For example, AUTHORIZATION_CODE , JWT_BEARER , or CLIENT_CREDENTIALS .

        @[JSON::Field(key: "OAuth2GrantType")]
        getter o_auth2_grant_type : String?

        # The URL of the provider's authentication server, to exchange an authorization code for an access
        # token.

        @[JSON::Field(key: "TokenUrl")]
        getter token_url : String?

        # A map of parameters that are added to the token GET request.

        @[JSON::Field(key: "TokenUrlParametersMap")]
        getter token_url_parameters_map : Hash(String, String)?

        def initialize(
          @o_auth2_client_application : Types::OAuth2ClientApplication? = nil,
          @o_auth2_grant_type : String? = nil,
          @token_url : String? = nil,
          @token_url_parameters_map : Hash(String, String)? = nil
        )
        end
      end

      # A structure containing properties for OAuth2 in the CreateConnection request.

      struct OAuth2PropertiesInput
        include JSON::Serializable

        # The set of properties required for the the OAuth2 AUTHORIZATION_CODE grant type.

        @[JSON::Field(key: "AuthorizationCodeProperties")]
        getter authorization_code_properties : Types::AuthorizationCodeProperties?

        # The client application type in the CreateConnection request. For example, AWS_MANAGED or
        # USER_MANAGED .

        @[JSON::Field(key: "OAuth2ClientApplication")]
        getter o_auth2_client_application : Types::OAuth2ClientApplication?

        # The credentials used when the authentication type is OAuth2 authentication.

        @[JSON::Field(key: "OAuth2Credentials")]
        getter o_auth2_credentials : Types::OAuth2Credentials?

        # The OAuth2 grant type in the CreateConnection request. For example, AUTHORIZATION_CODE , JWT_BEARER
        # , or CLIENT_CREDENTIALS .

        @[JSON::Field(key: "OAuth2GrantType")]
        getter o_auth2_grant_type : String?

        # The URL of the provider's authentication server, to exchange an authorization code for an access
        # token.

        @[JSON::Field(key: "TokenUrl")]
        getter token_url : String?

        # A map of parameters that are added to the token GET request.

        @[JSON::Field(key: "TokenUrlParametersMap")]
        getter token_url_parameters_map : Hash(String, String)?

        def initialize(
          @authorization_code_properties : Types::AuthorizationCodeProperties? = nil,
          @o_auth2_client_application : Types::OAuth2ClientApplication? = nil,
          @o_auth2_credentials : Types::OAuth2Credentials? = nil,
          @o_auth2_grant_type : String? = nil,
          @token_url : String? = nil,
          @token_url_parameters_map : Hash(String, String)? = nil
        )
        end
      end

      # A structure representing an open format table.

      struct OpenTableFormatInput
        include JSON::Serializable

        # Specifies an IcebergInput structure that defines an Apache Iceberg metadata table.

        @[JSON::Field(key: "IcebergInput")]
        getter iceberg_input : Types::IcebergInput?

        def initialize(
          @iceberg_input : Types::IcebergInput? = nil
        )
        end
      end

      # The operation is not available in the region.

      struct OperationNotSupportedException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The operation timed out.

      struct OperationTimeoutException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Specifies an option value.

      struct Option
        include JSON::Serializable

        # Specifies the description of the option.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Specifies the label of the option.

        @[JSON::Field(key: "Label")]
        getter label : String?

        # Specifies the value of the option.

        @[JSON::Field(key: "Value")]
        getter value : String?

        def initialize(
          @description : String? = nil,
          @label : String? = nil,
          @value : String? = nil
        )
        end
      end

      # Specifies an Oracle data source in the Glue Data Catalog.

      struct OracleSQLCatalogSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        def initialize(
          @database : String,
          @name : String,
          @table : String
        )
        end
      end

      # Specifies a target that uses Oracle SQL.

      struct OracleSQLCatalogTarget
        include JSON::Serializable

        # The name of the database to write to.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to write to.

        @[JSON::Field(key: "Table")]
        getter table : String

        def initialize(
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String
        )
        end
      end

      # Specifies the sort order of a sorted column.

      struct Order
        include JSON::Serializable

        # The name of the column.

        @[JSON::Field(key: "Column")]
        getter column : String

        # Indicates that the column is sorted in ascending order ( == 1 ), or in descending order ( ==0 ).

        @[JSON::Field(key: "SortOrder")]
        getter sort_order : Int32

        def initialize(
          @column : String,
          @sort_order : Int32
        )
        end
      end

      # The configuration for an orphan file deletion optimizer.

      struct OrphanFileDeletionConfiguration
        include JSON::Serializable

        # The configuration for an Iceberg orphan file deletion optimizer.

        @[JSON::Field(key: "icebergConfiguration")]
        getter iceberg_configuration : Types::IcebergOrphanFileDeletionConfiguration?

        def initialize(
          @iceberg_configuration : Types::IcebergOrphanFileDeletionConfiguration? = nil
        )
        end
      end

      # A structure that contains orphan file deletion metrics for the optimizer run.

      struct OrphanFileDeletionMetrics
        include JSON::Serializable

        # A structure containing the Iceberg orphan file deletion metrics for the optimizer run.

        @[JSON::Field(key: "IcebergMetrics")]
        getter iceberg_metrics : Types::IcebergOrphanFileDeletionMetrics?

        def initialize(
          @iceberg_metrics : Types::IcebergOrphanFileDeletionMetrics? = nil
        )
        end
      end

      # A structure containing other metadata for a schema version belonging to the same metadata key.

      struct OtherMetadataValueListItem
        include JSON::Serializable

        # The time at which the entry was created.

        @[JSON::Field(key: "CreatedTime")]
        getter created_time : String?

        # The metadata keys corresponding value for the other metadata belonging to the same metadata key.

        @[JSON::Field(key: "MetadataValue")]
        getter metadata_value : String?

        def initialize(
          @created_time : String? = nil,
          @metadata_value : String? = nil
        )
        end
      end

      # Specifies a transform that identifies, removes or masks PII data.

      struct PIIDetection
        include JSON::Serializable

        # Indicates the types of entities the PIIDetection transform will identify as PII data. PII type
        # entities include: PERSON_NAME, DATE, USA_SNN, EMAIL, USA_ITIN, USA_PASSPORT_NUMBER, PHONE_NUMBER,
        # BANK_ACCOUNT, IP_ADDRESS, MAC_ADDRESS, USA_CPT_CODE, USA_HCPCS_CODE, USA_NATIONAL_DRUG_CODE,
        # USA_MEDICARE_BENEFICIARY_IDENTIFIER,
        # USA_HEALTH_INSURANCE_CLAIM_NUMBER,CREDIT_CARD,USA_NATIONAL_PROVIDER_IDENTIFIER,USA_DEA_NUMBER,USA_DRIVING_LICENSE

        @[JSON::Field(key: "EntityTypesToDetect")]
        getter entity_types_to_detect : Array(String)

        # The node ID inputs to the transform.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Indicates the type of PIIDetection transform.

        @[JSON::Field(key: "PiiType")]
        getter pii_type : String

        # Additional parameters for configuring PII detection behavior and sensitivity settings.

        @[JSON::Field(key: "DetectionParameters")]
        getter detection_parameters : String?

        # The sensitivity level for PII detection. Higher sensitivity levels detect more potential PII but may
        # result in more false positives.

        @[JSON::Field(key: "DetectionSensitivity")]
        getter detection_sensitivity : String?

        # Indicates the value that will replace the detected entity.

        @[JSON::Field(key: "MaskValue")]
        getter mask_value : String?

        # A regular expression pattern used to identify additional PII content beyond the standard detection
        # algorithms.

        @[JSON::Field(key: "MatchPattern")]
        getter match_pattern : String?

        # The number of characters to exclude from redaction on the left side of detected PII content. This
        # allows preserving context around the sensitive data.

        @[JSON::Field(key: "NumLeftCharsToExclude")]
        getter num_left_chars_to_exclude : Int32?

        # The number of characters to exclude from redaction on the right side of detected PII content. This
        # allows preserving context around the sensitive data.

        @[JSON::Field(key: "NumRightCharsToExclude")]
        getter num_right_chars_to_exclude : Int32?

        # Indicates the output column name that will contain any entity type detected in that row.

        @[JSON::Field(key: "OutputColumnName")]
        getter output_column_name : String?

        # The character used to replace detected PII content when redaction is enabled. The default redaction
        # character is * .

        @[JSON::Field(key: "RedactChar")]
        getter redact_char : String?

        # Specifies whether to redact the detected PII text. When set to true , PII content is replaced with
        # redaction characters.

        @[JSON::Field(key: "RedactText")]
        getter redact_text : String?

        # Indicates the fraction of the data to sample when scanning for PII entities.

        @[JSON::Field(key: "SampleFraction")]
        getter sample_fraction : Float64?

        # Indicates the fraction of the data that must be met in order for a column to be identified as PII
        # data.

        @[JSON::Field(key: "ThresholdFraction")]
        getter threshold_fraction : Float64?

        def initialize(
          @entity_types_to_detect : Array(String),
          @inputs : Array(String),
          @name : String,
          @pii_type : String,
          @detection_parameters : String? = nil,
          @detection_sensitivity : String? = nil,
          @mask_value : String? = nil,
          @match_pattern : String? = nil,
          @num_left_chars_to_exclude : Int32? = nil,
          @num_right_chars_to_exclude : Int32? = nil,
          @output_column_name : String? = nil,
          @redact_char : String? = nil,
          @redact_text : String? = nil,
          @sample_fraction : Float64? = nil,
          @threshold_fraction : Float64? = nil
        )
        end
      end

      # Represents a slice of table data.

      struct Partition
        include JSON::Serializable

        # The ID of the Data Catalog in which the partition resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The time at which the partition was created.

        @[JSON::Field(key: "CreationTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter creation_time : Time?

        # The name of the catalog database in which to create the partition.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # The last time at which the partition was accessed.

        @[JSON::Field(key: "LastAccessTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_access_time : Time?

        # The last time at which column statistics were computed for this partition.

        @[JSON::Field(key: "LastAnalyzedTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_analyzed_time : Time?

        # These key-value pairs define partition parameters.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # Provides information about the physical location where the partition is stored.

        @[JSON::Field(key: "StorageDescriptor")]
        getter storage_descriptor : Types::StorageDescriptor?

        # The name of the database table in which to create the partition.

        @[JSON::Field(key: "TableName")]
        getter table_name : String?

        # The values of the partition.

        @[JSON::Field(key: "Values")]
        getter values : Array(String)?

        def initialize(
          @catalog_id : String? = nil,
          @creation_time : Time? = nil,
          @database_name : String? = nil,
          @last_access_time : Time? = nil,
          @last_analyzed_time : Time? = nil,
          @parameters : Hash(String, String)? = nil,
          @storage_descriptor : Types::StorageDescriptor? = nil,
          @table_name : String? = nil,
          @values : Array(String)? = nil
        )
        end
      end

      # Contains information about a partition error.

      struct PartitionError
        include JSON::Serializable

        # The details about the partition error.

        @[JSON::Field(key: "ErrorDetail")]
        getter error_detail : Types::ErrorDetail?

        # The values that define the partition.

        @[JSON::Field(key: "PartitionValues")]
        getter partition_values : Array(String)?

        def initialize(
          @error_detail : Types::ErrorDetail? = nil,
          @partition_values : Array(String)? = nil
        )
        end
      end

      # A structure for a partition index.

      struct PartitionIndex
        include JSON::Serializable

        # The name of the partition index.

        @[JSON::Field(key: "IndexName")]
        getter index_name : String

        # The keys for the partition index.

        @[JSON::Field(key: "Keys")]
        getter keys : Array(String)

        def initialize(
          @index_name : String,
          @keys : Array(String)
        )
        end
      end

      # A descriptor for a partition index in a table.

      struct PartitionIndexDescriptor
        include JSON::Serializable

        # The name of the partition index.

        @[JSON::Field(key: "IndexName")]
        getter index_name : String

        # The status of the partition index. The possible statuses are: CREATING: The index is being created.
        # When an index is in a CREATING state, the index or its table cannot be deleted. ACTIVE: The index
        # creation succeeds. FAILED: The index creation fails. DELETING: The index is deleted from the list of
        # indexes.

        @[JSON::Field(key: "IndexStatus")]
        getter index_status : String

        # A list of one or more keys, as KeySchemaElement structures, for the partition index.

        @[JSON::Field(key: "Keys")]
        getter keys : Array(Types::KeySchemaElement)

        # A list of errors that can occur when registering partition indexes for an existing table.

        @[JSON::Field(key: "BackfillErrors")]
        getter backfill_errors : Array(Types::BackfillError)?

        def initialize(
          @index_name : String,
          @index_status : String,
          @keys : Array(Types::KeySchemaElement),
          @backfill_errors : Array(Types::BackfillError)? = nil
        )
        end
      end

      # The structure used to create and update a partition.

      struct PartitionInput
        include JSON::Serializable

        # The last time at which the partition was accessed.

        @[JSON::Field(key: "LastAccessTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_access_time : Time?

        # The last time at which column statistics were computed for this partition.

        @[JSON::Field(key: "LastAnalyzedTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_analyzed_time : Time?

        # These key-value pairs define partition parameters.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # Provides information about the physical location where the partition is stored.

        @[JSON::Field(key: "StorageDescriptor")]
        getter storage_descriptor : Types::StorageDescriptor?

        # The values of the partition. Although this parameter is not required by the SDK, you must specify
        # this parameter for a valid input. The values for the keys for the new partition must be passed as an
        # array of String objects that must be ordered in the same order as the partition keys appearing in
        # the Amazon S3 prefix. Otherwise Glue will add the values to the wrong keys.

        @[JSON::Field(key: "Values")]
        getter values : Array(String)?

        def initialize(
          @last_access_time : Time? = nil,
          @last_analyzed_time : Time? = nil,
          @parameters : Hash(String, String)? = nil,
          @storage_descriptor : Types::StorageDescriptor? = nil,
          @values : Array(String)? = nil
        )
        end
      end

      # Contains a list of values defining partitions.

      struct PartitionValueList
        include JSON::Serializable

        # The list of values.

        @[JSON::Field(key: "Values")]
        getter values : Array(String)

        def initialize(
          @values : Array(String)
        )
        end
      end

      # The operation timed out.

      struct PermissionTypeMismatchException
        include JSON::Serializable

        # There is a mismatch between the SupportedPermissionType used in the query request and the
        # permissions defined on the target table.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The OAuth client app in GetConnection response.

      struct PhysicalConnectionRequirements
        include JSON::Serializable

        # The connection's Availability Zone.

        @[JSON::Field(key: "AvailabilityZone")]
        getter availability_zone : String?

        # The security group ID list used by the connection.

        @[JSON::Field(key: "SecurityGroupIdList")]
        getter security_group_id_list : Array(String)?

        # The subnet ID used by the connection.

        @[JSON::Field(key: "SubnetId")]
        getter subnet_id : String?

        def initialize(
          @availability_zone : String? = nil,
          @security_group_id_list : Array(String)? = nil,
          @subnet_id : String? = nil
        )
        end
      end

      # Specifies a PostgresSQL data source in the Glue Data Catalog.

      struct PostgreSQLCatalogSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        def initialize(
          @database : String,
          @name : String,
          @table : String
        )
        end
      end

      # Specifies a target that uses Postgres SQL.

      struct PostgreSQLCatalogTarget
        include JSON::Serializable

        # The name of the database to write to.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to write to.

        @[JSON::Field(key: "Table")]
        getter table : String

        def initialize(
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String
        )
        end
      end

      # A job run that was used in the predicate of a conditional trigger that triggered this job run.

      struct Predecessor
        include JSON::Serializable

        # The name of the job definition used by the predecessor job run.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # The job-run ID of the predecessor job run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        def initialize(
          @job_name : String? = nil,
          @run_id : String? = nil
        )
        end
      end

      # Defines the predicate of the trigger, which determines when it fires.

      struct Predicate
        include JSON::Serializable

        # A list of the conditions that determine when the trigger will fire.

        @[JSON::Field(key: "Conditions")]
        getter conditions : Array(Types::Condition)?

        # An optional field if only one condition is listed. If multiple conditions are listed, then this
        # field is required.

        @[JSON::Field(key: "Logical")]
        getter logical : String?

        def initialize(
          @conditions : Array(Types::Condition)? = nil,
          @logical : String? = nil
        )
        end
      end

      # Permissions granted to a principal.

      struct PrincipalPermissions
        include JSON::Serializable

        # The permissions that are granted to the principal.

        @[JSON::Field(key: "Permissions")]
        getter permissions : Array(String)?

        # The principal who is granted permissions.

        @[JSON::Field(key: "Principal")]
        getter principal : Types::DataLakePrincipal?

        def initialize(
          @permissions : Array(String)? = nil,
          @principal : Types::DataLakePrincipal? = nil
        )
        end
      end

      # Specifies the job and session values that an admin configures in an Glue usage profile.

      struct ProfileConfiguration
        include JSON::Serializable

        # A key-value map of configuration parameters for Glue jobs.

        @[JSON::Field(key: "JobConfiguration")]
        getter job_configuration : Hash(String, Types::ConfigurationObject)?

        # A key-value map of configuration parameters for Glue sessions.

        @[JSON::Field(key: "SessionConfiguration")]
        getter session_configuration : Hash(String, Types::ConfigurationObject)?

        def initialize(
          @job_configuration : Hash(String, Types::ConfigurationObject)? = nil,
          @session_configuration : Hash(String, Types::ConfigurationObject)? = nil
        )
        end
      end

      # An object that defines a connection type for a compute environment.

      struct Property
        include JSON::Serializable

        # A description of the property.

        @[JSON::Field(key: "Description")]
        getter description : String

        # The name of the property.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Describes the type of property.

        @[JSON::Field(key: "PropertyTypes")]
        getter property_types : Array(String)

        # Indicates whether the property is required.

        @[JSON::Field(key: "Required")]
        getter required : Bool

        # A list of AllowedValue objects representing the values allowed for the property.

        @[JSON::Field(key: "AllowedValues")]
        getter allowed_values : Array(Types::AllowedValue)?

        # Indicates which data operations are applicable to the property.

        @[JSON::Field(key: "DataOperationScopes")]
        getter data_operation_scopes : Array(String)?

        # The default value for the property.

        @[JSON::Field(key: "DefaultValue")]
        getter default_value : String?

        def initialize(
          @description : String,
          @name : String,
          @property_types : Array(String),
          @required : Bool,
          @allowed_values : Array(Types::AllowedValue)? = nil,
          @data_operation_scopes : Array(String)? = nil,
          @default_value : String? = nil
        )
        end
      end

      # Defines a property predicate.

      struct PropertyPredicate
        include JSON::Serializable

        # The comparator used to compare this property to others.

        @[JSON::Field(key: "Comparator")]
        getter comparator : String?

        # The key of the property.

        @[JSON::Field(key: "Key")]
        getter key : String?

        # The value of the property.

        @[JSON::Field(key: "Value")]
        getter value : String?

        def initialize(
          @comparator : String? = nil,
          @key : String? = nil,
          @value : String? = nil
        )
        end
      end


      struct PutDataCatalogEncryptionSettingsRequest
        include JSON::Serializable

        # The security configuration to set.

        @[JSON::Field(key: "DataCatalogEncryptionSettings")]
        getter data_catalog_encryption_settings : Types::DataCatalogEncryptionSettings

        # The ID of the Data Catalog to set the security configuration for. If none is provided, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @data_catalog_encryption_settings : Types::DataCatalogEncryptionSettings,
          @catalog_id : String? = nil
        )
        end
      end


      struct PutDataCatalogEncryptionSettingsResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct PutDataQualityProfileAnnotationRequest
        include JSON::Serializable

        # The inclusion annotation value to apply to the profile.

        @[JSON::Field(key: "InclusionAnnotation")]
        getter inclusion_annotation : String

        # The ID of the data quality monitoring profile to annotate.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String

        def initialize(
          @inclusion_annotation : String,
          @profile_id : String
        )
        end
      end

      # Left blank.

      struct PutDataQualityProfileAnnotationResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct PutResourcePolicyRequest
        include JSON::Serializable

        # Contains the policy document to set, in JSON format.

        @[JSON::Field(key: "PolicyInJson")]
        getter policy_in_json : String

        # If 'TRUE' , indicates that you are using both methods to grant cross-account access to Data Catalog
        # resources: By directly updating the resource policy with PutResourePolicy By using the Grant
        # permissions command on the Amazon Web Services Management Console. Must be set to 'TRUE' if you have
        # already used the Management Console to grant cross-account access, otherwise the call fails. Default
        # is 'FALSE'.

        @[JSON::Field(key: "EnableHybrid")]
        getter enable_hybrid : String?

        # A value of MUST_EXIST is used to update a policy. A value of NOT_EXIST is used to create a new
        # policy. If a value of NONE or a null value is used, the call does not depend on the existence of a
        # policy.

        @[JSON::Field(key: "PolicyExistsCondition")]
        getter policy_exists_condition : String?

        # The hash value returned when the previous policy was set using PutResourcePolicy . Its purpose is to
        # prevent concurrent modifications of a policy. Do not use this parameter if no previous policy has
        # been set.

        @[JSON::Field(key: "PolicyHashCondition")]
        getter policy_hash_condition : String?

        # Do not use. For internal use only.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String?

        def initialize(
          @policy_in_json : String,
          @enable_hybrid : String? = nil,
          @policy_exists_condition : String? = nil,
          @policy_hash_condition : String? = nil,
          @resource_arn : String? = nil
        )
        end
      end


      struct PutResourcePolicyResponse
        include JSON::Serializable

        # A hash of the policy that has just been set. This must be included in a subsequent call that
        # overwrites or updates this policy.

        @[JSON::Field(key: "PolicyHash")]
        getter policy_hash : String?

        def initialize(
          @policy_hash : String? = nil
        )
        end
      end


      struct PutSchemaVersionMetadataInput
        include JSON::Serializable

        # The metadata key's corresponding value.

        @[JSON::Field(key: "MetadataKeyValue")]
        getter metadata_key_value : Types::MetadataKeyValuePair

        # The unique ID for the schema.

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId?

        # The unique version ID of the schema version.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The version number of the schema.

        @[JSON::Field(key: "SchemaVersionNumber")]
        getter schema_version_number : Types::SchemaVersionNumber?

        def initialize(
          @metadata_key_value : Types::MetadataKeyValuePair,
          @schema_id : Types::SchemaId? = nil,
          @schema_version_id : String? = nil,
          @schema_version_number : Types::SchemaVersionNumber? = nil
        )
        end
      end


      struct PutSchemaVersionMetadataResponse
        include JSON::Serializable

        # The latest version of the schema.

        @[JSON::Field(key: "LatestVersion")]
        getter latest_version : Bool?

        # The metadata key.

        @[JSON::Field(key: "MetadataKey")]
        getter metadata_key : String?

        # The value of the metadata key.

        @[JSON::Field(key: "MetadataValue")]
        getter metadata_value : String?

        # The name for the registry.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The Amazon Resource Name (ARN) for the schema.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The name for the schema.

        @[JSON::Field(key: "SchemaName")]
        getter schema_name : String?

        # The unique version ID of the schema version.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The version number of the schema.

        @[JSON::Field(key: "VersionNumber")]
        getter version_number : Int64?

        def initialize(
          @latest_version : Bool? = nil,
          @metadata_key : String? = nil,
          @metadata_value : String? = nil,
          @registry_name : String? = nil,
          @schema_arn : String? = nil,
          @schema_name : String? = nil,
          @schema_version_id : String? = nil,
          @version_number : Int64? = nil
        )
        end
      end


      struct PutWorkflowRunPropertiesRequest
        include JSON::Serializable

        # Name of the workflow which was run.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the workflow run for which the run properties should be updated.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        # The properties to put for the specified run. Run properties may be logged. Do not pass plaintext
        # secrets as properties. Retrieve secrets from a Glue Connection, Amazon Web Services Secrets Manager
        # or other secret management mechanism if you intend to use them within the workflow run.

        @[JSON::Field(key: "RunProperties")]
        getter run_properties : Hash(String, String)

        def initialize(
          @name : String,
          @run_id : String,
          @run_properties : Hash(String, String)
        )
        end
      end


      struct PutWorkflowRunPropertiesResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct QuerySchemaVersionMetadataInput
        include JSON::Serializable

        # Maximum number of results required per page. If the value is not supplied, this will be defaulted to
        # 25 per page.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # Search key-value pairs for metadata, if they are not provided all the metadata information will be
        # fetched.

        @[JSON::Field(key: "MetadataList")]
        getter metadata_list : Array(Types::MetadataKeyValuePair)?

        # A continuation token, if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId?

        # The unique version ID of the schema version.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The version number of the schema.

        @[JSON::Field(key: "SchemaVersionNumber")]
        getter schema_version_number : Types::SchemaVersionNumber?

        def initialize(
          @max_results : Int32? = nil,
          @metadata_list : Array(Types::MetadataKeyValuePair)? = nil,
          @next_token : String? = nil,
          @schema_id : Types::SchemaId? = nil,
          @schema_version_id : String? = nil,
          @schema_version_number : Types::SchemaVersionNumber? = nil
        )
        end
      end


      struct QuerySchemaVersionMetadataResponse
        include JSON::Serializable

        # A map of a metadata key and associated values.

        @[JSON::Field(key: "MetadataInfoMap")]
        getter metadata_info_map : Hash(String, Types::MetadataInfo)?

        # A continuation token for paginating the returned list of tokens, returned if the current segment of
        # the list is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # The unique version ID of the schema version.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        def initialize(
          @metadata_info_map : Hash(String, Types::MetadataInfo)? = nil,
          @next_token : String? = nil,
          @schema_version_id : String? = nil
        )
        end
      end

      # A structure used as a protocol between query engines and Lake Formation or Glue. Contains both a
      # Lake Formation generated authorization identifier and information from the request's authorization
      # context.

      struct QuerySessionContext
        include JSON::Serializable

        # An opaque string-string map passed by the query engine.

        @[JSON::Field(key: "AdditionalContext")]
        getter additional_context : Hash(String, String)?

        # An identifier string for the consumer cluster.

        @[JSON::Field(key: "ClusterId")]
        getter cluster_id : String?

        # A cryptographically generated query identifier generated by Glue or Lake Formation.

        @[JSON::Field(key: "QueryAuthorizationId")]
        getter query_authorization_id : String?

        # A unique identifier generated by the query engine for the query.

        @[JSON::Field(key: "QueryId")]
        getter query_id : String?

        # A timestamp provided by the query engine for when the query started.

        @[JSON::Field(key: "QueryStartTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter query_start_time : Time?

        def initialize(
          @additional_context : Hash(String, String)? = nil,
          @cluster_id : String? = nil,
          @query_authorization_id : String? = nil,
          @query_id : String? = nil,
          @query_start_time : Time? = nil
        )
        end
      end

      # A Glue Studio node that uses a Glue DataBrew recipe in Glue jobs.

      struct Recipe
        include JSON::Serializable

        # The nodes that are inputs to the recipe node, identified by id.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the Glue Studio node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A reference to the DataBrew recipe used by the node.

        @[JSON::Field(key: "RecipeReference")]
        getter recipe_reference : Types::RecipeReference?

        # Transform steps used in the recipe node.

        @[JSON::Field(key: "RecipeSteps")]
        getter recipe_steps : Array(Types::RecipeStep)?

        def initialize(
          @inputs : Array(String),
          @name : String,
          @recipe_reference : Types::RecipeReference? = nil,
          @recipe_steps : Array(Types::RecipeStep)? = nil
        )
        end
      end

      # Actions defined in the Glue Studio data preparation recipe node.

      struct RecipeAction
        include JSON::Serializable

        # The operation of the recipe action.

        @[JSON::Field(key: "Operation")]
        getter operation : String

        # The parameters of the recipe action.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        def initialize(
          @operation : String,
          @parameters : Hash(String, String)? = nil
        )
        end
      end

      # A reference to a Glue DataBrew recipe.

      struct RecipeReference
        include JSON::Serializable

        # The ARN of the DataBrew recipe.

        @[JSON::Field(key: "RecipeArn")]
        getter recipe_arn : String

        # The RecipeVersion of the DataBrew recipe.

        @[JSON::Field(key: "RecipeVersion")]
        getter recipe_version : String

        def initialize(
          @recipe_arn : String,
          @recipe_version : String
        )
        end
      end

      # A recipe step used in a Glue Studio data preparation recipe node.

      struct RecipeStep
        include JSON::Serializable

        # The transformation action of the recipe step.

        @[JSON::Field(key: "Action")]
        getter action : Types::RecipeAction

        # The condition expressions for the recipe step.

        @[JSON::Field(key: "ConditionExpressions")]
        getter condition_expressions : Array(Types::ConditionExpression)?

        def initialize(
          @action : Types::RecipeAction,
          @condition_expressions : Array(Types::ConditionExpression)? = nil
        )
        end
      end


      struct Record
        include JSON::Serializable

        def initialize
        end
      end

      # When crawling an Amazon S3 data source after the first crawl is complete, specifies whether to crawl
      # the entire dataset again or to crawl only folders that were added since the last crawler run. For
      # more information, see Incremental Crawls in Glue in the developer guide.

      struct RecrawlPolicy
        include JSON::Serializable

        # Specifies whether to crawl the entire dataset again or to crawl only folders that were added since
        # the last crawler run. A value of CRAWL_EVERYTHING specifies crawling the entire dataset again. A
        # value of CRAWL_NEW_FOLDERS_ONLY specifies crawling only folders that were added since the last
        # crawler run. A value of CRAWL_EVENT_MODE specifies crawling only the changes identified by Amazon S3
        # events.

        @[JSON::Field(key: "RecrawlBehavior")]
        getter recrawl_behavior : String?

        def initialize(
          @recrawl_behavior : String? = nil
        )
        end
      end

      # Specifies an Amazon Redshift data store.

      struct RedshiftSource
        include JSON::Serializable

        # The database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the Amazon Redshift data store.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The database table to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # The Amazon S3 path where temporary data can be staged when copying out of the database.

        @[JSON::Field(key: "RedshiftTmpDir")]
        getter redshift_tmp_dir : String?

        # The IAM role with permissions.

        @[JSON::Field(key: "TmpDirIAMRole")]
        getter tmp_dir_iam_role : String?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @redshift_tmp_dir : String? = nil,
          @tmp_dir_iam_role : String? = nil
        )
        end
      end

      # Specifies a target that uses Amazon Redshift.

      struct RedshiftTarget
        include JSON::Serializable

        # The name of the database to write to.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to write to.

        @[JSON::Field(key: "Table")]
        getter table : String

        # The Amazon S3 path where temporary data can be staged when copying out of the database.

        @[JSON::Field(key: "RedshiftTmpDir")]
        getter redshift_tmp_dir : String?

        # The IAM role with permissions.

        @[JSON::Field(key: "TmpDirIAMRole")]
        getter tmp_dir_iam_role : String?

        # The set of options to configure an upsert operation when writing to a Redshift target.

        @[JSON::Field(key: "UpsertRedshiftOptions")]
        getter upsert_redshift_options : Types::UpsertRedshiftTargetOptions?

        def initialize(
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String,
          @redshift_tmp_dir : String? = nil,
          @tmp_dir_iam_role : String? = nil,
          @upsert_redshift_options : Types::UpsertRedshiftTargetOptions? = nil
        )
        end
      end


      struct RegisterSchemaVersionInput
        include JSON::Serializable

        # The schema definition using the DataFormat setting for the SchemaName .

        @[JSON::Field(key: "SchemaDefinition")]
        getter schema_definition : String

        # This is a wrapper structure to contain schema identity fields. The structure contains:
        # SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. Either SchemaArn or SchemaName and
        # RegistryName has to be provided. SchemaId$SchemaName: The name of the schema. Either SchemaArn or
        # SchemaName and RegistryName has to be provided.

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId

        def initialize(
          @schema_definition : String,
          @schema_id : Types::SchemaId
        )
        end
      end


      struct RegisterSchemaVersionResponse
        include JSON::Serializable

        # The unique ID that represents the version of this schema.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The status of the schema version.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The version of this schema (for sync flow only, in case this is the first version).

        @[JSON::Field(key: "VersionNumber")]
        getter version_number : Int64?

        def initialize(
          @schema_version_id : String? = nil,
          @status : String? = nil,
          @version_number : Int64? = nil
        )
        end
      end

      # A wrapper structure that may contain the registry name and Amazon Resource Name (ARN).

      struct RegistryId
        include JSON::Serializable

        # Arn of the registry to be updated. One of RegistryArn or RegistryName has to be provided.

        @[JSON::Field(key: "RegistryArn")]
        getter registry_arn : String?

        # Name of the registry. Used only for lookup. One of RegistryArn or RegistryName has to be provided.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        def initialize(
          @registry_arn : String? = nil,
          @registry_name : String? = nil
        )
        end
      end

      # A structure containing the details for a registry.

      struct RegistryListItem
        include JSON::Serializable

        # The data the registry was created.

        @[JSON::Field(key: "CreatedTime")]
        getter created_time : String?

        # A description of the registry.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The Amazon Resource Name (ARN) of the registry.

        @[JSON::Field(key: "RegistryArn")]
        getter registry_arn : String?

        # The name of the registry.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The status of the registry.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The date the registry was updated.

        @[JSON::Field(key: "UpdatedTime")]
        getter updated_time : String?

        def initialize(
          @created_time : String? = nil,
          @description : String? = nil,
          @registry_arn : String? = nil,
          @registry_name : String? = nil,
          @status : String? = nil,
          @updated_time : String? = nil
        )
        end
      end

      # Specifies a Relational database data source in the Glue Data Catalog.

      struct RelationalCatalogSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        def initialize(
          @database : String,
          @name : String,
          @table : String
        )
        end
      end


      struct RemoveSchemaVersionMetadataInput
        include JSON::Serializable

        # The value of the metadata key.

        @[JSON::Field(key: "MetadataKeyValue")]
        getter metadata_key_value : Types::MetadataKeyValuePair

        # A wrapper structure that may contain the schema name and Amazon Resource Name (ARN).

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId?

        # The unique version ID of the schema version.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The version number of the schema.

        @[JSON::Field(key: "SchemaVersionNumber")]
        getter schema_version_number : Types::SchemaVersionNumber?

        def initialize(
          @metadata_key_value : Types::MetadataKeyValuePair,
          @schema_id : Types::SchemaId? = nil,
          @schema_version_id : String? = nil,
          @schema_version_number : Types::SchemaVersionNumber? = nil
        )
        end
      end


      struct RemoveSchemaVersionMetadataResponse
        include JSON::Serializable

        # The latest version of the schema.

        @[JSON::Field(key: "LatestVersion")]
        getter latest_version : Bool?

        # The metadata key.

        @[JSON::Field(key: "MetadataKey")]
        getter metadata_key : String?

        # The value of the metadata key.

        @[JSON::Field(key: "MetadataValue")]
        getter metadata_value : String?

        # The name of the registry.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The Amazon Resource Name (ARN) of the schema.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The name of the schema.

        @[JSON::Field(key: "SchemaName")]
        getter schema_name : String?

        # The version ID for the schema version.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The version number of the schema.

        @[JSON::Field(key: "VersionNumber")]
        getter version_number : Int64?

        def initialize(
          @latest_version : Bool? = nil,
          @metadata_key : String? = nil,
          @metadata_value : String? = nil,
          @registry_name : String? = nil,
          @schema_arn : String? = nil,
          @schema_name : String? = nil,
          @schema_version_id : String? = nil,
          @version_number : Int64? = nil
        )
        end
      end

      # Specifies a transform that renames a single data property key.

      struct RenameField
        include JSON::Serializable

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A JSON path to a variable in the data structure for the source data.

        @[JSON::Field(key: "SourcePath")]
        getter source_path : Array(String)

        # A JSON path to a variable in the data structure for the target data.

        @[JSON::Field(key: "TargetPath")]
        getter target_path : Array(String)

        def initialize(
          @inputs : Array(String),
          @name : String,
          @source_path : Array(String),
          @target_path : Array(String)
        )
        end
      end


      struct ResetJobBookmarkRequest
        include JSON::Serializable

        # The name of the job in question.

        @[JSON::Field(key: "JobName")]
        getter job_name : String

        # The unique run identifier associated with this job run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        def initialize(
          @job_name : String,
          @run_id : String? = nil
        )
        end
      end


      struct ResetJobBookmarkResponse
        include JSON::Serializable

        # The reset bookmark entry.

        @[JSON::Field(key: "JobBookmarkEntry")]
        getter job_bookmark_entry : Types::JobBookmarkEntry?

        def initialize(
          @job_bookmark_entry : Types::JobBookmarkEntry? = nil
        )
        end
      end

      # The resource could not be found.

      struct ResourceNotFoundException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # A resource was not ready for a transaction.

      struct ResourceNotReadyException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # A resource numerical limit was exceeded.

      struct ResourceNumberLimitExceededException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The URIs for function resources.

      struct ResourceUri
        include JSON::Serializable

        # The type of the resource.

        @[JSON::Field(key: "ResourceType")]
        getter resource_type : String?

        # The URI for accessing the resource.

        @[JSON::Field(key: "Uri")]
        getter uri : String?

        def initialize(
          @resource_type : String? = nil,
          @uri : String? = nil
        )
        end
      end


      struct ResumeWorkflowRunRequest
        include JSON::Serializable

        # The name of the workflow to resume.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A list of the node IDs for the nodes you want to restart. The nodes that are to be restarted must
        # have a run attempt in the original run.

        @[JSON::Field(key: "NodeIds")]
        getter node_ids : Array(String)

        # The ID of the workflow run to resume.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        def initialize(
          @name : String,
          @node_ids : Array(String),
          @run_id : String
        )
        end
      end


      struct ResumeWorkflowRunResponse
        include JSON::Serializable

        # A list of the node IDs for the nodes that were actually restarted.

        @[JSON::Field(key: "NodeIds")]
        getter node_ids : Array(String)?

        # The new ID assigned to the resumed workflow run. Each resume of a workflow run will have a new run
        # ID.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        def initialize(
          @node_ids : Array(String)? = nil,
          @run_id : String? = nil
        )
        end
      end

      # The configuration for a snapshot retention optimizer.

      struct RetentionConfiguration
        include JSON::Serializable

        # The configuration for an Iceberg snapshot retention optimizer.

        @[JSON::Field(key: "icebergConfiguration")]
        getter iceberg_configuration : Types::IcebergRetentionConfiguration?

        def initialize(
          @iceberg_configuration : Types::IcebergRetentionConfiguration? = nil
        )
        end
      end

      # A structure that contains retention metrics for the optimizer run.

      struct RetentionMetrics
        include JSON::Serializable

        # A structure containing the Iceberg retention metrics for the optimizer run.

        @[JSON::Field(key: "IcebergMetrics")]
        getter iceberg_metrics : Types::IcebergRetentionMetrics?

        def initialize(
          @iceberg_metrics : Types::IcebergRetentionMetrics? = nil
        )
        end
      end

      # Specifies a route node that directs data to different output paths based on defined filtering
      # conditions.

      struct Route
        include JSON::Serializable

        # A list of group filters that define the routing conditions and criteria for directing data to
        # different output paths.

        @[JSON::Field(key: "GroupFiltersList")]
        getter group_filters_list : Array(Types::GroupFilters)

        # The input connection for the route node.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the route node.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @group_filters_list : Array(Types::GroupFilters),
          @inputs : Array(String),
          @name : String
        )
        end
      end

      # A run identifier.

      struct RunIdentifier
        include JSON::Serializable

        # The Job Run ID.

        @[JSON::Field(key: "JobRunId")]
        getter job_run_id : String?

        # The Run ID.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        def initialize(
          @job_run_id : String? = nil,
          @run_id : String? = nil
        )
        end
      end

      # Metrics for the optimizer run. This structure is deprecated. See the individual metric members for
      # compaction, retention, and orphan file deletion.

      struct RunMetrics
        include JSON::Serializable

        # The duration of the job in hours.

        @[JSON::Field(key: "JobDurationInHour")]
        getter job_duration_in_hour : String?

        # The number of bytes removed by the compaction job run.

        @[JSON::Field(key: "NumberOfBytesCompacted")]
        getter number_of_bytes_compacted : String?

        # The number of DPUs consumed by the job, rounded up to the nearest whole number.

        @[JSON::Field(key: "NumberOfDpus")]
        getter number_of_dpus : String?

        # The number of files removed by the compaction job run.

        @[JSON::Field(key: "NumberOfFilesCompacted")]
        getter number_of_files_compacted : String?

        def initialize(
          @job_duration_in_hour : String? = nil,
          @number_of_bytes_compacted : String? = nil,
          @number_of_dpus : String? = nil,
          @number_of_files_compacted : String? = nil
        )
        end
      end


      struct RunStatementRequest
        include JSON::Serializable

        # The statement code to be run.

        @[JSON::Field(key: "Code")]
        getter code : String

        # The Session Id of the statement to be run.

        @[JSON::Field(key: "SessionId")]
        getter session_id : String

        # The origin of the request.

        @[JSON::Field(key: "RequestOrigin")]
        getter request_origin : String?

        def initialize(
          @code : String,
          @session_id : String,
          @request_origin : String? = nil
        )
        end
      end


      struct RunStatementResponse
        include JSON::Serializable

        # Returns the Id of the statement that was run.

        @[JSON::Field(key: "Id")]
        getter id : Int32?

        def initialize(
          @id : Int32? = nil
        )
        end
      end

      # Specifies a Delta Lake data source that is registered in the Glue Data Catalog. The data source must
      # be stored in Amazon S3.

      struct S3CatalogDeltaSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the Delta Lake data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalDeltaOptions")]
        getter additional_delta_options : Hash(String, String)?

        # Specifies the data schema for the Delta Lake source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @additional_delta_options : Hash(String, String)? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies a Hudi data source that is registered in the Glue Data Catalog. The Hudi data source must
      # be stored in Amazon S3.

      struct S3CatalogHudiSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the Hudi data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalHudiOptions")]
        getter additional_hudi_options : Hash(String, String)?

        # Specifies the data schema for the Hudi source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @additional_hudi_options : Hash(String, String)? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies an Apache Iceberg data source that is registered in the Glue Data Catalog. The Iceberg
      # data source must be stored in Amazon S3.

      struct S3CatalogIcebergSource
        include JSON::Serializable

        # The name of the database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the Iceberg data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options for the Iceberg data source.

        @[JSON::Field(key: "AdditionalIcebergOptions")]
        getter additional_iceberg_options : Hash(String, String)?

        # Specifies the data schema for the Iceberg source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @additional_iceberg_options : Hash(String, String)? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies an Amazon S3 data store in the Glue Data Catalog.

      struct S3CatalogSource
        include JSON::Serializable

        # The database to read from.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The name of the data store.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The database table to read from.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Types::S3SourceAdditionalOptions?

        # Partitions satisfying this predicate are deleted. Files within the retention period in these
        # partitions are not deleted. Set to ""  empty by default.

        @[JSON::Field(key: "PartitionPredicate")]
        getter partition_predicate : String?

        def initialize(
          @database : String,
          @name : String,
          @table : String,
          @additional_options : Types::S3SourceAdditionalOptions? = nil,
          @partition_predicate : String? = nil
        )
        end
      end

      # Specifies a data target that writes to Amazon S3 using the Glue Data Catalog.

      struct S3CatalogTarget
        include JSON::Serializable

        # The name of the database to write to.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to write to.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies whether to automatically enable data quality evaluation for the S3 catalog target. When
        # set to true , data quality checks are performed automatically during the write operation.

        @[JSON::Field(key: "AutoDataQuality")]
        getter auto_data_quality : Types::AutoDataQuality?

        # Specifies native partitioning using a sequence of keys.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # A policy that specifies update behavior for the crawler.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::CatalogSchemaChangePolicy?

        def initialize(
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String,
          @auto_data_quality : Types::AutoDataQuality? = nil,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::CatalogSchemaChangePolicy? = nil
        )
        end
      end

      # Specifies a command-separated value (CSV) data store stored in Amazon S3.

      struct S3CsvSource
        include JSON::Serializable

        # The name of the data store.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A list of the Amazon S3 paths to read from.

        @[JSON::Field(key: "Paths")]
        getter paths : Array(String)

        # Specifies the character to use for quoting. The default is a double quote: '"' . Set this to -1 to
        # turn off quoting entirely.

        @[JSON::Field(key: "QuoteChar")]
        getter quote_char : String

        # Specifies the delimiter character. The default is a comma: ",", but any other character can be
        # specified.

        @[JSON::Field(key: "Separator")]
        getter separator : String

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Types::S3DirectSourceAdditionalOptions?

        # Specifies how the data is compressed. This is generally not necessary if the data has a standard
        # file extension. Possible values are "gzip" and "bzip" ).

        @[JSON::Field(key: "CompressionType")]
        getter compression_type : String?

        # Specifies a character to use for escaping. This option is used only when reading CSV files. The
        # default value is none . If enabled, the character which immediately follows is used as-is, except
        # for a small set of well-known escapes ( \n , \r , \t , and \0 ).

        @[JSON::Field(key: "Escaper")]
        getter escaper : String?

        # A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]"
        # excludes all PDF files.

        @[JSON::Field(key: "Exclusions")]
        getter exclusions : Array(String)?

        # Grouping files is turned on by default when the input contains more than 50,000 files. To turn on
        # grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when
        # there are more than 50,000 files, set this parameter to "none" .

        @[JSON::Field(key: "GroupFiles")]
        getter group_files : String?

        # The target group size in bytes. The default is computed based on the input data size and the size of
        # your cluster. When there are fewer than 50,000 input files, "groupFiles" must be set to
        # "inPartition" for this to take effect.

        @[JSON::Field(key: "GroupSize")]
        getter group_size : String?

        # This option controls the duration in milliseconds after which the s3 listing is likely to be
        # consistent. Files with modification timestamps falling within the last maxBand milliseconds are
        # tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users
        # don't need to set this option. The default is 900000 milliseconds, or 15 minutes.

        @[JSON::Field(key: "MaxBand")]
        getter max_band : Int32?

        # This option specifies the maximum number of files to save from the last maxBand seconds. If this
        # number is exceeded, extra files are skipped and only processed in the next job run.

        @[JSON::Field(key: "MaxFilesInBand")]
        getter max_files_in_band : Int32?

        # A Boolean value that specifies whether a single record can span multiple lines. This can occur when
        # a field contains a quoted new-line character. You must set this option to True if any record spans
        # multiple lines. The default value is False , which allows for more aggressive file-splitting during
        # parsing.

        @[JSON::Field(key: "Multiline")]
        getter multiline : Bool?

        # A Boolean value that specifies whether to use the advanced SIMD CSV reader along with Apache Arrow
        # based columnar memory formats. Only available in Glue version 3.0.

        @[JSON::Field(key: "OptimizePerformance")]
        getter optimize_performance : Bool?

        # Specifies the data schema for the S3 CSV source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # If set to true, recursively reads files in all subdirectories under the specified paths.

        @[JSON::Field(key: "Recurse")]
        getter recurse : Bool?

        # A Boolean value that specifies whether to skip the first data line. The default value is False .

        @[JSON::Field(key: "SkipFirst")]
        getter skip_first : Bool?

        # A Boolean value that specifies whether to treat the first line as a header. The default value is
        # False .

        @[JSON::Field(key: "WithHeader")]
        getter with_header : Bool?

        # A Boolean value that specifies whether to write the header to output. The default value is True .

        @[JSON::Field(key: "WriteHeader")]
        getter write_header : Bool?

        def initialize(
          @name : String,
          @paths : Array(String),
          @quote_char : String,
          @separator : String,
          @additional_options : Types::S3DirectSourceAdditionalOptions? = nil,
          @compression_type : String? = nil,
          @escaper : String? = nil,
          @exclusions : Array(String)? = nil,
          @group_files : String? = nil,
          @group_size : String? = nil,
          @max_band : Int32? = nil,
          @max_files_in_band : Int32? = nil,
          @multiline : Bool? = nil,
          @optimize_performance : Bool? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @recurse : Bool? = nil,
          @skip_first : Bool? = nil,
          @with_header : Bool? = nil,
          @write_header : Bool? = nil
        )
        end
      end

      # Specifies a target that writes to a Delta Lake data source in the Glue Data Catalog.

      struct S3DeltaCatalogTarget
        include JSON::Serializable

        # The name of the database to write to.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to write to.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options for the connector.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?

        # Specifies whether to automatically enable data quality evaluation for the S3 Delta catalog target.
        # When set to true , data quality checks are performed automatically during the write operation.

        @[JSON::Field(key: "AutoDataQuality")]
        getter auto_data_quality : Types::AutoDataQuality?

        # Specifies the data schema for the S3 Delta catalog target.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # Specifies native partitioning using a sequence of keys.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # A policy that specifies update behavior for the crawler.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::CatalogSchemaChangePolicy?

        def initialize(
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String,
          @additional_options : Hash(String, String)? = nil,
          @auto_data_quality : Types::AutoDataQuality? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::CatalogSchemaChangePolicy? = nil
        )
        end
      end

      # Specifies a target that writes to a Delta Lake data source in Amazon S3.

      struct S3DeltaDirectTarget
        include JSON::Serializable

        # Specifies how the data is compressed. This is generally not necessary if the data has a standard
        # file extension. Possible values are "gzip" and "bzip" ).

        @[JSON::Field(key: "Compression")]
        getter compression : String

        # Specifies the data output format for the target.

        @[JSON::Field(key: "Format")]
        getter format : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The Amazon S3 path of your Delta Lake data source to write to.

        @[JSON::Field(key: "Path")]
        getter path : String

        # Specifies additional connection options for the connector.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?

        # Specifies whether to automatically enable data quality evaluation for the S3 Delta direct target.
        # When set to true , data quality checks are performed automatically during the write operation.

        @[JSON::Field(key: "AutoDataQuality")]
        getter auto_data_quality : Types::AutoDataQuality?

        # Specifies the number of target partitions for distributing Delta Lake dataset files across Amazon
        # S3.

        @[JSON::Field(key: "NumberTargetPartitions")]
        getter number_target_partitions : String?

        # Specifies native partitioning using a sequence of keys.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # A policy that specifies update behavior for the crawler.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::DirectSchemaChangePolicy?

        def initialize(
          @compression : String,
          @format : String,
          @inputs : Array(String),
          @name : String,
          @path : String,
          @additional_options : Hash(String, String)? = nil,
          @auto_data_quality : Types::AutoDataQuality? = nil,
          @number_target_partitions : String? = nil,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::DirectSchemaChangePolicy? = nil
        )
        end
      end

      # Specifies a Delta Lake data source stored in Amazon S3.

      struct S3DeltaSource
        include JSON::Serializable

        # The name of the Delta Lake source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A list of the Amazon S3 paths to read from.

        @[JSON::Field(key: "Paths")]
        getter paths : Array(String)

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalDeltaOptions")]
        getter additional_delta_options : Hash(String, String)?

        # Specifies additional options for the connector.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Types::S3DirectSourceAdditionalOptions?

        # Specifies the data schema for the Delta Lake source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @name : String,
          @paths : Array(String),
          @additional_delta_options : Hash(String, String)? = nil,
          @additional_options : Types::S3DirectSourceAdditionalOptions? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies additional connection options for the Amazon S3 data store.

      struct S3DirectSourceAdditionalOptions
        include JSON::Serializable

        # Sets the upper limit for the target number of files that will be processed.

        @[JSON::Field(key: "BoundedFiles")]
        getter bounded_files : Int64?

        # Sets the upper limit for the target size of the dataset in bytes that will be processed.

        @[JSON::Field(key: "BoundedSize")]
        getter bounded_size : Int64?

        # Sets option to enable a sample path.

        @[JSON::Field(key: "EnableSamplePath")]
        getter enable_sample_path : Bool?

        # If enabled, specifies the sample path.

        @[JSON::Field(key: "SamplePath")]
        getter sample_path : String?

        def initialize(
          @bounded_files : Int64? = nil,
          @bounded_size : Int64? = nil,
          @enable_sample_path : Bool? = nil,
          @sample_path : String? = nil
        )
        end
      end

      # Specifies a data target that writes to Amazon S3.

      struct S3DirectTarget
        include JSON::Serializable

        # Specifies the data output format for the target.

        @[JSON::Field(key: "Format")]
        getter format : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A single Amazon S3 path to write to.

        @[JSON::Field(key: "Path")]
        getter path : String

        # Specifies whether to automatically enable data quality evaluation for the S3 direct target. When set
        # to true , data quality checks are performed automatically during the write operation.

        @[JSON::Field(key: "AutoDataQuality")]
        getter auto_data_quality : Types::AutoDataQuality?

        # Specifies how the data is compressed. This is generally not necessary if the data has a standard
        # file extension. Possible values are "gzip" and "bzip" ).

        @[JSON::Field(key: "Compression")]
        getter compression : String?

        # Specifies the number of target partitions when writing data directly to Amazon S3.

        @[JSON::Field(key: "NumberTargetPartitions")]
        getter number_target_partitions : String?

        # Specifies the data schema for the S3 direct target.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # Specifies native partitioning using a sequence of keys.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # A policy that specifies update behavior for the crawler.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::DirectSchemaChangePolicy?

        def initialize(
          @format : String,
          @inputs : Array(String),
          @name : String,
          @path : String,
          @auto_data_quality : Types::AutoDataQuality? = nil,
          @compression : String? = nil,
          @number_target_partitions : String? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::DirectSchemaChangePolicy? = nil
        )
        end
      end

      # Specifies how Amazon Simple Storage Service (Amazon S3) data should be encrypted.

      struct S3Encryption
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the KMS key to be used to encrypt the data.

        @[JSON::Field(key: "KmsKeyArn")]
        getter kms_key_arn : String?

        # The encryption mode to use for Amazon S3 data.

        @[JSON::Field(key: "S3EncryptionMode")]
        getter s3_encryption_mode : String?

        def initialize(
          @kms_key_arn : String? = nil,
          @s3_encryption_mode : String? = nil
        )
        end
      end

      # Specifies an S3 Excel data source.

      struct S3ExcelSource
        include JSON::Serializable

        # The name of the S3 Excel data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The S3 paths where the Excel files are located.

        @[JSON::Field(key: "Paths")]
        getter paths : Array(String)

        # Additional configuration options for S3 direct source processing.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Types::S3DirectSourceAdditionalOptions?

        # The compression format used for the Excel files.

        @[JSON::Field(key: "CompressionType")]
        getter compression_type : String?

        # Patterns to exclude specific files or paths from processing.

        @[JSON::Field(key: "Exclusions")]
        getter exclusions : Array(String)?

        # Specifies how files should be grouped for processing.

        @[JSON::Field(key: "GroupFiles")]
        getter group_files : String?

        # Defines the size of file groups for batch processing.

        @[JSON::Field(key: "GroupSize")]
        getter group_size : String?

        # The maximum number of processing bands to use.

        @[JSON::Field(key: "MaxBand")]
        getter max_band : Int32?

        # The maximum number of files to process in each band.

        @[JSON::Field(key: "MaxFilesInBand")]
        getter max_files_in_band : Int32?

        # The number of rows to process from each Excel file.

        @[JSON::Field(key: "NumberRows")]
        getter number_rows : Int64?

        # The Glue schemas to apply to the processed data.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # Indicates whether to recursively process subdirectories.

        @[JSON::Field(key: "Recurse")]
        getter recurse : Bool?

        # The number of rows to skip at the end of each Excel file.

        @[JSON::Field(key: "SkipFooter")]
        getter skip_footer : Int32?

        def initialize(
          @name : String,
          @paths : Array(String),
          @additional_options : Types::S3DirectSourceAdditionalOptions? = nil,
          @compression_type : String? = nil,
          @exclusions : Array(String)? = nil,
          @group_files : String? = nil,
          @group_size : String? = nil,
          @max_band : Int32? = nil,
          @max_files_in_band : Int32? = nil,
          @number_rows : Int64? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @recurse : Bool? = nil,
          @skip_footer : Int32? = nil
        )
        end
      end

      # Specifies a data target that writes to Amazon S3 in Apache Parquet columnar storage.

      struct S3GlueParquetTarget
        include JSON::Serializable

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A single Amazon S3 path to write to.

        @[JSON::Field(key: "Path")]
        getter path : String

        # Specifies whether to automatically enable data quality evaluation for the S3 Glue Parquet target.
        # When set to true , data quality checks are performed automatically during the write operation.

        @[JSON::Field(key: "AutoDataQuality")]
        getter auto_data_quality : Types::AutoDataQuality?

        # Specifies how the data is compressed. This is generally not necessary if the data has a standard
        # file extension. Possible values are "gzip" and "bzip" ).

        @[JSON::Field(key: "Compression")]
        getter compression : String?

        # Specifies the number of target partitions for Parquet files when writing to Amazon S3 using Glue.

        @[JSON::Field(key: "NumberTargetPartitions")]
        getter number_target_partitions : String?

        # Specifies native partitioning using a sequence of keys.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # A policy that specifies update behavior for the crawler.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::DirectSchemaChangePolicy?

        def initialize(
          @inputs : Array(String),
          @name : String,
          @path : String,
          @auto_data_quality : Types::AutoDataQuality? = nil,
          @compression : String? = nil,
          @number_target_partitions : String? = nil,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::DirectSchemaChangePolicy? = nil
        )
        end
      end

      # Specifies a target that writes to a Hudi data source in the Glue Data Catalog.

      struct S3HudiCatalogTarget
        include JSON::Serializable

        # Specifies additional connection options for the connector.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)

        # The name of the database to write to.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table in the database to write to.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies whether to automatically enable data quality evaluation for the S3 Hudi catalog target.
        # When set to true , data quality checks are performed automatically during the write operation.

        @[JSON::Field(key: "AutoDataQuality")]
        getter auto_data_quality : Types::AutoDataQuality?

        # Specifies the data schema for the S3 Hudi catalog target.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # Specifies native partitioning using a sequence of keys.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # A policy that specifies update behavior for the crawler.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::CatalogSchemaChangePolicy?

        def initialize(
          @additional_options : Hash(String, String),
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String,
          @auto_data_quality : Types::AutoDataQuality? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::CatalogSchemaChangePolicy? = nil
        )
        end
      end

      # Specifies a target that writes to a Hudi data source in Amazon S3.

      struct S3HudiDirectTarget
        include JSON::Serializable

        # Specifies additional connection options for the connector.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)

        # Specifies how the data is compressed. This is generally not necessary if the data has a standard
        # file extension. Possible values are "gzip" and "bzip" ).

        @[JSON::Field(key: "Compression")]
        getter compression : String

        # Specifies the data output format for the target.

        @[JSON::Field(key: "Format")]
        getter format : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The Amazon S3 path of your Hudi data source to write to.

        @[JSON::Field(key: "Path")]
        getter path : String

        # Specifies whether to automatically enable data quality evaluation for the S3 Hudi direct target.
        # When set to true , data quality checks are performed automatically during the write operation.

        @[JSON::Field(key: "AutoDataQuality")]
        getter auto_data_quality : Types::AutoDataQuality?

        # Specifies the number of target partitions for distributing Hudi dataset files across Amazon S3.

        @[JSON::Field(key: "NumberTargetPartitions")]
        getter number_target_partitions : String?

        # Specifies native partitioning using a sequence of keys.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # A policy that specifies update behavior for the crawler.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::DirectSchemaChangePolicy?

        def initialize(
          @additional_options : Hash(String, String),
          @compression : String,
          @format : String,
          @inputs : Array(String),
          @name : String,
          @path : String,
          @auto_data_quality : Types::AutoDataQuality? = nil,
          @number_target_partitions : String? = nil,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::DirectSchemaChangePolicy? = nil
        )
        end
      end

      # Specifies a Hudi data source stored in Amazon S3.

      struct S3HudiSource
        include JSON::Serializable

        # The name of the Hudi source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A list of the Amazon S3 paths to read from.

        @[JSON::Field(key: "Paths")]
        getter paths : Array(String)

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalHudiOptions")]
        getter additional_hudi_options : Hash(String, String)?

        # Specifies additional options for the connector.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Types::S3DirectSourceAdditionalOptions?

        # Specifies the data schema for the Hudi source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @name : String,
          @paths : Array(String),
          @additional_hudi_options : Hash(String, String)? = nil,
          @additional_options : Types::S3DirectSourceAdditionalOptions? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies a HyperDirect data target that writes to Amazon S3.

      struct S3HyperDirectTarget
        include JSON::Serializable

        # Specifies the input source for the HyperDirect target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The unique identifier for the HyperDirect target node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The S3 location where the output data will be written.

        @[JSON::Field(key: "Path")]
        getter path : String

        # Specifies whether to automatically enable data quality evaluation for the S3 Hyper direct target.
        # When set to true , data quality checks are performed automatically during the write operation.

        @[JSON::Field(key: "AutoDataQuality")]
        getter auto_data_quality : Types::AutoDataQuality?

        # The compression type to apply to the output data.

        @[JSON::Field(key: "Compression")]
        getter compression : String?

        # Specifies the data output format for the HyperDirect target.

        @[JSON::Field(key: "Format")]
        getter format : String?

        # Specifies the data schema for the S3 Hyper direct target.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # Defines the partitioning strategy for the output data.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # Defines how schema changes are handled during write operations.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::DirectSchemaChangePolicy?

        def initialize(
          @inputs : Array(String),
          @name : String,
          @path : String,
          @auto_data_quality : Types::AutoDataQuality? = nil,
          @compression : String? = nil,
          @format : String? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::DirectSchemaChangePolicy? = nil
        )
        end
      end

      # Specifies an Apache Iceberg catalog target that writes data to Amazon S3 and registers the table in
      # the Glue Data Catalog.

      struct S3IcebergCatalogTarget
        include JSON::Serializable

        # The name of the database to write to.

        @[JSON::Field(key: "Database")]
        getter database : String

        # The input connection for the Iceberg catalog target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the Iceberg catalog target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The name of the table to write to in the catalog.

        @[JSON::Field(key: "Table")]
        getter table : String

        # Specifies additional connection options for the Iceberg catalog target.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?

        # Specifies whether to automatically enable data quality evaluation for the S3 Iceberg catalog target.
        # When set to true , data quality checks are performed automatically during the write operation.

        @[JSON::Field(key: "AutoDataQuality")]
        getter auto_data_quality : Types::AutoDataQuality?

        # A list of partition keys for the Iceberg table.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # The policy for handling schema changes in the catalog target.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::CatalogSchemaChangePolicy?

        def initialize(
          @database : String,
          @inputs : Array(String),
          @name : String,
          @table : String,
          @additional_options : Hash(String, String)? = nil,
          @auto_data_quality : Types::AutoDataQuality? = nil,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::CatalogSchemaChangePolicy? = nil
        )
        end
      end

      # Specifies a target that writes to an Iceberg data source in Amazon S3.

      struct S3IcebergDirectTarget
        include JSON::Serializable

        # Specifies the compression codec used for Iceberg table files in S3.

        @[JSON::Field(key: "Compression")]
        getter compression : String

        # Specifies the file format used for storing Iceberg table data (e.g., Parquet, ORC).

        @[JSON::Field(key: "Format")]
        getter format : String

        # Defines the single input source that provides data to this Iceberg target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # Specifies the unique identifier for the Iceberg target node in your data pipeline.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Defines the S3 location where the Iceberg table data will be stored.

        @[JSON::Field(key: "Path")]
        getter path : String

        # Provides additional configuration options for customizing the Iceberg table behavior.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?


        @[JSON::Field(key: "AutoDataQuality")]
        getter auto_data_quality : Types::AutoDataQuality?

        # Sets the number of target partitions for distributing Iceberg table files across S3.

        @[JSON::Field(key: "NumberTargetPartitions")]
        getter number_target_partitions : String?

        # Specifies the data schema for the S3 Iceberg direct target.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # Specifies the columns used to partition the Iceberg table data in S3.

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Array(String))?

        # Defines how schema changes are handled when writing data to the Iceberg table.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::DirectSchemaChangePolicy?

        def initialize(
          @compression : String,
          @format : String,
          @inputs : Array(String),
          @name : String,
          @path : String,
          @additional_options : Hash(String, String)? = nil,
          @auto_data_quality : Types::AutoDataQuality? = nil,
          @number_target_partitions : String? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @partition_keys : Array(Array(String))? = nil,
          @schema_change_policy : Types::DirectSchemaChangePolicy? = nil
        )
        end
      end

      # Specifies a JSON data store stored in Amazon S3.

      struct S3JsonSource
        include JSON::Serializable

        # The name of the data store.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A list of the Amazon S3 paths to read from.

        @[JSON::Field(key: "Paths")]
        getter paths : Array(String)

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Types::S3DirectSourceAdditionalOptions?

        # Specifies how the data is compressed. This is generally not necessary if the data has a standard
        # file extension. Possible values are "gzip" and "bzip" ).

        @[JSON::Field(key: "CompressionType")]
        getter compression_type : String?

        # A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]"
        # excludes all PDF files.

        @[JSON::Field(key: "Exclusions")]
        getter exclusions : Array(String)?

        # Grouping files is turned on by default when the input contains more than 50,000 files. To turn on
        # grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when
        # there are more than 50,000 files, set this parameter to "none" .

        @[JSON::Field(key: "GroupFiles")]
        getter group_files : String?

        # The target group size in bytes. The default is computed based on the input data size and the size of
        # your cluster. When there are fewer than 50,000 input files, "groupFiles" must be set to
        # "inPartition" for this to take effect.

        @[JSON::Field(key: "GroupSize")]
        getter group_size : String?

        # A JsonPath string defining the JSON data.

        @[JSON::Field(key: "JsonPath")]
        getter json_path : String?

        # This option controls the duration in milliseconds after which the s3 listing is likely to be
        # consistent. Files with modification timestamps falling within the last maxBand milliseconds are
        # tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users
        # don't need to set this option. The default is 900000 milliseconds, or 15 minutes.

        @[JSON::Field(key: "MaxBand")]
        getter max_band : Int32?

        # This option specifies the maximum number of files to save from the last maxBand seconds. If this
        # number is exceeded, extra files are skipped and only processed in the next job run.

        @[JSON::Field(key: "MaxFilesInBand")]
        getter max_files_in_band : Int32?

        # A Boolean value that specifies whether a single record can span multiple lines. This can occur when
        # a field contains a quoted new-line character. You must set this option to True if any record spans
        # multiple lines. The default value is False , which allows for more aggressive file-splitting during
        # parsing.

        @[JSON::Field(key: "Multiline")]
        getter multiline : Bool?

        # Specifies the data schema for the S3 JSON source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # If set to true, recursively reads files in all subdirectories under the specified paths.

        @[JSON::Field(key: "Recurse")]
        getter recurse : Bool?

        def initialize(
          @name : String,
          @paths : Array(String),
          @additional_options : Types::S3DirectSourceAdditionalOptions? = nil,
          @compression_type : String? = nil,
          @exclusions : Array(String)? = nil,
          @group_files : String? = nil,
          @group_size : String? = nil,
          @json_path : String? = nil,
          @max_band : Int32? = nil,
          @max_files_in_band : Int32? = nil,
          @multiline : Bool? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @recurse : Bool? = nil
        )
        end
      end

      # Specifies an Apache Parquet data store stored in Amazon S3.

      struct S3ParquetSource
        include JSON::Serializable

        # The name of the data store.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A list of the Amazon S3 paths to read from.

        @[JSON::Field(key: "Paths")]
        getter paths : Array(String)

        # Specifies additional connection options.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Types::S3DirectSourceAdditionalOptions?

        # Specifies how the data is compressed. This is generally not necessary if the data has a standard
        # file extension. Possible values are "gzip" and "bzip" ).

        @[JSON::Field(key: "CompressionType")]
        getter compression_type : String?

        # A string containing a JSON list of Unix-style glob patterns to exclude. For example, "[\"**.pdf\"]"
        # excludes all PDF files.

        @[JSON::Field(key: "Exclusions")]
        getter exclusions : Array(String)?

        # Grouping files is turned on by default when the input contains more than 50,000 files. To turn on
        # grouping with fewer than 50,000 files, set this parameter to "inPartition". To disable grouping when
        # there are more than 50,000 files, set this parameter to "none" .

        @[JSON::Field(key: "GroupFiles")]
        getter group_files : String?

        # The target group size in bytes. The default is computed based on the input data size and the size of
        # your cluster. When there are fewer than 50,000 input files, "groupFiles" must be set to
        # "inPartition" for this to take effect.

        @[JSON::Field(key: "GroupSize")]
        getter group_size : String?

        # This option controls the duration in milliseconds after which the s3 listing is likely to be
        # consistent. Files with modification timestamps falling within the last maxBand milliseconds are
        # tracked specially when using JobBookmarks to account for Amazon S3 eventual consistency. Most users
        # don't need to set this option. The default is 900000 milliseconds, or 15 minutes.

        @[JSON::Field(key: "MaxBand")]
        getter max_band : Int32?

        # This option specifies the maximum number of files to save from the last maxBand seconds. If this
        # number is exceeded, extra files are skipped and only processed in the next job run.

        @[JSON::Field(key: "MaxFilesInBand")]
        getter max_files_in_band : Int32?

        # Specifies the data schema for the S3 Parquet source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        # If set to true, recursively reads files in all subdirectories under the specified paths.

        @[JSON::Field(key: "Recurse")]
        getter recurse : Bool?

        def initialize(
          @name : String,
          @paths : Array(String),
          @additional_options : Types::S3DirectSourceAdditionalOptions? = nil,
          @compression_type : String? = nil,
          @exclusions : Array(String)? = nil,
          @group_files : String? = nil,
          @group_size : String? = nil,
          @max_band : Int32? = nil,
          @max_files_in_band : Int32? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil,
          @recurse : Bool? = nil
        )
        end
      end

      # Specifies additional connection options for the Amazon S3 data store.

      struct S3SourceAdditionalOptions
        include JSON::Serializable

        # Sets the upper limit for the target number of files that will be processed.

        @[JSON::Field(key: "BoundedFiles")]
        getter bounded_files : Int64?

        # Sets the upper limit for the target size of the dataset in bytes that will be processed.

        @[JSON::Field(key: "BoundedSize")]
        getter bounded_size : Int64?

        def initialize(
          @bounded_files : Int64? = nil,
          @bounded_size : Int64? = nil
        )
        end
      end

      # Specifies a data store in Amazon Simple Storage Service (Amazon S3).

      struct S3Target
        include JSON::Serializable

        # The name of a connection which allows a job or crawler to access data in Amazon S3 within an Amazon
        # Virtual Private Cloud environment (Amazon VPC).

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # A valid Amazon dead-letter SQS ARN. For example, arn:aws:sqs:region:account:deadLetterQueue .

        @[JSON::Field(key: "DlqEventQueueArn")]
        getter dlq_event_queue_arn : String?

        # A valid Amazon SQS ARN. For example, arn:aws:sqs:region:account:sqs .

        @[JSON::Field(key: "EventQueueArn")]
        getter event_queue_arn : String?

        # A list of glob patterns used to exclude from the crawl. For more information, see Catalog Tables
        # with a Crawler .

        @[JSON::Field(key: "Exclusions")]
        getter exclusions : Array(String)?

        # The path to the Amazon S3 target.

        @[JSON::Field(key: "Path")]
        getter path : String?

        # Sets the number of files in each leaf folder to be crawled when crawling sample files in a dataset.
        # If not set, all the files are crawled. A valid value is an integer between 1 and 249.

        @[JSON::Field(key: "SampleSize")]
        getter sample_size : Int32?

        def initialize(
          @connection_name : String? = nil,
          @dlq_event_queue_arn : String? = nil,
          @event_queue_arn : String? = nil,
          @exclusions : Array(String)? = nil,
          @path : String? = nil,
          @sample_size : Int32? = nil
        )
        end
      end

      # A scheduling object using a cron statement to schedule an event.

      struct Schedule
        include JSON::Serializable

        # A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers . For
        # example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *) .

        @[JSON::Field(key: "ScheduleExpression")]
        getter schedule_expression : String?

        # The state of the schedule.

        @[JSON::Field(key: "State")]
        getter state : String?

        def initialize(
          @schedule_expression : String? = nil,
          @state : String? = nil
        )
        end
      end

      # The specified scheduler is not running.

      struct SchedulerNotRunningException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The specified scheduler is already running.

      struct SchedulerRunningException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # The specified scheduler is transitioning.

      struct SchedulerTransitioningException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # A policy that specifies update and deletion behaviors for the crawler.

      struct SchemaChangePolicy
        include JSON::Serializable

        # The deletion behavior when the crawler finds a deleted object.

        @[JSON::Field(key: "DeleteBehavior")]
        getter delete_behavior : String?

        # The update behavior when the crawler finds a changed schema.

        @[JSON::Field(key: "UpdateBehavior")]
        getter update_behavior : String?

        def initialize(
          @delete_behavior : String? = nil,
          @update_behavior : String? = nil
        )
        end
      end

      # A key-value pair representing a column and data type that this transform can run against. The Schema
      # parameter of the MLTransform may contain up to 100 of these structures.

      struct SchemaColumn
        include JSON::Serializable

        # The type of data in the column.

        @[JSON::Field(key: "DataType")]
        getter data_type : String?

        # The name of the column.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @data_type : String? = nil,
          @name : String? = nil
        )
        end
      end

      # The unique ID of the schema in the Glue schema registry.

      struct SchemaId
        include JSON::Serializable

        # The name of the schema registry that contains the schema.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has to be provided.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The name of the schema. One of SchemaArn or SchemaName has to be provided.

        @[JSON::Field(key: "SchemaName")]
        getter schema_name : String?

        def initialize(
          @registry_name : String? = nil,
          @schema_arn : String? = nil,
          @schema_name : String? = nil
        )
        end
      end

      # An object that contains minimal details for a schema.

      struct SchemaListItem
        include JSON::Serializable

        # The date and time that a schema was created.

        @[JSON::Field(key: "CreatedTime")]
        getter created_time : String?

        # A description for the schema.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # the name of the registry where the schema resides.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The Amazon Resource Name (ARN) for the schema.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The name of the schema.

        @[JSON::Field(key: "SchemaName")]
        getter schema_name : String?

        # The status of the schema.

        @[JSON::Field(key: "SchemaStatus")]
        getter schema_status : String?

        # The date and time that a schema was updated.

        @[JSON::Field(key: "UpdatedTime")]
        getter updated_time : String?

        def initialize(
          @created_time : String? = nil,
          @description : String? = nil,
          @registry_name : String? = nil,
          @schema_arn : String? = nil,
          @schema_name : String? = nil,
          @schema_status : String? = nil,
          @updated_time : String? = nil
        )
        end
      end

      # An object that references a schema stored in the Glue Schema Registry.

      struct SchemaReference
        include JSON::Serializable

        # A structure that contains schema identity fields. Either this or the SchemaVersionId has to be
        # provided.

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId?

        # The unique ID assigned to a version of the schema. Either this or the SchemaId has to be provided.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The version number of the schema.

        @[JSON::Field(key: "SchemaVersionNumber")]
        getter schema_version_number : Int64?

        def initialize(
          @schema_id : Types::SchemaId? = nil,
          @schema_version_id : String? = nil,
          @schema_version_number : Int64? = nil
        )
        end
      end

      # An object that contains the error details for an operation on a schema version.

      struct SchemaVersionErrorItem
        include JSON::Serializable

        # The details of the error for the schema version.

        @[JSON::Field(key: "ErrorDetails")]
        getter error_details : Types::ErrorDetails?

        # The version number of the schema.

        @[JSON::Field(key: "VersionNumber")]
        getter version_number : Int64?

        def initialize(
          @error_details : Types::ErrorDetails? = nil,
          @version_number : Int64? = nil
        )
        end
      end

      # An object containing the details about a schema version.

      struct SchemaVersionListItem
        include JSON::Serializable

        # The date and time the schema version was created.

        @[JSON::Field(key: "CreatedTime")]
        getter created_time : String?

        # The Amazon Resource Name (ARN) of the schema.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The unique identifier of the schema version.

        @[JSON::Field(key: "SchemaVersionId")]
        getter schema_version_id : String?

        # The status of the schema version.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The version number of the schema.

        @[JSON::Field(key: "VersionNumber")]
        getter version_number : Int64?

        def initialize(
          @created_time : String? = nil,
          @schema_arn : String? = nil,
          @schema_version_id : String? = nil,
          @status : String? = nil,
          @version_number : Int64? = nil
        )
        end
      end

      # A structure containing the schema version information.

      struct SchemaVersionNumber
        include JSON::Serializable

        # The latest version available for the schema.

        @[JSON::Field(key: "LatestVersion")]
        getter latest_version : Bool?

        # The version number of the schema.

        @[JSON::Field(key: "VersionNumber")]
        getter version_number : Int64?

        def initialize(
          @latest_version : Bool? = nil,
          @version_number : Int64? = nil
        )
        end
      end


      struct SearchTablesRequest
        include JSON::Serializable

        # A unique identifier, consisting of account_id .

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # A list of key-value pairs, and a comparator used to filter the search results. Returns all entities
        # matching the predicate. The Comparator member of the PropertyPredicate struct is used only for time
        # fields, and can be omitted for other field types. Also, when comparing string values, such as when
        # Key=Name , a fuzzy match algorithm is used. The Key field (for example, the value of the Name field)
        # is split on certain punctuation characters, for example, -, :, #, etc. into tokens. Then each token
        # is exact-match compared with the Value member of PropertyPredicate . For example, if Key=Name and
        # Value=link , tables named customer-link and xx-link-yy are returned, but xxlinkyy is not returned.

        @[JSON::Field(key: "Filters")]
        getter filters : Array(Types::PropertyPredicate)?

        # Specifies whether to include status details related to a request to create or update an Glue Data
        # Catalog view.

        @[JSON::Field(key: "IncludeStatusDetails")]
        getter include_status_details : Bool?

        # The maximum number of tables to return in a single response.

        @[JSON::Field(key: "MaxResults")]
        getter max_results : Int32?

        # A continuation token, included if this is a continuation call.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # Allows you to specify that you want to search the tables shared with your account. The allowable
        # values are FOREIGN or ALL . If set to FOREIGN , will search the tables shared with your account. If
        # set to ALL , will search the tables shared with your account, as well as the tables in yor local
        # account.

        @[JSON::Field(key: "ResourceShareType")]
        getter resource_share_type : String?

        # A string used for a text search. Specifying a value in quotes filters based on an exact match to the
        # value.

        @[JSON::Field(key: "SearchText")]
        getter search_text : String?

        # A list of criteria for sorting the results by a field name, in an ascending or descending order.

        @[JSON::Field(key: "SortCriteria")]
        getter sort_criteria : Array(Types::SortCriterion)?

        def initialize(
          @catalog_id : String? = nil,
          @filters : Array(Types::PropertyPredicate)? = nil,
          @include_status_details : Bool? = nil,
          @max_results : Int32? = nil,
          @next_token : String? = nil,
          @resource_share_type : String? = nil,
          @search_text : String? = nil,
          @sort_criteria : Array(Types::SortCriterion)? = nil
        )
        end
      end


      struct SearchTablesResponse
        include JSON::Serializable

        # A continuation token, present if the current list segment is not the last.

        @[JSON::Field(key: "NextToken")]
        getter next_token : String?

        # A list of the requested Table objects. The SearchTables response returns only the tables that you
        # have access to.

        @[JSON::Field(key: "TableList")]
        getter table_list : Array(Types::Table)?

        def initialize(
          @next_token : String? = nil,
          @table_list : Array(Types::Table)? = nil
        )
        end
      end

      # Specifies a security configuration.

      struct SecurityConfiguration
        include JSON::Serializable

        # The time at which this security configuration was created.

        @[JSON::Field(key: "CreatedTimeStamp", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_time_stamp : Time?

        # The encryption configuration associated with this security configuration.

        @[JSON::Field(key: "EncryptionConfiguration")]
        getter encryption_configuration : Types::EncryptionConfiguration?

        # The name of the security configuration.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @created_time_stamp : Time? = nil,
          @encryption_configuration : Types::EncryptionConfiguration? = nil,
          @name : String? = nil
        )
        end
      end

      # Defines a non-overlapping region of a table's partitions, allowing multiple requests to be run in
      # parallel.

      struct Segment
        include JSON::Serializable

        # The zero-based index number of the segment. For example, if the total number of segments is 4,
        # SegmentNumber values range from 0 through 3.

        @[JSON::Field(key: "SegmentNumber")]
        getter segment_number : Int32

        # The total number of segments.

        @[JSON::Field(key: "TotalSegments")]
        getter total_segments : Int32

        def initialize(
          @segment_number : Int32,
          @total_segments : Int32
        )
        end
      end

      # Specifies a transform that chooses the data property keys that you want to keep.

      struct SelectFields
        include JSON::Serializable

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A JSON path to a variable in the data structure.

        @[JSON::Field(key: "Paths")]
        getter paths : Array(Array(String))

        def initialize(
          @inputs : Array(String),
          @name : String,
          @paths : Array(Array(String))
        )
        end
      end

      # Specifies a transform that chooses one DynamicFrame from a collection of DynamicFrames . The output
      # is the selected DynamicFrame

      struct SelectFromCollection
        include JSON::Serializable

        # The index for the DynamicFrame to be selected.

        @[JSON::Field(key: "Index")]
        getter index : Int32

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @index : Int32,
          @inputs : Array(String),
          @name : String
        )
        end
      end

      # Information about a serialization/deserialization program (SerDe) that serves as an extractor and
      # loader.

      struct SerDeInfo
        include JSON::Serializable

        # Name of the SerDe.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # These key-value pairs define initialization parameters for the SerDe.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # Usually the class that implements the SerDe. An example is
        # org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe .

        @[JSON::Field(key: "SerializationLibrary")]
        getter serialization_library : String?

        def initialize(
          @name : String? = nil,
          @parameters : Hash(String, String)? = nil,
          @serialization_library : String? = nil
        )
        end
      end

      # The period in which a remote Spark runtime environment is running.

      struct Session
        include JSON::Serializable

        # The command object.See SessionCommand.

        @[JSON::Field(key: "Command")]
        getter command : Types::SessionCommand?

        # The date and time that this session is completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # The number of connections used for the session.

        @[JSON::Field(key: "Connections")]
        getter connections : Types::ConnectionsList?

        # The time and date when the session was created.

        @[JSON::Field(key: "CreatedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_on : Time?

        # The DPUs consumed by the session (formula: ExecutionTime * MaxCapacity).

        @[JSON::Field(key: "DPUSeconds")]
        getter dpu_seconds : Float64?

        # A map array of key-value pairs. Max is 75 pairs.

        @[JSON::Field(key: "DefaultArguments")]
        getter default_arguments : Hash(String, String)?

        # The description of the session.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The error message displayed during the session.

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # The total time the session ran for.

        @[JSON::Field(key: "ExecutionTime")]
        getter execution_time : Float64?

        # The Glue version determines the versions of Apache Spark and Python that Glue supports. The
        # GlueVersion must be greater than 2.0.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # The ID of the session.

        @[JSON::Field(key: "Id")]
        getter id : String?

        # The number of minutes when idle before the session times out.

        @[JSON::Field(key: "IdleTimeout")]
        getter idle_timeout : Int32?

        # The number of Glue data processing units (DPUs) that can be allocated when the job runs. A DPU is a
        # relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB memory.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # The number of workers of a defined WorkerType to use for the session.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The name of an Glue usage profile associated with the session.

        @[JSON::Field(key: "ProfileName")]
        getter profile_name : String?

        # The code execution progress of the session.

        @[JSON::Field(key: "Progress")]
        getter progress : Float64?

        # The name or Amazon Resource Name (ARN) of the IAM role associated with the Session.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # The name of the SecurityConfiguration structure to be used with the session.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The session status.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The type of predefined worker that is allocated when a session runs. Accepts a value of G.1X , G.2X
        # , G.4X , or G.8X for Spark sessions. Accepts the value Z.2X for Ray sessions.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @command : Types::SessionCommand? = nil,
          @completed_on : Time? = nil,
          @connections : Types::ConnectionsList? = nil,
          @created_on : Time? = nil,
          @dpu_seconds : Float64? = nil,
          @default_arguments : Hash(String, String)? = nil,
          @description : String? = nil,
          @error_message : String? = nil,
          @execution_time : Float64? = nil,
          @glue_version : String? = nil,
          @id : String? = nil,
          @idle_timeout : Int32? = nil,
          @max_capacity : Float64? = nil,
          @number_of_workers : Int32? = nil,
          @profile_name : String? = nil,
          @progress : Float64? = nil,
          @role : String? = nil,
          @security_configuration : String? = nil,
          @status : String? = nil,
          @worker_type : String? = nil
        )
        end
      end

      # The SessionCommand that runs the job.

      struct SessionCommand
        include JSON::Serializable

        # Specifies the name of the SessionCommand. Can be 'glueetl' or 'gluestreaming'.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # Specifies the Python version. The Python version indicates the version supported for jobs of type
        # Spark.

        @[JSON::Field(key: "PythonVersion")]
        getter python_version : String?

        def initialize(
          @name : String? = nil,
          @python_version : String? = nil
        )
        end
      end

      # Specifies skewed values in a table. Skewed values are those that occur with very high frequency.

      struct SkewedInfo
        include JSON::Serializable

        # A list of names of columns that contain skewed values.

        @[JSON::Field(key: "SkewedColumnNames")]
        getter skewed_column_names : Array(String)?

        # A mapping of skewed values to the columns that contain them.

        @[JSON::Field(key: "SkewedColumnValueLocationMaps")]
        getter skewed_column_value_location_maps : Hash(String, String)?

        # A list of values that appear so frequently as to be considered skewed.

        @[JSON::Field(key: "SkewedColumnValues")]
        getter skewed_column_values : Array(String)?

        def initialize(
          @skewed_column_names : Array(String)? = nil,
          @skewed_column_value_location_maps : Hash(String, String)? = nil,
          @skewed_column_values : Array(String)? = nil
        )
        end
      end

      # Specifies configuration for Snowflake nodes in Glue Studio.

      struct SnowflakeNodeData
        include JSON::Serializable

        # Specifies what action to take when writing to a table with preexisting data. Valid values: append ,
        # merge , truncate , drop .

        @[JSON::Field(key: "Action")]
        getter action : String?

        # Specifies additional options passed to the Snowflake connector. If options are specified elsewhere
        # in this node, this will take precedence.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?

        # Specifies whether automatic query pushdown is enabled. If pushdown is enabled, then when a query is
        # run on Spark, if part of the query can be "pushed down" to the Snowflake server, it is pushed down.
        # This improves performance of some queries.

        @[JSON::Field(key: "AutoPushdown")]
        getter auto_pushdown : Bool?

        # Specifies a Glue Data Catalog Connection to a Snowflake endpoint.

        @[JSON::Field(key: "Connection")]
        getter connection : Types::Option?

        # Specifies a Snowflake database for your node to use.

        @[JSON::Field(key: "Database")]
        getter database : String?

        # Not currently used.

        @[JSON::Field(key: "IamRole")]
        getter iam_role : Types::Option?

        # Specifies a merge action. Valid values: simple , custom . If simple, merge behavior is defined by
        # MergeWhenMatched and MergeWhenNotMatched . If custom, defined by MergeClause .

        @[JSON::Field(key: "MergeAction")]
        getter merge_action : String?

        # A SQL statement that specifies a custom merge behavior.

        @[JSON::Field(key: "MergeClause")]
        getter merge_clause : String?

        # Specifies how to resolve records that match preexisting data when merging. Valid values: update ,
        # delete .

        @[JSON::Field(key: "MergeWhenMatched")]
        getter merge_when_matched : String?

        # Specifies how to process records that do not match preexisting data when merging. Valid values:
        # insert , none .

        @[JSON::Field(key: "MergeWhenNotMatched")]
        getter merge_when_not_matched : String?

        # A SQL string run after the Snowflake connector performs its standard actions.

        @[JSON::Field(key: "PostAction")]
        getter post_action : String?

        # A SQL string run before the Snowflake connector performs its standard actions.

        @[JSON::Field(key: "PreAction")]
        getter pre_action : String?

        # A SQL string used to retrieve data with the query sourcetype.

        @[JSON::Field(key: "SampleQuery")]
        getter sample_query : String?

        # Specifies a Snowflake database schema for your node to use.

        @[JSON::Field(key: "Schema")]
        getter schema : String?

        # Specifies the columns combined to identify a record when detecting matches for merges and upserts. A
        # list of structures with value , label and description keys. Each structure describes a column.

        @[JSON::Field(key: "SelectedColumns")]
        getter selected_columns : Array(Types::Option)?

        # Specifies how retrieved data is specified. Valid values: "table" , "query" .

        @[JSON::Field(key: "SourceType")]
        getter source_type : String?

        # The name of a staging table used when performing merge or upsert append actions. Data is written to
        # this table, then moved to table by a generated postaction.

        @[JSON::Field(key: "StagingTable")]
        getter staging_table : String?

        # Specifies a Snowflake table for your node to use.

        @[JSON::Field(key: "Table")]
        getter table : String?

        # Manually defines the target schema for the node. A list of structures with value , label and
        # description keys. Each structure defines a column.

        @[JSON::Field(key: "TableSchema")]
        getter table_schema : Array(Types::Option)?

        # Not currently used.

        @[JSON::Field(key: "TempDir")]
        getter temp_dir : String?

        # Used when Action is append . Specifies the resolution behavior when a row already exists. If true,
        # preexisting rows will be updated. If false, those rows will be inserted.

        @[JSON::Field(key: "Upsert")]
        getter upsert : Bool?

        def initialize(
          @action : String? = nil,
          @additional_options : Hash(String, String)? = nil,
          @auto_pushdown : Bool? = nil,
          @connection : Types::Option? = nil,
          @database : String? = nil,
          @iam_role : Types::Option? = nil,
          @merge_action : String? = nil,
          @merge_clause : String? = nil,
          @merge_when_matched : String? = nil,
          @merge_when_not_matched : String? = nil,
          @post_action : String? = nil,
          @pre_action : String? = nil,
          @sample_query : String? = nil,
          @schema : String? = nil,
          @selected_columns : Array(Types::Option)? = nil,
          @source_type : String? = nil,
          @staging_table : String? = nil,
          @table : String? = nil,
          @table_schema : Array(Types::Option)? = nil,
          @temp_dir : String? = nil,
          @upsert : Bool? = nil
        )
        end
      end

      # Specifies a Snowflake data source.

      struct SnowflakeSource
        include JSON::Serializable

        # Configuration for the Snowflake data source.

        @[JSON::Field(key: "Data")]
        getter data : Types::SnowflakeNodeData

        # The name of the Snowflake data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Specifies user-defined schemas for your output data.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @data : Types::SnowflakeNodeData,
          @name : String,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies a Snowflake target.

      struct SnowflakeTarget
        include JSON::Serializable

        # Specifies the data of the Snowflake target node.

        @[JSON::Field(key: "Data")]
        getter data : Types::SnowflakeNodeData

        # The name of the Snowflake target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)?

        def initialize(
          @data : Types::SnowflakeNodeData,
          @name : String,
          @inputs : Array(String)? = nil
        )
        end
      end

      # Specifies a field to sort by and a sort order.

      struct SortCriterion
        include JSON::Serializable

        # The name of the field on which to sort.

        @[JSON::Field(key: "FieldName")]
        getter field_name : String?

        # An ascending or descending sort.

        @[JSON::Field(key: "Sort")]
        getter sort : String?

        def initialize(
          @field_name : String? = nil,
          @sort : String? = nil
        )
        end
      end

      # The details for a source control configuration for a job, allowing synchronization of job artifacts
      # to or from a remote repository.

      struct SourceControlDetails
        include JSON::Serializable

        # The type of authentication, which can be an authentication token stored in Amazon Web Services
        # Secrets Manager, or a personal access token.

        @[JSON::Field(key: "AuthStrategy")]
        getter auth_strategy : String?

        # The value of an authorization token.

        @[JSON::Field(key: "AuthToken")]
        getter auth_token : String?

        # An optional branch in the remote repository.

        @[JSON::Field(key: "Branch")]
        getter branch : String?

        # An optional folder in the remote repository.

        @[JSON::Field(key: "Folder")]
        getter folder : String?

        # The last commit ID for a commit in the remote repository.

        @[JSON::Field(key: "LastCommitId")]
        getter last_commit_id : String?

        # The owner of the remote repository that contains the job artifacts.

        @[JSON::Field(key: "Owner")]
        getter owner : String?

        # The provider for the remote repository.

        @[JSON::Field(key: "Provider")]
        getter provider : String?

        # The name of the remote repository that contains the job artifacts.

        @[JSON::Field(key: "Repository")]
        getter repository : String?

        def initialize(
          @auth_strategy : String? = nil,
          @auth_token : String? = nil,
          @branch : String? = nil,
          @folder : String? = nil,
          @last_commit_id : String? = nil,
          @owner : String? = nil,
          @provider : String? = nil,
          @repository : String? = nil
        )
        end
      end

      # The resource properties associated with the integration source.

      struct SourceProcessingProperties
        include JSON::Serializable

        # The IAM role to access the Glue connection.

        @[JSON::Field(key: "RoleArn")]
        getter role_arn : String?

        def initialize(
          @role_arn : String? = nil
        )
        end
      end

      # Properties used by the source leg to process data from the source.

      struct SourceTableConfig
        include JSON::Serializable

        # A list of fields used for column-level filtering. Currently unsupported.

        @[JSON::Field(key: "Fields")]
        getter fields : Array(String)?

        # A condition clause used for row-level filtering. Currently unsupported.

        @[JSON::Field(key: "FilterPredicate")]
        getter filter_predicate : String?

        # Provide the primary key set for this table. Currently supported specifically for SAP EntityOf
        # entities upon request. Contact Amazon Web Services Support to make this feature available.

        @[JSON::Field(key: "PrimaryKey")]
        getter primary_key : Array(String)?

        # Incremental pull timestamp-based field. Currently unsupported.

        @[JSON::Field(key: "RecordUpdateField")]
        getter record_update_field : String?

        def initialize(
          @fields : Array(String)? = nil,
          @filter_predicate : String? = nil,
          @primary_key : Array(String)? = nil,
          @record_update_field : String? = nil
        )
        end
      end

      # Specifies a connector to an Apache Spark data source.

      struct SparkConnectorSource
        include JSON::Serializable

        # The name of the connection that is associated with the connector.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String

        # The type of connection, such as marketplace.spark or custom.spark, designating a connection to an
        # Apache Spark data store.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        # The name of a connector that assists with accessing the data store in Glue Studio.

        @[JSON::Field(key: "ConnectorName")]
        getter connector_name : String

        # The name of the data source.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Additional connection options for the connector.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?

        # Specifies data schema for the custom spark source.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @connection_name : String,
          @connection_type : String,
          @connector_name : String,
          @name : String,
          @additional_options : Hash(String, String)? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies a target that uses an Apache Spark connector.

      struct SparkConnectorTarget
        include JSON::Serializable

        # The name of a connection for an Apache Spark connector.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String

        # The type of connection, such as marketplace.spark or custom.spark, designating a connection to an
        # Apache Spark data store.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        # The name of an Apache Spark connector.

        @[JSON::Field(key: "ConnectorName")]
        getter connector_name : String

        # The nodes that are inputs to the data target.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the data target.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Additional connection options for the connector.

        @[JSON::Field(key: "AdditionalOptions")]
        getter additional_options : Hash(String, String)?

        # Specifies the data schema for the custom spark target.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @connection_name : String,
          @connection_type : String,
          @connector_name : String,
          @inputs : Array(String),
          @name : String,
          @additional_options : Hash(String, String)? = nil,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies a transform where you enter a SQL query using Spark SQL syntax to transform the data. The
      # output is a single DynamicFrame .

      struct SparkSQL
        include JSON::Serializable

        # The data inputs identified by their node names. You can associate a table name with each input node
        # to use in the SQL query. The name you choose must meet the Spark SQL naming restrictions.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A list of aliases. An alias allows you to specify what name to use in the SQL for a given input. For
        # example, you have a datasource named "MyDataSource". If you specify From as MyDataSource, and Alias
        # as SqlName, then in your SQL you can do: select * from SqlName and that gets data from MyDataSource.

        @[JSON::Field(key: "SqlAliases")]
        getter sql_aliases : Array(Types::SqlAlias)

        # A SQL query that must use Spark SQL syntax and return a single data set.

        @[JSON::Field(key: "SqlQuery")]
        getter sql_query : String

        # Specifies the data schema for the SparkSQL transform.

        @[JSON::Field(key: "OutputSchemas")]
        getter output_schemas : Array(Types::GlueSchema)?

        def initialize(
          @inputs : Array(String),
          @name : String,
          @sql_aliases : Array(Types::SqlAlias),
          @sql_query : String,
          @output_schemas : Array(Types::GlueSchema)? = nil
        )
        end
      end

      # Specifies a transform that writes samples of the data to an Amazon S3 bucket.

      struct Spigot
        include JSON::Serializable

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A path in Amazon S3 where the transform will write a subset of records from the dataset to a JSON
        # file in an Amazon S3 bucket.

        @[JSON::Field(key: "Path")]
        getter path : String

        # The probability (a decimal value with a maximum value of 1) of picking any given record. A value of
        # 1 indicates that each row read from the dataset should be included in the sample output.

        @[JSON::Field(key: "Prob")]
        getter prob : Float64?

        # Specifies a number of records to write starting from the beginning of the dataset.

        @[JSON::Field(key: "Topk")]
        getter topk : Int32?

        def initialize(
          @inputs : Array(String),
          @name : String,
          @path : String,
          @prob : Float64? = nil,
          @topk : Int32? = nil
        )
        end
      end

      # Specifies a transform that splits data property keys into two DynamicFrames . The output is a
      # collection of DynamicFrames : one with selected data property keys, and one with the remaining data
      # property keys.

      struct SplitFields
        include JSON::Serializable

        # The data inputs identified by their node names.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A JSON path to a variable in the data structure.

        @[JSON::Field(key: "Paths")]
        getter paths : Array(Array(String))

        def initialize(
          @inputs : Array(String),
          @name : String,
          @paths : Array(Array(String))
        )
        end
      end

      # Represents a single entry in the list of values for SqlAliases .

      struct SqlAlias
        include JSON::Serializable

        # A temporary name given to a table, or a column in a table.

        @[JSON::Field(key: "Alias")]
        getter alias : String

        # A table, or a column in a table.

        @[JSON::Field(key: "From")]
        getter from : String

        def initialize(
          @alias : String,
          @from : String
        )
        end
      end


      struct StartBlueprintRunRequest
        include JSON::Serializable

        # The name of the blueprint.

        @[JSON::Field(key: "BlueprintName")]
        getter blueprint_name : String

        # Specifies the IAM role used to create the workflow.

        @[JSON::Field(key: "RoleArn")]
        getter role_arn : String

        # Specifies the parameters as a BlueprintParameters object.

        @[JSON::Field(key: "Parameters")]
        getter parameters : String?

        def initialize(
          @blueprint_name : String,
          @role_arn : String,
          @parameters : String? = nil
        )
        end
      end


      struct StartBlueprintRunResponse
        include JSON::Serializable

        # The run ID for this blueprint run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        def initialize(
          @run_id : String? = nil
        )
        end
      end


      struct StartColumnStatisticsTaskRunRequest
        include JSON::Serializable

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The IAM role that the service assumes to generate statistics.

        @[JSON::Field(key: "Role")]
        getter role : String

        # The name of the table to generate statistics.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the table reside. If none is supplied, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogID")]
        getter catalog_id : String?

        # A list of the column names to generate statistics. If none is supplied, all column names for the
        # table will be used by default.

        @[JSON::Field(key: "ColumnNameList")]
        getter column_name_list : Array(String)?

        # The percentage of rows used to generate statistics. If none is supplied, the entire table will be
        # used to generate stats.

        @[JSON::Field(key: "SampleSize")]
        getter sample_size : Float64?

        # Name of the security configuration that is used to encrypt CloudWatch logs for the column stats task
        # run.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        def initialize(
          @database_name : String,
          @role : String,
          @table_name : String,
          @catalog_id : String? = nil,
          @column_name_list : Array(String)? = nil,
          @sample_size : Float64? = nil,
          @security_configuration : String? = nil
        )
        end
      end


      struct StartColumnStatisticsTaskRunResponse
        include JSON::Serializable

        # The identifier for the column statistics task run.

        @[JSON::Field(key: "ColumnStatisticsTaskRunId")]
        getter column_statistics_task_run_id : String?

        def initialize(
          @column_statistics_task_run_id : String? = nil
        )
        end
      end


      struct StartColumnStatisticsTaskRunScheduleRequest
        include JSON::Serializable

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table for which to start a column statistic task run schedule.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        def initialize(
          @database_name : String,
          @table_name : String
        )
        end
      end


      struct StartColumnStatisticsTaskRunScheduleResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct StartCrawlerRequest
        include JSON::Serializable

        # Name of the crawler to start.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct StartCrawlerResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct StartCrawlerScheduleRequest
        include JSON::Serializable

        # Name of the crawler to schedule.

        @[JSON::Field(key: "CrawlerName")]
        getter crawler_name : String

        def initialize(
          @crawler_name : String
        )
        end
      end


      struct StartCrawlerScheduleResponse
        include JSON::Serializable

        def initialize
        end
      end

      # The request of the Data Quality rule recommendation request.

      struct StartDataQualityRuleRecommendationRunRequest
        include JSON::Serializable

        # The data source (Glue table) associated with this run.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource

        # An IAM role supplied to encrypt the results of the run.

        @[JSON::Field(key: "Role")]
        getter role : String

        # Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating
        # or starting multiple instances of the same resource.

        @[JSON::Field(key: "ClientToken")]
        getter client_token : String?

        # A name for the ruleset.

        @[JSON::Field(key: "CreatedRulesetName")]
        getter created_ruleset_name : String?

        # The name of the security configuration created with the data quality encryption option.

        @[JSON::Field(key: "DataQualitySecurityConfiguration")]
        getter data_quality_security_configuration : String?

        # The number of G.1X workers to be used in the run. The default is 5.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The timeout for a run in minutes. This is the maximum time that a run can consume resources before
        # it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        def initialize(
          @data_source : Types::DataSource,
          @role : String,
          @client_token : String? = nil,
          @created_ruleset_name : String? = nil,
          @data_quality_security_configuration : String? = nil,
          @number_of_workers : Int32? = nil,
          @timeout : Int32? = nil
        )
        end
      end


      struct StartDataQualityRuleRecommendationRunResponse
        include JSON::Serializable

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        def initialize(
          @run_id : String? = nil
        )
        end
      end


      struct StartDataQualityRulesetEvaluationRunRequest
        include JSON::Serializable

        # The data source (Glue table) associated with this run.

        @[JSON::Field(key: "DataSource")]
        getter data_source : Types::DataSource

        # An IAM role supplied to encrypt the results of the run.

        @[JSON::Field(key: "Role")]
        getter role : String

        # A list of ruleset names.

        @[JSON::Field(key: "RulesetNames")]
        getter ruleset_names : Array(String)

        # A map of reference strings to additional data sources you can specify for an evaluation run.

        @[JSON::Field(key: "AdditionalDataSources")]
        getter additional_data_sources : Hash(String, Types::DataSource)?

        # Additional run options you can specify for an evaluation run.

        @[JSON::Field(key: "AdditionalRunOptions")]
        getter additional_run_options : Types::DataQualityEvaluationRunAdditionalRunOptions?

        # Used for idempotency and is recommended to be set to a random ID (such as a UUID) to avoid creating
        # or starting multiple instances of the same resource.

        @[JSON::Field(key: "ClientToken")]
        getter client_token : String?

        # The number of G.1X workers to be used in the run. The default is 5.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The timeout for a run in minutes. This is the maximum time that a run can consume resources before
        # it is terminated and enters TIMEOUT status. The default is 2,880 minutes (48 hours).

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        def initialize(
          @data_source : Types::DataSource,
          @role : String,
          @ruleset_names : Array(String),
          @additional_data_sources : Hash(String, Types::DataSource)? = nil,
          @additional_run_options : Types::DataQualityEvaluationRunAdditionalRunOptions? = nil,
          @client_token : String? = nil,
          @number_of_workers : Int32? = nil,
          @timeout : Int32? = nil
        )
        end
      end


      struct StartDataQualityRulesetEvaluationRunResponse
        include JSON::Serializable

        # The unique run identifier associated with this run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        def initialize(
          @run_id : String? = nil
        )
        end
      end


      struct StartExportLabelsTaskRunRequest
        include JSON::Serializable

        # The Amazon S3 path where you export the labels.

        @[JSON::Field(key: "OutputS3Path")]
        getter output_s3_path : String

        # The unique identifier of the machine learning transform.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String

        def initialize(
          @output_s3_path : String,
          @transform_id : String
        )
        end
      end


      struct StartExportLabelsTaskRunResponse
        include JSON::Serializable

        # The unique identifier for the task run.

        @[JSON::Field(key: "TaskRunId")]
        getter task_run_id : String?

        def initialize(
          @task_run_id : String? = nil
        )
        end
      end


      struct StartImportLabelsTaskRunRequest
        include JSON::Serializable

        # The Amazon Simple Storage Service (Amazon S3) path from where you import the labels.

        @[JSON::Field(key: "InputS3Path")]
        getter input_s3_path : String

        # The unique identifier of the machine learning transform.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String

        # Indicates whether to overwrite your existing labels.

        @[JSON::Field(key: "ReplaceAllLabels")]
        getter replace_all_labels : Bool?

        def initialize(
          @input_s3_path : String,
          @transform_id : String,
          @replace_all_labels : Bool? = nil
        )
        end
      end


      struct StartImportLabelsTaskRunResponse
        include JSON::Serializable

        # The unique identifier for the task run.

        @[JSON::Field(key: "TaskRunId")]
        getter task_run_id : String?

        def initialize(
          @task_run_id : String? = nil
        )
        end
      end


      struct StartJobRunRequest
        include JSON::Serializable

        # The name of the job definition to use.

        @[JSON::Field(key: "JobName")]
        getter job_name : String

        # This field is deprecated. Use MaxCapacity instead. The number of Glue data processing units (DPUs)
        # to allocate to this JobRun. You can allocate a minimum of 2 DPUs; the default is 10. A DPU is a
        # relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of
        # memory. For more information, see the Glue pricing page .

        @[JSON::Field(key: "AllocatedCapacity")]
        getter allocated_capacity : Int32?

        # The job arguments associated with this run. For this job run, they replace the default arguments set
        # in the job definition itself. You can specify arguments here that your own job-execution script
        # consumes, as well as arguments that Glue itself consumes. Job arguments may be logged. Do not pass
        # plaintext secrets as arguments. Retrieve secrets from a Glue Connection, Secrets Manager or other
        # secret management mechanism if you intend to keep them within the Job. For information about how to
        # specify and consume your own Job arguments, see the Calling Glue APIs in Python topic in the
        # developer guide. For information about the arguments you can provide to this field when configuring
        # Spark jobs, see the Special Parameters Used by Glue topic in the developer guide. For information
        # about the arguments you can provide to this field when configuring Ray jobs, see Using job
        # parameters in Ray jobs in the developer guide.

        @[JSON::Field(key: "Arguments")]
        getter arguments : Hash(String, String)?

        # Indicates whether the job is run with a standard or flexible execution class. The standard
        # execution-class is ideal for time-sensitive workloads that require fast job startup and dedicated
        # resources. The flexible execution class is appropriate for time-insensitive jobs whose start and
        # completion times may vary. Only jobs with Glue version 3.0 and above and command type glueetl will
        # be allowed to set ExecutionClass to FLEX . The flexible execution class is available for Spark jobs.

        @[JSON::Field(key: "ExecutionClass")]
        getter execution_class : String?

        # This inline session policy to the StartJobRun API allows you to dynamically restrict the permissions
        # of the specified execution role for the scope of the job, without requiring the creation of
        # additional IAM roles.

        @[JSON::Field(key: "ExecutionRoleSessionPolicy")]
        getter execution_role_session_policy : String?

        # The ID of a previous JobRun to retry.

        @[JSON::Field(key: "JobRunId")]
        getter job_run_id : String?

        # Specifies whether job run queuing is enabled for the job run. A value of true means job run queuing
        # is enabled for the job run. If false or not populated, the job run will not be considered for
        # queueing.

        @[JSON::Field(key: "JobRunQueuingEnabled")]
        getter job_run_queuing_enabled : Bool?

        # For Glue version 1.0 or earlier jobs, using the standard worker type, the number of Glue data
        # processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of
        # processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more
        # information, see the Glue pricing page . For Glue version 2.0+ jobs, you cannot specify a Maximum
        # capacity . Instead, you should specify a Worker type and the Number of workers . Do not set
        # MaxCapacity if using WorkerType and NumberOfWorkers . The value that can be allocated for
        # MaxCapacity depends on whether you are running a Python shell job, an Apache Spark ETL job, or an
        # Apache Spark streaming ETL job: When you specify a Python shell job ( JobCommand.Name
        # ="pythonshell"), you can allocate either 0.0625 or 1 DPU. The default is 0.0625 DPU. When you
        # specify an Apache Spark ETL job ( JobCommand.Name ="glueetl") or Apache Spark streaming ETL job (
        # JobCommand.Name ="gluestreaming"), you can allocate from 2 to 100 DPUs. The default is 10 DPUs. This
        # job type cannot have a fractional DPU allocation.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # Specifies configuration properties of a job run notification.

        @[JSON::Field(key: "NotificationProperty")]
        getter notification_property : Types::NotificationProperty?

        # The number of workers of a defined workerType that are allocated when a job runs.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The name of the SecurityConfiguration structure to be used with this job run.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        # The JobRun timeout in minutes. This is the maximum time that a job run can consume resources before
        # it is terminated and enters TIMEOUT status. This value overrides the timeout value set in the parent
        # job. Jobs must have timeout values less than 7 days or 10080 minutes. Otherwise, the jobs will throw
        # an exception. When the value is left blank, the timeout is defaulted to 2880 minutes. Any existing
        # Glue jobs that had a timeout value greater than 7 days will be defaulted to 7 days. For instance if
        # you have specified a timeout of 20 days for a batch job, it will be stopped on the 7th day. For
        # streaming jobs, if you have set up a maintenance window, it will be restarted during the maintenance
        # window after 7 days.

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        # The type of predefined worker that is allocated when a job runs. Accepts a value of G.1X, G.2X,
        # G.4X, G.8X or G.025X for Spark jobs. Accepts the value Z.2X for Ray jobs. For the G.1X worker type,
        # each worker maps to 1 DPU (4 vCPUs, 16 GB of memory) with 94GB disk, and provides 1 executor per
        # worker. We recommend this worker type for workloads such as data transforms, joins, and queries, to
        # offers a scalable and cost effective way to run most jobs. For the G.2X worker type, each worker
        # maps to 2 DPU (8 vCPUs, 32 GB of memory) with 138GB disk, and provides 1 executor per worker. We
        # recommend this worker type for workloads such as data transforms, joins, and queries, to offers a
        # scalable and cost effective way to run most jobs. For the G.4X worker type, each worker maps to 4
        # DPU (16 vCPUs, 64 GB of memory) with 256GB disk, and provides 1 executor per worker. We recommend
        # this worker type for jobs whose workloads contain your most demanding transforms, aggregations,
        # joins, and queries. This worker type is available only for Glue version 3.0 or later Spark ETL jobs
        # in the following Amazon Web Services Regions: US East (Ohio), US East (N. Virginia), US West
        # (Oregon), Asia Pacific (Singapore), Asia Pacific (Sydney), Asia Pacific (Tokyo), Canada (Central),
        # Europe (Frankfurt), Europe (Ireland), and Europe (Stockholm). For the G.8X worker type, each worker
        # maps to 8 DPU (32 vCPUs, 128 GB of memory) with 512GB disk, and provides 1 executor per worker. We
        # recommend this worker type for jobs whose workloads contain your most demanding transforms,
        # aggregations, joins, and queries. This worker type is available only for Glue version 3.0 or later
        # Spark ETL jobs, in the same Amazon Web Services Regions as supported for the G.4X worker type. For
        # the G.025X worker type, each worker maps to 0.25 DPU (2 vCPUs, 4 GB of memory) with 84GB disk, and
        # provides 1 executor per worker. We recommend this worker type for low volume streaming jobs. This
        # worker type is only available for Glue version 3.0 or later streaming jobs. For the Z.2X worker
        # type, each worker maps to 2 M-DPU (8vCPUs, 64 GB of memory) with 128 GB disk, and provides up to 8
        # Ray workers based on the autoscaler.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @job_name : String,
          @allocated_capacity : Int32? = nil,
          @arguments : Hash(String, String)? = nil,
          @execution_class : String? = nil,
          @execution_role_session_policy : String? = nil,
          @job_run_id : String? = nil,
          @job_run_queuing_enabled : Bool? = nil,
          @max_capacity : Float64? = nil,
          @notification_property : Types::NotificationProperty? = nil,
          @number_of_workers : Int32? = nil,
          @security_configuration : String? = nil,
          @timeout : Int32? = nil,
          @worker_type : String? = nil
        )
        end
      end


      struct StartJobRunResponse
        include JSON::Serializable

        # The ID assigned to this job run.

        @[JSON::Field(key: "JobRunId")]
        getter job_run_id : String?

        def initialize(
          @job_run_id : String? = nil
        )
        end
      end


      struct StartMLEvaluationTaskRunRequest
        include JSON::Serializable

        # The unique identifier of the machine learning transform.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String

        def initialize(
          @transform_id : String
        )
        end
      end


      struct StartMLEvaluationTaskRunResponse
        include JSON::Serializable

        # The unique identifier associated with this run.

        @[JSON::Field(key: "TaskRunId")]
        getter task_run_id : String?

        def initialize(
          @task_run_id : String? = nil
        )
        end
      end


      struct StartMLLabelingSetGenerationTaskRunRequest
        include JSON::Serializable

        # The Amazon Simple Storage Service (Amazon S3) path where you generate the labeling set.

        @[JSON::Field(key: "OutputS3Path")]
        getter output_s3_path : String

        # The unique identifier of the machine learning transform.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String

        def initialize(
          @output_s3_path : String,
          @transform_id : String
        )
        end
      end


      struct StartMLLabelingSetGenerationTaskRunResponse
        include JSON::Serializable

        # The unique run identifier that is associated with this task run.

        @[JSON::Field(key: "TaskRunId")]
        getter task_run_id : String?

        def initialize(
          @task_run_id : String? = nil
        )
        end
      end


      struct StartMaterializedViewRefreshTaskRunRequest
        include JSON::Serializable

        # The ID of the Data Catalog where the table reside. If none is supplied, the account ID is used by
        # default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table to generate run the materialized view refresh task.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # Specifies whether this is a full refresh of the task run.

        @[JSON::Field(key: "FullRefresh")]
        getter full_refresh : Bool?

        def initialize(
          @catalog_id : String,
          @database_name : String,
          @table_name : String,
          @full_refresh : Bool? = nil
        )
        end
      end


      struct StartMaterializedViewRefreshTaskRunResponse
        include JSON::Serializable

        # The identifier for the materialized view refresh task run.

        @[JSON::Field(key: "MaterializedViewRefreshTaskRunId")]
        getter materialized_view_refresh_task_run_id : String?

        def initialize(
          @materialized_view_refresh_task_run_id : String? = nil
        )
        end
      end


      struct StartTriggerRequest
        include JSON::Serializable

        # The name of the trigger to start.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct StartTriggerResponse
        include JSON::Serializable

        # The name of the trigger that was started.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct StartWorkflowRunRequest
        include JSON::Serializable

        # The name of the workflow to start.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The workflow run properties for the new workflow run. Run properties may be logged. Do not pass
        # plaintext secrets as properties. Retrieve secrets from a Glue Connection, Amazon Web Services
        # Secrets Manager or other secret management mechanism if you intend to use them within the workflow
        # run.

        @[JSON::Field(key: "RunProperties")]
        getter run_properties : Hash(String, String)?

        def initialize(
          @name : String,
          @run_properties : Hash(String, String)? = nil
        )
        end
      end


      struct StartWorkflowRunResponse
        include JSON::Serializable

        # An Id for the new run.

        @[JSON::Field(key: "RunId")]
        getter run_id : String?

        def initialize(
          @run_id : String? = nil
        )
        end
      end

      # The batch condition that started the workflow run. Either the number of events in the batch size
      # arrived, in which case the BatchSize member is non-zero, or the batch window expired, in which case
      # the BatchWindow member is non-zero.

      struct StartingEventBatchCondition
        include JSON::Serializable

        # Number of events in the batch.

        @[JSON::Field(key: "BatchSize")]
        getter batch_size : Int32?

        # Duration of the batch window in seconds.

        @[JSON::Field(key: "BatchWindow")]
        getter batch_window : Int32?

        def initialize(
          @batch_size : Int32? = nil,
          @batch_window : Int32? = nil
        )
        end
      end

      # The statement or request for a particular action to occur in a session.

      struct Statement
        include JSON::Serializable

        # The execution code of the statement.

        @[JSON::Field(key: "Code")]
        getter code : String?

        # The unix time and date that the job definition was completed.

        @[JSON::Field(key: "CompletedOn")]
        getter completed_on : Int64?

        # The ID of the statement.

        @[JSON::Field(key: "Id")]
        getter id : Int32?

        # The output in JSON.

        @[JSON::Field(key: "Output")]
        getter output : Types::StatementOutput?

        # The code execution progress.

        @[JSON::Field(key: "Progress")]
        getter progress : Float64?

        # The unix time and date that the job definition was started.

        @[JSON::Field(key: "StartedOn")]
        getter started_on : Int64?

        # The state while request is actioned.

        @[JSON::Field(key: "State")]
        getter state : String?

        def initialize(
          @code : String? = nil,
          @completed_on : Int64? = nil,
          @id : Int32? = nil,
          @output : Types::StatementOutput? = nil,
          @progress : Float64? = nil,
          @started_on : Int64? = nil,
          @state : String? = nil
        )
        end
      end

      # The code execution output in JSON format.

      struct StatementOutput
        include JSON::Serializable

        # The code execution output.

        @[JSON::Field(key: "Data")]
        getter data : Types::StatementOutputData?

        # The name of the error in the output.

        @[JSON::Field(key: "ErrorName")]
        getter error_name : String?

        # The error value of the output.

        @[JSON::Field(key: "ErrorValue")]
        getter error_value : String?

        # The execution count of the output.

        @[JSON::Field(key: "ExecutionCount")]
        getter execution_count : Int32?

        # The status of the code execution output.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The traceback of the output.

        @[JSON::Field(key: "Traceback")]
        getter traceback : Array(String)?

        def initialize(
          @data : Types::StatementOutputData? = nil,
          @error_name : String? = nil,
          @error_value : String? = nil,
          @execution_count : Int32? = nil,
          @status : String? = nil,
          @traceback : Array(String)? = nil
        )
        end
      end

      # The code execution output in JSON format.

      struct StatementOutputData
        include JSON::Serializable

        # The code execution output in text format.

        @[JSON::Field(key: "TextPlain")]
        getter text_plain : String?

        def initialize(
          @text_plain : String? = nil
        )
        end
      end

      # A Statistic Annotation.

      struct StatisticAnnotation
        include JSON::Serializable

        # The inclusion annotation applied to the statistic.

        @[JSON::Field(key: "InclusionAnnotation")]
        getter inclusion_annotation : Types::TimestampedInclusionAnnotation?

        # The Profile ID.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String?

        # The Statistic ID.

        @[JSON::Field(key: "StatisticId")]
        getter statistic_id : String?

        # The timestamp when the annotated statistic was recorded.

        @[JSON::Field(key: "StatisticRecordedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter statistic_recorded_on : Time?

        def initialize(
          @inclusion_annotation : Types::TimestampedInclusionAnnotation? = nil,
          @profile_id : String? = nil,
          @statistic_id : String? = nil,
          @statistic_recorded_on : Time? = nil
        )
        end
      end

      # The statistic model result.

      struct StatisticModelResult
        include JSON::Serializable

        # The actual value.

        @[JSON::Field(key: "ActualValue")]
        getter actual_value : Float64?

        # The date.

        @[JSON::Field(key: "Date", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter date : Time?

        # The inclusion annotation.

        @[JSON::Field(key: "InclusionAnnotation")]
        getter inclusion_annotation : String?

        # The lower bound.

        @[JSON::Field(key: "LowerBound")]
        getter lower_bound : Float64?

        # The predicted value.

        @[JSON::Field(key: "PredictedValue")]
        getter predicted_value : Float64?

        # The upper bound.

        @[JSON::Field(key: "UpperBound")]
        getter upper_bound : Float64?

        def initialize(
          @actual_value : Float64? = nil,
          @date : Time? = nil,
          @inclusion_annotation : String? = nil,
          @lower_bound : Float64? = nil,
          @predicted_value : Float64? = nil,
          @upper_bound : Float64? = nil
        )
        end
      end

      # Summary information about a statistic.

      struct StatisticSummary
        include JSON::Serializable

        # The list of columns referenced by the statistic.

        @[JSON::Field(key: "ColumnsReferenced")]
        getter columns_referenced : Array(String)?

        # The value of the statistic.

        @[JSON::Field(key: "DoubleValue")]
        getter double_value : Float64?

        # The evaluation level of the statistic. Possible values: Dataset , Column , Multicolumn .

        @[JSON::Field(key: "EvaluationLevel")]
        getter evaluation_level : String?

        # The inclusion annotation for the statistic.

        @[JSON::Field(key: "InclusionAnnotation")]
        getter inclusion_annotation : Types::TimestampedInclusionAnnotation?

        # The Profile ID.

        @[JSON::Field(key: "ProfileId")]
        getter profile_id : String?

        # The timestamp when the statistic was recorded.

        @[JSON::Field(key: "RecordedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter recorded_on : Time?

        # The list of datasets referenced by the statistic.

        @[JSON::Field(key: "ReferencedDatasets")]
        getter referenced_datasets : Array(String)?

        # The Run Identifier

        @[JSON::Field(key: "RunIdentifier")]
        getter run_identifier : Types::RunIdentifier?

        # The Statistic ID.

        @[JSON::Field(key: "StatisticId")]
        getter statistic_id : String?

        # The name of the statistic.

        @[JSON::Field(key: "StatisticName")]
        getter statistic_name : String?

        # A StatisticPropertiesMap , which contains a NameString and DescriptionString

        @[JSON::Field(key: "StatisticProperties")]
        getter statistic_properties : Hash(String, String)?

        def initialize(
          @columns_referenced : Array(String)? = nil,
          @double_value : Float64? = nil,
          @evaluation_level : String? = nil,
          @inclusion_annotation : Types::TimestampedInclusionAnnotation? = nil,
          @profile_id : String? = nil,
          @recorded_on : Time? = nil,
          @referenced_datasets : Array(String)? = nil,
          @run_identifier : Types::RunIdentifier? = nil,
          @statistic_id : String? = nil,
          @statistic_name : String? = nil,
          @statistic_properties : Hash(String, String)? = nil
        )
        end
      end

      # A structure containing information about an asynchronous change to a table.

      struct StatusDetails
        include JSON::Serializable

        # A Table object representing the requested changes.

        @[JSON::Field(key: "RequestedChange")]
        getter requested_change : Types::Table?

        # A list of ViewValidation objects that contain information for an analytical engine to validate a
        # view.

        @[JSON::Field(key: "ViewValidations")]
        getter view_validations : Array(Types::ViewValidation)?

        def initialize(
          @requested_change : Types::Table? = nil,
          @view_validations : Array(Types::ViewValidation)? = nil
        )
        end
      end


      struct StopColumnStatisticsTaskRunRequest
        include JSON::Serializable

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        def initialize(
          @database_name : String,
          @table_name : String
        )
        end
      end


      struct StopColumnStatisticsTaskRunResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct StopColumnStatisticsTaskRunScheduleRequest
        include JSON::Serializable

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table for which to stop a column statistic task run schedule.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        def initialize(
          @database_name : String,
          @table_name : String
        )
        end
      end


      struct StopColumnStatisticsTaskRunScheduleResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct StopCrawlerRequest
        include JSON::Serializable

        # Name of the crawler to stop.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct StopCrawlerResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct StopCrawlerScheduleRequest
        include JSON::Serializable

        # Name of the crawler whose schedule state to set.

        @[JSON::Field(key: "CrawlerName")]
        getter crawler_name : String

        def initialize(
          @crawler_name : String
        )
        end
      end


      struct StopCrawlerScheduleResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct StopMaterializedViewRefreshTaskRunRequest
        include JSON::Serializable

        # The ID of the Data Catalog where the table reside. If none is supplied, the account ID is used by
        # default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table to generate statistics.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        def initialize(
          @catalog_id : String,
          @database_name : String,
          @table_name : String
        )
        end
      end


      struct StopMaterializedViewRefreshTaskRunResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct StopSessionRequest
        include JSON::Serializable

        # The ID of the session to be stopped.

        @[JSON::Field(key: "Id")]
        getter id : String

        # The origin of the request.

        @[JSON::Field(key: "RequestOrigin")]
        getter request_origin : String?

        def initialize(
          @id : String,
          @request_origin : String? = nil
        )
        end
      end


      struct StopSessionResponse
        include JSON::Serializable

        # Returns the Id of the stopped session.

        @[JSON::Field(key: "Id")]
        getter id : String?

        def initialize(
          @id : String? = nil
        )
        end
      end


      struct StopTriggerRequest
        include JSON::Serializable

        # The name of the trigger to stop.

        @[JSON::Field(key: "Name")]
        getter name : String

        def initialize(
          @name : String
        )
        end
      end


      struct StopTriggerResponse
        include JSON::Serializable

        # The name of the trigger that was stopped.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct StopWorkflowRunRequest
        include JSON::Serializable

        # The name of the workflow to stop.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the workflow run to stop.

        @[JSON::Field(key: "RunId")]
        getter run_id : String

        def initialize(
          @name : String,
          @run_id : String
        )
        end
      end


      struct StopWorkflowRunResponse
        include JSON::Serializable

        def initialize
        end
      end

      # Describes the physical storage of table data.

      struct StorageDescriptor
        include JSON::Serializable

        # A list of locations that point to the path where a Delta table is located.

        @[JSON::Field(key: "AdditionalLocations")]
        getter additional_locations : Array(String)?

        # A list of reducer grouping columns, clustering columns, and bucketing columns in the table.

        @[JSON::Field(key: "BucketColumns")]
        getter bucket_columns : Array(String)?

        # A list of the Columns in the table.

        @[JSON::Field(key: "Columns")]
        getter columns : Array(Types::Column)?

        # True if the data in the table is compressed, or False if not.

        @[JSON::Field(key: "Compressed")]
        getter compressed : Bool?

        # The input format: SequenceFileInputFormat (binary), or TextInputFormat , or a custom format.

        @[JSON::Field(key: "InputFormat")]
        getter input_format : String?

        # The physical location of the table. By default, this takes the form of the warehouse location,
        # followed by the database location in the warehouse, followed by the table name.

        @[JSON::Field(key: "Location")]
        getter location : String?

        # Must be specified if the table contains any dimension columns.

        @[JSON::Field(key: "NumberOfBuckets")]
        getter number_of_buckets : Int32?

        # The output format: SequenceFileOutputFormat (binary), or IgnoreKeyTextOutputFormat , or a custom
        # format.

        @[JSON::Field(key: "OutputFormat")]
        getter output_format : String?

        # The user-supplied properties in key-value form.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # An object that references a schema stored in the Glue Schema Registry. When creating a table, you
        # can pass an empty list of columns for the schema, and instead use a schema reference.

        @[JSON::Field(key: "SchemaReference")]
        getter schema_reference : Types::SchemaReference?

        # The serialization/deserialization (SerDe) information.

        @[JSON::Field(key: "SerdeInfo")]
        getter serde_info : Types::SerDeInfo?

        # The information about values that appear frequently in a column (skewed values).

        @[JSON::Field(key: "SkewedInfo")]
        getter skewed_info : Types::SkewedInfo?

        # A list specifying the sort order of each bucket in the table.

        @[JSON::Field(key: "SortColumns")]
        getter sort_columns : Array(Types::Order)?

        # True if the table data is stored in subdirectories, or False if not.

        @[JSON::Field(key: "StoredAsSubDirectories")]
        getter stored_as_sub_directories : Bool?

        def initialize(
          @additional_locations : Array(String)? = nil,
          @bucket_columns : Array(String)? = nil,
          @columns : Array(Types::Column)? = nil,
          @compressed : Bool? = nil,
          @input_format : String? = nil,
          @location : String? = nil,
          @number_of_buckets : Int32? = nil,
          @output_format : String? = nil,
          @parameters : Hash(String, String)? = nil,
          @schema_reference : Types::SchemaReference? = nil,
          @serde_info : Types::SerDeInfo? = nil,
          @skewed_info : Types::SkewedInfo? = nil,
          @sort_columns : Array(Types::Order)? = nil,
          @stored_as_sub_directories : Bool? = nil
        )
        end
      end

      # Specifies options related to data preview for viewing a sample of your data.

      struct StreamingDataPreviewOptions
        include JSON::Serializable

        # The polling time in milliseconds.

        @[JSON::Field(key: "PollingTime")]
        getter polling_time : Int64?

        # The limit to the number of records polled.

        @[JSON::Field(key: "RecordPollingLimit")]
        getter record_polling_limit : Int64?

        def initialize(
          @polling_time : Int64? = nil,
          @record_polling_limit : Int64? = nil
        )
        end
      end

      # Defines column statistics supported for character sequence data values.

      struct StringColumnStatisticsData
        include JSON::Serializable

        # The average string length in the column.

        @[JSON::Field(key: "AverageLength")]
        getter average_length : Float64

        # The size of the longest string in the column.

        @[JSON::Field(key: "MaximumLength")]
        getter maximum_length : Int64

        # The number of distinct values in a column.

        @[JSON::Field(key: "NumberOfDistinctValues")]
        getter number_of_distinct_values : Int64

        # The number of null values in the column.

        @[JSON::Field(key: "NumberOfNulls")]
        getter number_of_nulls : Int64

        def initialize(
          @average_length : Float64,
          @maximum_length : Int64,
          @number_of_distinct_values : Int64,
          @number_of_nulls : Int64
        )
        end
      end

      # A structure specifying the dialect and dialect version used by the query engine.

      struct SupportedDialect
        include JSON::Serializable

        # The dialect of the query engine.

        @[JSON::Field(key: "Dialect")]
        getter dialect : String?

        # The version of the dialect of the query engine. For example, 3.0.0.

        @[JSON::Field(key: "DialectVersion")]
        getter dialect_version : String?

        def initialize(
          @dialect : String? = nil,
          @dialect_version : String? = nil
        )
        end
      end

      # Represents a collection of related data organized in columns and rows.

      struct Table
        include JSON::Serializable

        # The table name. For Hive compatibility, this must be entirely lowercase.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the Data Catalog in which the table resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The time when the table definition was created in the Data Catalog.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time?

        # The person or entity who created the table.

        @[JSON::Field(key: "CreatedBy")]
        getter created_by : String?

        # The name of the database where the table metadata resides. For Hive compatibility, this must be all
        # lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # A description of the table.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A FederatedTable structure that references an entity outside the Glue Data Catalog.

        @[JSON::Field(key: "FederatedTable")]
        getter federated_table : Types::FederatedTable?

        # Indicates a table is a MaterializedView .

        @[JSON::Field(key: "IsMaterializedView")]
        getter is_materialized_view : Bool?

        # Specifies whether the view supports the SQL dialects of one or more different query engines and can
        # therefore be read by those engines.

        @[JSON::Field(key: "IsMultiDialectView")]
        getter is_multi_dialect_view : Bool?

        # Indicates whether the table has been registered with Lake Formation.

        @[JSON::Field(key: "IsRegisteredWithLakeFormation")]
        getter is_registered_with_lake_formation : Bool?

        # The last time that the table was accessed. This is usually taken from HDFS, and might not be
        # reliable.

        @[JSON::Field(key: "LastAccessTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_access_time : Time?

        # The last time that column statistics were computed for this table.

        @[JSON::Field(key: "LastAnalyzedTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_analyzed_time : Time?

        # The owner of the table.

        @[JSON::Field(key: "Owner")]
        getter owner : String?

        # These key-value pairs define properties associated with the table.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # A list of columns by which the table is partitioned. Only primitive types are supported as partition
        # keys. When you create a table used by Amazon Athena, and you do not specify any partitionKeys , you
        # must at least set the value of partitionKeys to an empty list. For example: "PartitionKeys": []

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Types::Column)?

        # The retention time for this table.

        @[JSON::Field(key: "Retention")]
        getter retention : Int32?

        # Indicates the the state of an asynchronous change to a table.

        @[JSON::Field(key: "Status")]
        getter status : Types::TableStatus?

        # A storage descriptor containing information about the physical storage of this table.

        @[JSON::Field(key: "StorageDescriptor")]
        getter storage_descriptor : Types::StorageDescriptor?

        # The type of this table. Glue will create tables with the EXTERNAL_TABLE type. Other services, such
        # as Athena, may create tables with additional table types. Glue related table types: EXTERNAL_TABLE
        # Hive compatible attribute - indicates a non-Hive managed table. GOVERNED Used by Lake Formation. The
        # Glue Data Catalog understands GOVERNED .

        @[JSON::Field(key: "TableType")]
        getter table_type : String?

        # A TableIdentifier structure that describes a target table for resource linking.

        @[JSON::Field(key: "TargetTable")]
        getter target_table : Types::TableIdentifier?

        # The last time that the table was updated.

        @[JSON::Field(key: "UpdateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter update_time : Time?

        # The ID of the table version.

        @[JSON::Field(key: "VersionId")]
        getter version_id : String?

        # A structure that contains all the information that defines the view, including the dialect or
        # dialects for the view, and the query.

        @[JSON::Field(key: "ViewDefinition")]
        getter view_definition : Types::ViewDefinition?

        # Included for Apache Hive compatibility. Not used in the normal course of Glue operations.

        @[JSON::Field(key: "ViewExpandedText")]
        getter view_expanded_text : String?

        # Included for Apache Hive compatibility. Not used in the normal course of Glue operations. If the
        # table is a VIRTUAL_VIEW , certain Athena configuration encoded in base64.

        @[JSON::Field(key: "ViewOriginalText")]
        getter view_original_text : String?

        def initialize(
          @name : String,
          @catalog_id : String? = nil,
          @create_time : Time? = nil,
          @created_by : String? = nil,
          @database_name : String? = nil,
          @description : String? = nil,
          @federated_table : Types::FederatedTable? = nil,
          @is_materialized_view : Bool? = nil,
          @is_multi_dialect_view : Bool? = nil,
          @is_registered_with_lake_formation : Bool? = nil,
          @last_access_time : Time? = nil,
          @last_analyzed_time : Time? = nil,
          @owner : String? = nil,
          @parameters : Hash(String, String)? = nil,
          @partition_keys : Array(Types::Column)? = nil,
          @retention : Int32? = nil,
          @status : Types::TableStatus? = nil,
          @storage_descriptor : Types::StorageDescriptor? = nil,
          @table_type : String? = nil,
          @target_table : Types::TableIdentifier? = nil,
          @update_time : Time? = nil,
          @version_id : String? = nil,
          @view_definition : Types::ViewDefinition? = nil,
          @view_expanded_text : String? = nil,
          @view_original_text : String? = nil
        )
        end
      end

      # An error record for table operations.

      struct TableError
        include JSON::Serializable

        # The details about the error.

        @[JSON::Field(key: "ErrorDetail")]
        getter error_detail : Types::ErrorDetail?

        # The name of the table. For Hive compatibility, this must be entirely lowercase.

        @[JSON::Field(key: "TableName")]
        getter table_name : String?

        def initialize(
          @error_detail : Types::ErrorDetail? = nil,
          @table_name : String? = nil
        )
        end
      end

      # A structure that describes a target table for resource linking.

      struct TableIdentifier
        include JSON::Serializable

        # The ID of the Data Catalog in which the table resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The name of the catalog database that contains the target table.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # The name of the target table.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # Region of the target table.

        @[JSON::Field(key: "Region")]
        getter region : String?

        def initialize(
          @catalog_id : String? = nil,
          @database_name : String? = nil,
          @name : String? = nil,
          @region : String? = nil
        )
        end
      end

      # A structure used to define a table.

      struct TableInput
        include JSON::Serializable

        # The table name. For Hive compatibility, this is folded to lowercase when it is stored.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A description of the table.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The last time that the table was accessed.

        @[JSON::Field(key: "LastAccessTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_access_time : Time?

        # The last time that column statistics were computed for this table.

        @[JSON::Field(key: "LastAnalyzedTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_analyzed_time : Time?

        # The table owner. Included for Apache Hive compatibility. Not used in the normal course of Glue
        # operations.

        @[JSON::Field(key: "Owner")]
        getter owner : String?

        # These key-value pairs define properties associated with the table.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Hash(String, String)?

        # A list of columns by which the table is partitioned. Only primitive types are supported as partition
        # keys. When you create a table used by Amazon Athena, and you do not specify any partitionKeys , you
        # must at least set the value of partitionKeys to an empty list. For example: "PartitionKeys": []

        @[JSON::Field(key: "PartitionKeys")]
        getter partition_keys : Array(Types::Column)?

        # The retention time for this table.

        @[JSON::Field(key: "Retention")]
        getter retention : Int32?

        # A storage descriptor containing information about the physical storage of this table.

        @[JSON::Field(key: "StorageDescriptor")]
        getter storage_descriptor : Types::StorageDescriptor?

        # The type of this table. Glue will create tables with the EXTERNAL_TABLE type. Other services, such
        # as Athena, may create tables with additional table types. Glue related table types: EXTERNAL_TABLE
        # Hive compatible attribute - indicates a non-Hive managed table. GOVERNED Used by Lake Formation. The
        # Glue Data Catalog understands GOVERNED .

        @[JSON::Field(key: "TableType")]
        getter table_type : String?

        # A TableIdentifier structure that describes a target table for resource linking.

        @[JSON::Field(key: "TargetTable")]
        getter target_table : Types::TableIdentifier?

        # A structure that contains all the information that defines the view, including the dialect or
        # dialects for the view, and the query.

        @[JSON::Field(key: "ViewDefinition")]
        getter view_definition : Types::ViewDefinitionInput?

        # Included for Apache Hive compatibility. Not used in the normal course of Glue operations.

        @[JSON::Field(key: "ViewExpandedText")]
        getter view_expanded_text : String?

        # Included for Apache Hive compatibility. Not used in the normal course of Glue operations. If the
        # table is a VIRTUAL_VIEW , certain Athena configuration encoded in base64.

        @[JSON::Field(key: "ViewOriginalText")]
        getter view_original_text : String?

        def initialize(
          @name : String,
          @description : String? = nil,
          @last_access_time : Time? = nil,
          @last_analyzed_time : Time? = nil,
          @owner : String? = nil,
          @parameters : Hash(String, String)? = nil,
          @partition_keys : Array(Types::Column)? = nil,
          @retention : Int32? = nil,
          @storage_descriptor : Types::StorageDescriptor? = nil,
          @table_type : String? = nil,
          @target_table : Types::TableIdentifier? = nil,
          @view_definition : Types::ViewDefinitionInput? = nil,
          @view_expanded_text : String? = nil,
          @view_original_text : String? = nil
        )
        end
      end

      # Contains details about an optimizer associated with a table.

      struct TableOptimizer
        include JSON::Serializable

        # A TableOptimizerConfiguration object that was specified when creating or updating a table optimizer.

        @[JSON::Field(key: "configuration")]
        getter configuration : Types::TableOptimizerConfiguration?

        # Specifies the source of the optimizer configuration. This indicates how the table optimizer was
        # configured and which entity or service initiated the configuration.

        @[JSON::Field(key: "configurationSource")]
        getter configuration_source : String?

        # A TableOptimizerRun object representing the last run of the table optimizer.

        @[JSON::Field(key: "lastRun")]
        getter last_run : Types::TableOptimizerRun?

        # The type of table optimizer. The valid values are: compaction : for managing compaction with a table
        # optimizer. retention : for managing the retention of snapshot with a table optimizer.
        # orphan_file_deletion : for managing the deletion of orphan files with a table optimizer.

        @[JSON::Field(key: "type")]
        getter type : String?

        def initialize(
          @configuration : Types::TableOptimizerConfiguration? = nil,
          @configuration_source : String? = nil,
          @last_run : Types::TableOptimizerRun? = nil,
          @type : String? = nil
        )
        end
      end

      # Contains details on the configuration of a table optimizer. You pass this configuration when
      # creating or updating a table optimizer.

      struct TableOptimizerConfiguration
        include JSON::Serializable

        # The configuration for a compaction optimizer. This configuration defines how data files in your
        # table will be compacted to improve query performance and reduce storage costs.

        @[JSON::Field(key: "compactionConfiguration")]
        getter compaction_configuration : Types::CompactionConfiguration?

        # Whether table optimization is enabled.

        @[JSON::Field(key: "enabled")]
        getter enabled : Bool?

        # The configuration for an orphan file deletion optimizer.

        @[JSON::Field(key: "orphanFileDeletionConfiguration")]
        getter orphan_file_deletion_configuration : Types::OrphanFileDeletionConfiguration?

        # The configuration for a snapshot retention optimizer.

        @[JSON::Field(key: "retentionConfiguration")]
        getter retention_configuration : Types::RetentionConfiguration?

        # A role passed by the caller which gives the service permission to update the resources associated
        # with the optimizer on the caller's behalf.

        @[JSON::Field(key: "roleArn")]
        getter role_arn : String?

        # A TableOptimizerVpcConfiguration object representing the VPC configuration for a table optimizer.
        # This configuration is necessary to perform optimization on tables that are in a customer VPC.

        @[JSON::Field(key: "vpcConfiguration")]
        getter vpc_configuration : Types::TableOptimizerVpcConfiguration?

        def initialize(
          @compaction_configuration : Types::CompactionConfiguration? = nil,
          @enabled : Bool? = nil,
          @orphan_file_deletion_configuration : Types::OrphanFileDeletionConfiguration? = nil,
          @retention_configuration : Types::RetentionConfiguration? = nil,
          @role_arn : String? = nil,
          @vpc_configuration : Types::TableOptimizerVpcConfiguration? = nil
        )
        end
      end

      # Contains details for a table optimizer run.

      struct TableOptimizerRun
        include JSON::Serializable

        # A CompactionMetrics object containing metrics for the optimizer run.

        @[JSON::Field(key: "compactionMetrics")]
        getter compaction_metrics : Types::CompactionMetrics?

        # The strategy used for the compaction run. Indicates which algorithm was applied to determine how
        # files were selected and combined during the compaction process. Valid values are: binpack : Combines
        # small files into larger files, typically targeting sizes over 100MB, while applying any pending
        # deletes. This is the recommended compaction strategy for most use cases. sort : Organizes data based
        # on specified columns which are sorted hierarchically during compaction, improving query performance
        # for filtered operations. This strategy is recommended when your queries frequently filter on
        # specific columns. To use this strategy, you must first define a sort order in your Iceberg table
        # properties using the sort_order table property. z-order : Optimizes data organization by blending
        # multiple attributes into a single scalar value that can be used for sorting, allowing efficient
        # querying across multiple dimensions. This strategy is recommended when you need to query data across
        # multiple dimensions simultaneously. To use this strategy, you must first define a sort order in your
        # Iceberg table properties using the sort_order table property.

        @[JSON::Field(key: "compactionStrategy")]
        getter compaction_strategy : String?

        # Represents the epoch timestamp at which the compaction job ended.

        @[JSON::Field(key: "endTimestamp", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter end_timestamp : Time?

        # An error that occured during the optimizer run.

        @[JSON::Field(key: "error")]
        getter error : String?

        # An event type representing the status of the table optimizer run.

        @[JSON::Field(key: "eventType")]
        getter event_type : String?

        # A RunMetrics object containing metrics for the optimizer run. This member is deprecated. See the
        # individual metric members for compaction, retention, and orphan file deletion.

        @[JSON::Field(key: "metrics")]
        getter metrics : Types::RunMetrics?

        # An OrphanFileDeletionMetrics object containing metrics for the optimizer run.

        @[JSON::Field(key: "orphanFileDeletionMetrics")]
        getter orphan_file_deletion_metrics : Types::OrphanFileDeletionMetrics?

        # A RetentionMetrics object containing metrics for the optimizer run.

        @[JSON::Field(key: "retentionMetrics")]
        getter retention_metrics : Types::RetentionMetrics?

        # Represents the epoch timestamp at which the compaction job was started within Lake Formation.

        @[JSON::Field(key: "startTimestamp", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter start_timestamp : Time?

        def initialize(
          @compaction_metrics : Types::CompactionMetrics? = nil,
          @compaction_strategy : String? = nil,
          @end_timestamp : Time? = nil,
          @error : String? = nil,
          @event_type : String? = nil,
          @metrics : Types::RunMetrics? = nil,
          @orphan_file_deletion_metrics : Types::OrphanFileDeletionMetrics? = nil,
          @retention_metrics : Types::RetentionMetrics? = nil,
          @start_timestamp : Time? = nil
        )
        end
      end

      # An object that describes the VPC configuration for a table optimizer. This configuration is
      # necessary to perform optimization on tables that are in a customer VPC.

      struct TableOptimizerVpcConfiguration
        include JSON::Serializable

        # The name of the Glue connection used for the VPC for the table optimizer.

        @[JSON::Field(key: "glueConnectionName")]
        getter glue_connection_name : String?

        def initialize(
          @glue_connection_name : String? = nil
        )
        end
      end

      # A structure containing information about the state of an asynchronous change to a table.

      struct TableStatus
        include JSON::Serializable

        # Indicates which action was called on the table, currently only CREATE or UPDATE .

        @[JSON::Field(key: "Action")]
        getter action : String?

        # A StatusDetails object with information about the requested change.

        @[JSON::Field(key: "Details")]
        getter details : Types::StatusDetails?

        # An error that will only appear when the state is "FAILED". This is a parent level exception message,
        # there may be different Error s for each dialect.

        @[JSON::Field(key: "Error")]
        getter error : Types::ErrorDetail?

        # An ISO 8601 formatted date string indicating the time that the change was initiated.

        @[JSON::Field(key: "RequestTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter request_time : Time?

        # The ARN of the user who requested the asynchronous change.

        @[JSON::Field(key: "RequestedBy")]
        getter requested_by : String?

        # A generic status for the change in progress, such as QUEUED, IN_PROGRESS, SUCCESS, or FAILED.

        @[JSON::Field(key: "State")]
        getter state : String?

        # An ISO 8601 formatted date string indicating the time that the state was last updated.

        @[JSON::Field(key: "UpdateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter update_time : Time?

        # The ARN of the user to last manually alter the asynchronous change (requesting cancellation, etc).

        @[JSON::Field(key: "UpdatedBy")]
        getter updated_by : String?

        def initialize(
          @action : String? = nil,
          @details : Types::StatusDetails? = nil,
          @error : Types::ErrorDetail? = nil,
          @request_time : Time? = nil,
          @requested_by : String? = nil,
          @state : String? = nil,
          @update_time : Time? = nil,
          @updated_by : String? = nil
        )
        end
      end

      # Specifies a version of a table.

      struct TableVersion
        include JSON::Serializable

        # The table in question.

        @[JSON::Field(key: "Table")]
        getter table : Types::Table?

        # The ID value that identifies this table version. A VersionId is a string representation of an
        # integer. Each version is incremented by 1.

        @[JSON::Field(key: "VersionId")]
        getter version_id : String?

        def initialize(
          @table : Types::Table? = nil,
          @version_id : String? = nil
        )
        end
      end

      # An error record for table-version operations.

      struct TableVersionError
        include JSON::Serializable

        # The details about the error.

        @[JSON::Field(key: "ErrorDetail")]
        getter error_detail : Types::ErrorDetail?

        # The name of the table in question.

        @[JSON::Field(key: "TableName")]
        getter table_name : String?

        # The ID value of the version in question. A VersionID is a string representation of an integer. Each
        # version is incremented by 1.

        @[JSON::Field(key: "VersionId")]
        getter version_id : String?

        def initialize(
          @error_detail : Types::ErrorDetail? = nil,
          @table_name : String? = nil,
          @version_id : String? = nil
        )
        end
      end

      # The Tag object represents a label that you can assign to an Amazon Web Services resource. Each tag
      # consists of a key and an optional value, both of which you define. For more information about tags,
      # and controlling access to resources in Glue, see Amazon Web Services Tags in Glue and Specifying
      # Glue Resource ARNs in the developer guide.

      struct Tag
        include JSON::Serializable

        # The tag key. The key is required when you create a tag on an object. The key is case-sensitive, and
        # must not contain the prefix aws.

        @[JSON::Field(key: "key")]
        getter key : String?

        # The tag value. The value is optional when you create a tag on an object. The value is
        # case-sensitive, and must not contain the prefix aws.

        @[JSON::Field(key: "value")]
        getter value : String?

        def initialize(
          @key : String? = nil,
          @value : String? = nil
        )
        end
      end


      struct TagResourceRequest
        include JSON::Serializable

        # The ARN of the Glue resource to which to add the tags. For more information about Glue resource
        # ARNs, see the Glue ARN string pattern .

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        # Tags to add to this resource.

        @[JSON::Field(key: "TagsToAdd")]
        getter tags_to_add : Hash(String, String)

        def initialize(
          @resource_arn : String,
          @tags_to_add : Hash(String, String)
        )
        end
      end


      struct TagResourceResponse
        include JSON::Serializable

        def initialize
        end
      end

      # The resource properties associated with the integration target.

      struct TargetProcessingProperties
        include JSON::Serializable

        # The Glue network connection to configure the Glue job running in the customer VPC.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # The ARN of an Eventbridge event bus to receive the integration status notification.

        @[JSON::Field(key: "EventBusArn")]
        getter event_bus_arn : String?

        # The ARN of the KMS key used for encryption.

        @[JSON::Field(key: "KmsArn")]
        getter kms_arn : String?

        # The IAM role to access the Glue database.

        @[JSON::Field(key: "RoleArn")]
        getter role_arn : String?

        def initialize(
          @connection_name : String? = nil,
          @event_bus_arn : String? = nil,
          @kms_arn : String? = nil,
          @role_arn : String? = nil
        )
        end
      end

      # A structure that describes a target catalog for resource linking.

      struct TargetRedshiftCatalog
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the catalog resource.

        @[JSON::Field(key: "CatalogArn")]
        getter catalog_arn : String

        def initialize(
          @catalog_arn : String
        )
        end
      end

      # The target resource could not be found.

      struct TargetResourceNotFound
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # Properties used by the target leg to partition the data on the target.

      struct TargetTableConfig
        include JSON::Serializable

        # Determines the file layout on the target.

        @[JSON::Field(key: "PartitionSpec")]
        getter partition_spec : Array(Types::IntegrationPartition)?

        # The optional name of a target table.

        @[JSON::Field(key: "TargetTableName")]
        getter target_table_name : String?

        # Specifies how nested objects are flattened to top-level elements. Valid values are: "TOPLEVEL",
        # "FULL", or "NOUNNEST".

        @[JSON::Field(key: "UnnestSpec")]
        getter unnest_spec : String?

        def initialize(
          @partition_spec : Array(Types::IntegrationPartition)? = nil,
          @target_table_name : String? = nil,
          @unnest_spec : String? = nil
        )
        end
      end

      # The sampling parameters that are associated with the machine learning transform.

      struct TaskRun
        include JSON::Serializable

        # The last point in time that the requested task run was completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # The list of error strings associated with this task run.

        @[JSON::Field(key: "ErrorString")]
        getter error_string : String?

        # The amount of time (in seconds) that the task run consumed resources.

        @[JSON::Field(key: "ExecutionTime")]
        getter execution_time : Int32?

        # The last point in time that the requested task run was updated.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The names of the log group for secure logging, associated with this task run.

        @[JSON::Field(key: "LogGroupName")]
        getter log_group_name : String?

        # Specifies configuration properties associated with this task run.

        @[JSON::Field(key: "Properties")]
        getter properties : Types::TaskRunProperties?

        # The date and time that this task run started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # The current status of the requested task run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The unique identifier for this task run.

        @[JSON::Field(key: "TaskRunId")]
        getter task_run_id : String?

        # The unique identifier for the transform.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String?

        def initialize(
          @completed_on : Time? = nil,
          @error_string : String? = nil,
          @execution_time : Int32? = nil,
          @last_modified_on : Time? = nil,
          @log_group_name : String? = nil,
          @properties : Types::TaskRunProperties? = nil,
          @started_on : Time? = nil,
          @status : String? = nil,
          @task_run_id : String? = nil,
          @transform_id : String? = nil
        )
        end
      end

      # The criteria that are used to filter the task runs for the machine learning transform.

      struct TaskRunFilterCriteria
        include JSON::Serializable

        # Filter on task runs started after this date.

        @[JSON::Field(key: "StartedAfter", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_after : Time?

        # Filter on task runs started before this date.

        @[JSON::Field(key: "StartedBefore", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_before : Time?

        # The current status of the task run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The type of task run.

        @[JSON::Field(key: "TaskRunType")]
        getter task_run_type : String?

        def initialize(
          @started_after : Time? = nil,
          @started_before : Time? = nil,
          @status : String? = nil,
          @task_run_type : String? = nil
        )
        end
      end

      # The configuration properties for the task run.

      struct TaskRunProperties
        include JSON::Serializable

        # The configuration properties for an exporting labels task run.

        @[JSON::Field(key: "ExportLabelsTaskRunProperties")]
        getter export_labels_task_run_properties : Types::ExportLabelsTaskRunProperties?

        # The configuration properties for a find matches task run.

        @[JSON::Field(key: "FindMatchesTaskRunProperties")]
        getter find_matches_task_run_properties : Types::FindMatchesTaskRunProperties?

        # The configuration properties for an importing labels task run.

        @[JSON::Field(key: "ImportLabelsTaskRunProperties")]
        getter import_labels_task_run_properties : Types::ImportLabelsTaskRunProperties?

        # The configuration properties for a labeling set generation task run.

        @[JSON::Field(key: "LabelingSetGenerationTaskRunProperties")]
        getter labeling_set_generation_task_run_properties : Types::LabelingSetGenerationTaskRunProperties?

        # The type of task run.

        @[JSON::Field(key: "TaskType")]
        getter task_type : String?

        def initialize(
          @export_labels_task_run_properties : Types::ExportLabelsTaskRunProperties? = nil,
          @find_matches_task_run_properties : Types::FindMatchesTaskRunProperties? = nil,
          @import_labels_task_run_properties : Types::ImportLabelsTaskRunProperties? = nil,
          @labeling_set_generation_task_run_properties : Types::LabelingSetGenerationTaskRunProperties? = nil,
          @task_type : String? = nil
        )
        end
      end

      # The sorting criteria that are used to sort the list of task runs for the machine learning transform.

      struct TaskRunSortCriteria
        include JSON::Serializable

        # The column to be used to sort the list of task runs for the machine learning transform.

        @[JSON::Field(key: "Column")]
        getter column : String

        # The sort direction to be used to sort the list of task runs for the machine learning transform.

        @[JSON::Field(key: "SortDirection")]
        getter sort_direction : String

        def initialize(
          @column : String,
          @sort_direction : String
        )
        end
      end

      # A structure that is used to specify testing a connection to a service.

      struct TestConnectionInput
        include JSON::Serializable

        # The key-value pairs that define parameters for the connection. JDBC connections use the following
        # connection properties: Required: All of ( HOST , PORT , JDBC_ENGINE ) or JDBC_CONNECTION_URL .
        # Required: All of ( USERNAME , PASSWORD ) or SECRET_ID . Optional: JDBC_ENFORCE_SSL ,
        # CUSTOM_JDBC_CERT , CUSTOM_JDBC_CERT_STRING , SKIP_CUSTOM_JDBC_CERT_VALIDATION . These parameters are
        # used to configure SSL with JDBC. SALESFORCE connections require the AuthenticationConfiguration
        # member to be configured.

        @[JSON::Field(key: "ConnectionProperties")]
        getter connection_properties : Hash(String, String)

        # The type of connection to test. This operation is only available for the JDBC or SALESFORCE
        # connection types.

        @[JSON::Field(key: "ConnectionType")]
        getter connection_type : String

        # A structure containing the authentication configuration in the TestConnection request. Required for
        # a connection to Salesforce using OAuth authentication.

        @[JSON::Field(key: "AuthenticationConfiguration")]
        getter authentication_configuration : Types::AuthenticationConfigurationInput?

        def initialize(
          @connection_properties : Hash(String, String),
          @connection_type : String,
          @authentication_configuration : Types::AuthenticationConfigurationInput? = nil
        )
        end
      end


      struct TestConnectionRequest
        include JSON::Serializable

        # The catalog ID where the connection resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # Optional. The name of the connection to test. If only name is provided, the operation will get the
        # connection and use that for testing.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # A structure that is used to specify testing a connection to a service.

        @[JSON::Field(key: "TestConnectionInput")]
        getter test_connection_input : Types::TestConnectionInput?

        def initialize(
          @catalog_id : String? = nil,
          @connection_name : String? = nil,
          @test_connection_input : Types::TestConnectionInput? = nil
        )
        end
      end


      struct TestConnectionResponse
        include JSON::Serializable

        def initialize
        end
      end

      # The throttling threshhold was exceeded.

      struct ThrottlingException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # A timestamp filter.

      struct TimestampFilter
        include JSON::Serializable

        # The timestamp after which statistics should be included in the results.

        @[JSON::Field(key: "RecordedAfter", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter recorded_after : Time?

        # The timestamp before which statistics should be included in the results.

        @[JSON::Field(key: "RecordedBefore", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter recorded_before : Time?

        def initialize(
          @recorded_after : Time? = nil,
          @recorded_before : Time? = nil
        )
        end
      end

      # A timestamped inclusion annotation.

      struct TimestampedInclusionAnnotation
        include JSON::Serializable

        # The timestamp when the inclusion annotation was last modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The inclusion annotation value.

        @[JSON::Field(key: "Value")]
        getter value : String?

        def initialize(
          @last_modified_on : Time? = nil,
          @value : String? = nil
        )
        end
      end

      # Specifies the parameters in the config file of the dynamic transform.

      struct TransformConfigParameter
        include JSON::Serializable

        # Specifies the name of the parameter in the config file of the dynamic transform.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Specifies the parameter type in the config file of the dynamic transform.

        @[JSON::Field(key: "Type")]
        getter type : String

        # Specifies whether the parameter is optional or not in the config file of the dynamic transform.

        @[JSON::Field(key: "IsOptional")]
        getter is_optional : Bool?

        # Specifies the list type of the parameter in the config file of the dynamic transform.

        @[JSON::Field(key: "ListType")]
        getter list_type : String?

        # Specifies the validation message in the config file of the dynamic transform.

        @[JSON::Field(key: "ValidationMessage")]
        getter validation_message : String?

        # Specifies the validation rule in the config file of the dynamic transform.

        @[JSON::Field(key: "ValidationRule")]
        getter validation_rule : String?

        # Specifies the value of the parameter in the config file of the dynamic transform.

        @[JSON::Field(key: "Value")]
        getter value : Array(String)?

        def initialize(
          @name : String,
          @type : String,
          @is_optional : Bool? = nil,
          @list_type : String? = nil,
          @validation_message : String? = nil,
          @validation_rule : String? = nil,
          @value : Array(String)? = nil
        )
        end
      end

      # The encryption-at-rest settings of the transform that apply to accessing user data. Machine learning
      # transforms can access user data encrypted in Amazon S3 using KMS. Additionally, imported labels and
      # trained transforms can now be encrypted using a customer provided KMS key.

      struct TransformEncryption
        include JSON::Serializable

        # An MLUserDataEncryption object containing the encryption mode and customer-provided KMS key ID.

        @[JSON::Field(key: "MlUserDataEncryption")]
        getter ml_user_data_encryption : Types::MLUserDataEncryption?

        # The name of the security configuration.

        @[JSON::Field(key: "TaskRunSecurityConfigurationName")]
        getter task_run_security_configuration_name : String?

        def initialize(
          @ml_user_data_encryption : Types::MLUserDataEncryption? = nil,
          @task_run_security_configuration_name : String? = nil
        )
        end
      end

      # The criteria used to filter the machine learning transforms.

      struct TransformFilterCriteria
        include JSON::Serializable

        # The time and date after which the transforms were created.

        @[JSON::Field(key: "CreatedAfter", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_after : Time?

        # The time and date before which the transforms were created.

        @[JSON::Field(key: "CreatedBefore", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_before : Time?

        # This value determines which version of Glue this machine learning transform is compatible with. Glue
        # 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to
        # Glue 0.9. For more information, see Glue Versions in the developer guide.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # Filter on transforms last modified after this date.

        @[JSON::Field(key: "LastModifiedAfter", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_after : Time?

        # Filter on transforms last modified before this date.

        @[JSON::Field(key: "LastModifiedBefore", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_before : Time?

        # A unique transform name that is used to filter the machine learning transforms.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # Filters on datasets with a specific schema. The Map&lt;Column, Type&gt; object is an array of
        # key-value pairs representing the schema this transform accepts, where Column is the name of a
        # column, and Type is the type of the data such as an integer or string. Has an upper bound of 100
        # columns.

        @[JSON::Field(key: "Schema")]
        getter schema : Array(Types::SchemaColumn)?

        # Filters the list of machine learning transforms by the last known status of the transforms (to
        # indicate whether a transform can be used or not). One of "NOT_READY", "READY", or "DELETING".

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The type of machine learning transform that is used to filter the machine learning transforms.

        @[JSON::Field(key: "TransformType")]
        getter transform_type : String?

        def initialize(
          @created_after : Time? = nil,
          @created_before : Time? = nil,
          @glue_version : String? = nil,
          @last_modified_after : Time? = nil,
          @last_modified_before : Time? = nil,
          @name : String? = nil,
          @schema : Array(Types::SchemaColumn)? = nil,
          @status : String? = nil,
          @transform_type : String? = nil
        )
        end
      end

      # The algorithm-specific parameters that are associated with the machine learning transform.

      struct TransformParameters
        include JSON::Serializable

        # The type of machine learning transform. For information about the types of machine learning
        # transforms, see Creating Machine Learning Transforms .

        @[JSON::Field(key: "TransformType")]
        getter transform_type : String

        # The parameters for the find matches algorithm.

        @[JSON::Field(key: "FindMatchesParameters")]
        getter find_matches_parameters : Types::FindMatchesParameters?

        def initialize(
          @transform_type : String,
          @find_matches_parameters : Types::FindMatchesParameters? = nil
        )
        end
      end

      # The sorting criteria that are associated with the machine learning transform.

      struct TransformSortCriteria
        include JSON::Serializable

        # The column to be used in the sorting criteria that are associated with the machine learning
        # transform.

        @[JSON::Field(key: "Column")]
        getter column : String

        # The sort direction to be used in the sorting criteria that are associated with the machine learning
        # transform.

        @[JSON::Field(key: "SortDirection")]
        getter sort_direction : String

        def initialize(
          @column : String,
          @sort_direction : String
        )
        end
      end

      # Information about a specific trigger.

      struct Trigger
        include JSON::Serializable

        # The actions initiated by this trigger.

        @[JSON::Field(key: "Actions")]
        getter actions : Array(Types::Action)?

        # A description of this trigger.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Batch condition that must be met (specified number of events received or batch time window expired)
        # before EventBridge event trigger fires.

        @[JSON::Field(key: "EventBatchingCondition")]
        getter event_batching_condition : Types::EventBatchingCondition?

        # Reserved for future use.

        @[JSON::Field(key: "Id")]
        getter id : String?

        # The name of the trigger.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # The predicate of this trigger, which defines when it will fire.

        @[JSON::Field(key: "Predicate")]
        getter predicate : Types::Predicate?

        # A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers . For
        # example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *) .

        @[JSON::Field(key: "Schedule")]
        getter schedule : String?

        # The current state of the trigger.

        @[JSON::Field(key: "State")]
        getter state : String?

        # The type of trigger that this is.

        @[JSON::Field(key: "Type")]
        getter type : String?

        # The name of the workflow associated with the trigger.

        @[JSON::Field(key: "WorkflowName")]
        getter workflow_name : String?

        def initialize(
          @actions : Array(Types::Action)? = nil,
          @description : String? = nil,
          @event_batching_condition : Types::EventBatchingCondition? = nil,
          @id : String? = nil,
          @name : String? = nil,
          @predicate : Types::Predicate? = nil,
          @schedule : String? = nil,
          @state : String? = nil,
          @type : String? = nil,
          @workflow_name : String? = nil
        )
        end
      end

      # The details of a Trigger node present in the workflow.

      struct TriggerNodeDetails
        include JSON::Serializable

        # The information of the trigger represented by the trigger node.

        @[JSON::Field(key: "Trigger")]
        getter trigger : Types::Trigger?

        def initialize(
          @trigger : Types::Trigger? = nil
        )
        end
      end

      # A structure used to provide information used to update a trigger. This object updates the previous
      # trigger definition by overwriting it completely.

      struct TriggerUpdate
        include JSON::Serializable

        # The actions initiated by this trigger.

        @[JSON::Field(key: "Actions")]
        getter actions : Array(Types::Action)?

        # A description of this trigger.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Batch condition that must be met (specified number of events received or batch time window expired)
        # before EventBridge event trigger fires.

        @[JSON::Field(key: "EventBatchingCondition")]
        getter event_batching_condition : Types::EventBatchingCondition?

        # Reserved for future use.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # The predicate of this trigger, which defines when it will fire.

        @[JSON::Field(key: "Predicate")]
        getter predicate : Types::Predicate?

        # A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers . For
        # example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *) .

        @[JSON::Field(key: "Schedule")]
        getter schedule : String?

        def initialize(
          @actions : Array(Types::Action)? = nil,
          @description : String? = nil,
          @event_batching_condition : Types::EventBatchingCondition? = nil,
          @name : String? = nil,
          @predicate : Types::Predicate? = nil,
          @schedule : String? = nil
        )
        end
      end

      # A partition that contains unfiltered metadata.

      struct UnfilteredPartition
        include JSON::Serializable

        # The list of columns the user has permissions to access.

        @[JSON::Field(key: "AuthorizedColumns")]
        getter authorized_columns : Array(String)?

        # A Boolean value indicating that the partition location is registered with Lake Formation.

        @[JSON::Field(key: "IsRegisteredWithLakeFormation")]
        getter is_registered_with_lake_formation : Bool?

        # The partition object.

        @[JSON::Field(key: "Partition")]
        getter partition : Types::Partition?

        def initialize(
          @authorized_columns : Array(String)? = nil,
          @is_registered_with_lake_formation : Bool? = nil,
          @partition : Types::Partition? = nil
        )
        end
      end

      # Specifies a transform that combines the rows from two or more datasets into a single result.

      struct Union
        include JSON::Serializable

        # The node ID inputs to the transform.

        @[JSON::Field(key: "Inputs")]
        getter inputs : Array(String)

        # The name of the transform node.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Indicates the type of Union transform. Specify ALL to join all rows from data sources to the
        # resulting DynamicFrame. The resulting union does not remove duplicate rows. Specify DISTINCT to
        # remove duplicate rows in the resulting DynamicFrame.

        @[JSON::Field(key: "UnionType")]
        getter union_type : String

        def initialize(
          @inputs : Array(String),
          @name : String,
          @union_type : String
        )
        end
      end


      struct UntagResourceRequest
        include JSON::Serializable

        # The Amazon Resource Name (ARN) of the resource from which to remove the tags.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        # Tags to remove from this resource.

        @[JSON::Field(key: "TagsToRemove")]
        getter tags_to_remove : Array(String)

        def initialize(
          @resource_arn : String,
          @tags_to_remove : Array(String)
        )
        end
      end


      struct UntagResourceResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateBlueprintRequest
        include JSON::Serializable

        # Specifies a path in Amazon S3 where the blueprint is published.

        @[JSON::Field(key: "BlueprintLocation")]
        getter blueprint_location : String

        # The name of the blueprint.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A description of the blueprint.

        @[JSON::Field(key: "Description")]
        getter description : String?

        def initialize(
          @blueprint_location : String,
          @name : String,
          @description : String? = nil
        )
        end
      end


      struct UpdateBlueprintResponse
        include JSON::Serializable

        # Returns the name of the blueprint that was updated.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct UpdateCatalogRequest
        include JSON::Serializable

        # The ID of the catalog.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # A CatalogInput object specifying the new properties of an existing catalog.

        @[JSON::Field(key: "CatalogInput")]
        getter catalog_input : Types::CatalogInput

        def initialize(
          @catalog_id : String,
          @catalog_input : Types::CatalogInput
        )
        end
      end


      struct UpdateCatalogResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateClassifierRequest
        include JSON::Serializable

        # A CsvClassifier object with updated fields.

        @[JSON::Field(key: "CsvClassifier")]
        getter csv_classifier : Types::UpdateCsvClassifierRequest?

        # A GrokClassifier object with updated fields.

        @[JSON::Field(key: "GrokClassifier")]
        getter grok_classifier : Types::UpdateGrokClassifierRequest?

        # A JsonClassifier object with updated fields.

        @[JSON::Field(key: "JsonClassifier")]
        getter json_classifier : Types::UpdateJsonClassifierRequest?

        # An XMLClassifier object with updated fields.

        @[JSON::Field(key: "XMLClassifier")]
        getter xml_classifier : Types::UpdateXMLClassifierRequest?

        def initialize(
          @csv_classifier : Types::UpdateCsvClassifierRequest? = nil,
          @grok_classifier : Types::UpdateGrokClassifierRequest? = nil,
          @json_classifier : Types::UpdateJsonClassifierRequest? = nil,
          @xml_classifier : Types::UpdateXMLClassifierRequest? = nil
        )
        end
      end


      struct UpdateClassifierResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateColumnStatisticsForPartitionRequest
        include JSON::Serializable

        # A list of the column statistics.

        @[JSON::Field(key: "ColumnStatisticsList")]
        getter column_statistics_list : Array(Types::ColumnStatistics)

        # The name of the catalog database where the partitions reside.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A list of partition values identifying the partition.

        @[JSON::Field(key: "PartitionValues")]
        getter partition_values : Array(String)

        # The name of the partitions' table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @column_statistics_list : Array(Types::ColumnStatistics),
          @database_name : String,
          @partition_values : Array(String),
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct UpdateColumnStatisticsForPartitionResponse
        include JSON::Serializable

        # Error occurred during updating column statistics data.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::ColumnStatisticsError)?

        def initialize(
          @errors : Array(Types::ColumnStatisticsError)? = nil
        )
        end
      end


      struct UpdateColumnStatisticsForTableRequest
        include JSON::Serializable

        # A list of the column statistics.

        @[JSON::Field(key: "ColumnStatisticsList")]
        getter column_statistics_list : Array(Types::ColumnStatistics)

        # The name of the catalog database where the partitions reside.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the partitions' table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partitions in question reside. If none is supplied, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @column_statistics_list : Array(Types::ColumnStatistics),
          @database_name : String,
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct UpdateColumnStatisticsForTableResponse
        include JSON::Serializable

        # List of ColumnStatisticsErrors.

        @[JSON::Field(key: "Errors")]
        getter errors : Array(Types::ColumnStatisticsError)?

        def initialize(
          @errors : Array(Types::ColumnStatisticsError)? = nil
        )
        end
      end


      struct UpdateColumnStatisticsTaskSettingsRequest
        include JSON::Serializable

        # The name of the database where the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table for which to generate column statistics.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog in which the database resides.

        @[JSON::Field(key: "CatalogID")]
        getter catalog_id : String?

        # A list of column names for which to run statistics.

        @[JSON::Field(key: "ColumnNameList")]
        getter column_name_list : Array(String)?

        # The role used for running the column statistics.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # The percentage of data to sample.

        @[JSON::Field(key: "SampleSize")]
        getter sample_size : Float64?

        # A schedule for running the column statistics, specified in CRON syntax.

        @[JSON::Field(key: "Schedule")]
        getter schedule : String?

        # Name of the security configuration that is used to encrypt CloudWatch logs.

        @[JSON::Field(key: "SecurityConfiguration")]
        getter security_configuration : String?

        def initialize(
          @database_name : String,
          @table_name : String,
          @catalog_id : String? = nil,
          @column_name_list : Array(String)? = nil,
          @role : String? = nil,
          @sample_size : Float64? = nil,
          @schedule : String? = nil,
          @security_configuration : String? = nil
        )
        end
      end


      struct UpdateColumnStatisticsTaskSettingsResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateConnectionRequest
        include JSON::Serializable

        # A ConnectionInput object that redefines the connection in question.

        @[JSON::Field(key: "ConnectionInput")]
        getter connection_input : Types::ConnectionInput

        # The name of the connection definition to update.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the Data Catalog in which the connection resides. If none is provided, the Amazon Web
        # Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @connection_input : Types::ConnectionInput,
          @name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct UpdateConnectionResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateCrawlerRequest
        include JSON::Serializable

        # Name of the new crawler.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A list of custom classifiers that the user has registered. By default, all built-in classifiers are
        # included in a crawl, but these custom classifiers always override the default classifiers for a
        # given classification.

        @[JSON::Field(key: "Classifiers")]
        getter classifiers : Array(String)?

        # Crawler configuration information. This versioned JSON string allows users to specify aspects of a
        # crawler's behavior. For more information, see Setting crawler configuration options .

        @[JSON::Field(key: "Configuration")]
        getter configuration : String?

        # The name of the SecurityConfiguration structure to be used by this crawler.

        @[JSON::Field(key: "CrawlerSecurityConfiguration")]
        getter crawler_security_configuration : String?

        # The Glue database where results are stored, such as:
        # arn:aws:daylight:us-east-1::database/sometable/* .

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # A description of the new crawler.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Specifies Lake Formation configuration settings for the crawler.

        @[JSON::Field(key: "LakeFormationConfiguration")]
        getter lake_formation_configuration : Types::LakeFormationConfiguration?

        # Specifies data lineage configuration settings for the crawler.

        @[JSON::Field(key: "LineageConfiguration")]
        getter lineage_configuration : Types::LineageConfiguration?

        # A policy that specifies whether to crawl the entire dataset again, or to crawl only folders that
        # were added since the last crawler run.

        @[JSON::Field(key: "RecrawlPolicy")]
        getter recrawl_policy : Types::RecrawlPolicy?

        # The IAM role or Amazon Resource Name (ARN) of an IAM role that is used by the new crawler to access
        # customer resources.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # A cron expression used to specify the schedule (see Time-Based Schedules for Jobs and Crawlers . For
        # example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ? *) .

        @[JSON::Field(key: "Schedule")]
        getter schedule : String?

        # The policy for the crawler's update and deletion behavior.

        @[JSON::Field(key: "SchemaChangePolicy")]
        getter schema_change_policy : Types::SchemaChangePolicy?

        # The table prefix used for catalog tables that are created.

        @[JSON::Field(key: "TablePrefix")]
        getter table_prefix : String?

        # A list of targets to crawl.

        @[JSON::Field(key: "Targets")]
        getter targets : Types::CrawlerTargets?

        def initialize(
          @name : String,
          @classifiers : Array(String)? = nil,
          @configuration : String? = nil,
          @crawler_security_configuration : String? = nil,
          @database_name : String? = nil,
          @description : String? = nil,
          @lake_formation_configuration : Types::LakeFormationConfiguration? = nil,
          @lineage_configuration : Types::LineageConfiguration? = nil,
          @recrawl_policy : Types::RecrawlPolicy? = nil,
          @role : String? = nil,
          @schedule : String? = nil,
          @schema_change_policy : Types::SchemaChangePolicy? = nil,
          @table_prefix : String? = nil,
          @targets : Types::CrawlerTargets? = nil
        )
        end
      end


      struct UpdateCrawlerResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateCrawlerScheduleRequest
        include JSON::Serializable

        # The name of the crawler whose schedule to update.

        @[JSON::Field(key: "CrawlerName")]
        getter crawler_name : String

        # The updated cron expression used to specify the schedule (see Time-Based Schedules for Jobs and
        # Crawlers . For example, to run something every day at 12:15 UTC, you would specify: cron(15 12 * * ?
        # *) .

        @[JSON::Field(key: "Schedule")]
        getter schedule : String?

        def initialize(
          @crawler_name : String,
          @schedule : String? = nil
        )
        end
      end


      struct UpdateCrawlerScheduleResponse
        include JSON::Serializable

        def initialize
        end
      end

      # Specifies a custom CSV classifier to be updated.

      struct UpdateCsvClassifierRequest
        include JSON::Serializable

        # The name of the classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        # Enables the processing of files that contain only one column.

        @[JSON::Field(key: "AllowSingleColumn")]
        getter allow_single_column : Bool?

        # Indicates whether the CSV file contains a header.

        @[JSON::Field(key: "ContainsHeader")]
        getter contains_header : String?

        # Specifies the configuration of custom datatypes.

        @[JSON::Field(key: "CustomDatatypeConfigured")]
        getter custom_datatype_configured : Bool?

        # Specifies a list of supported custom datatypes.

        @[JSON::Field(key: "CustomDatatypes")]
        getter custom_datatypes : Array(String)?

        # A custom symbol to denote what separates each column entry in the row.

        @[JSON::Field(key: "Delimiter")]
        getter delimiter : String?

        # Specifies not to trim values before identifying the type of column values. The default value is
        # true.

        @[JSON::Field(key: "DisableValueTrimming")]
        getter disable_value_trimming : Bool?

        # A list of strings representing column names.

        @[JSON::Field(key: "Header")]
        getter header : Array(String)?

        # A custom symbol to denote what combines content into a single column value. It must be different
        # from the column delimiter.

        @[JSON::Field(key: "QuoteSymbol")]
        getter quote_symbol : String?

        # Sets the SerDe for processing CSV in the classifier, which will be applied in the Data Catalog.
        # Valid values are OpenCSVSerDe , LazySimpleSerDe , and None . You can specify the None value when you
        # want the crawler to do the detection.

        @[JSON::Field(key: "Serde")]
        getter serde : String?

        def initialize(
          @name : String,
          @allow_single_column : Bool? = nil,
          @contains_header : String? = nil,
          @custom_datatype_configured : Bool? = nil,
          @custom_datatypes : Array(String)? = nil,
          @delimiter : String? = nil,
          @disable_value_trimming : Bool? = nil,
          @header : Array(String)? = nil,
          @quote_symbol : String? = nil,
          @serde : String? = nil
        )
        end
      end


      struct UpdateDataQualityRulesetRequest
        include JSON::Serializable

        # The name of the data quality ruleset.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A description of the ruleset.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer
        # guide.

        @[JSON::Field(key: "Ruleset")]
        getter ruleset : String?

        def initialize(
          @name : String,
          @description : String? = nil,
          @ruleset : String? = nil
        )
        end
      end


      struct UpdateDataQualityRulesetResponse
        include JSON::Serializable

        # A description of the ruleset.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The name of the data quality ruleset.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # A Data Quality Definition Language (DQDL) ruleset. For more information, see the Glue developer
        # guide.

        @[JSON::Field(key: "Ruleset")]
        getter ruleset : String?

        def initialize(
          @description : String? = nil,
          @name : String? = nil,
          @ruleset : String? = nil
        )
        end
      end


      struct UpdateDatabaseRequest
        include JSON::Serializable

        # A DatabaseInput object specifying the new definition of the metadata database in the catalog.

        @[JSON::Field(key: "DatabaseInput")]
        getter database_input : Types::DatabaseInput

        # The name of the database to update in the catalog. For Hive compatibility, this is folded to
        # lowercase.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The ID of the Data Catalog in which the metadata database resides. If none is provided, the Amazon
        # Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_input : Types::DatabaseInput,
          @name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct UpdateDatabaseResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateDevEndpointRequest
        include JSON::Serializable

        # The name of the DevEndpoint to be updated.

        @[JSON::Field(key: "EndpointName")]
        getter endpoint_name : String

        # The map of arguments to add the map of arguments used to configure the DevEndpoint . Valid arguments
        # are: "--enable-glue-datacatalog": "" You can specify a version of Python support for development
        # endpoints by using the Arguments parameter in the CreateDevEndpoint or UpdateDevEndpoint APIs. If no
        # arguments are provided, the version defaults to Python 2.

        @[JSON::Field(key: "AddArguments")]
        getter add_arguments : Hash(String, String)?

        # The list of public keys for the DevEndpoint to use.

        @[JSON::Field(key: "AddPublicKeys")]
        getter add_public_keys : Array(String)?

        # Custom Python or Java libraries to be loaded in the DevEndpoint .

        @[JSON::Field(key: "CustomLibraries")]
        getter custom_libraries : Types::DevEndpointCustomLibraries?

        # The list of argument keys to be deleted from the map of arguments used to configure the DevEndpoint
        # .

        @[JSON::Field(key: "DeleteArguments")]
        getter delete_arguments : Array(String)?

        # The list of public keys to be deleted from the DevEndpoint .

        @[JSON::Field(key: "DeletePublicKeys")]
        getter delete_public_keys : Array(String)?

        # The public key for the DevEndpoint to use.

        @[JSON::Field(key: "PublicKey")]
        getter public_key : String?

        # True if the list of custom libraries to be loaded in the development endpoint needs to be updated,
        # or False if otherwise.

        @[JSON::Field(key: "UpdateEtlLibraries")]
        getter update_etl_libraries : Bool?

        def initialize(
          @endpoint_name : String,
          @add_arguments : Hash(String, String)? = nil,
          @add_public_keys : Array(String)? = nil,
          @custom_libraries : Types::DevEndpointCustomLibraries? = nil,
          @delete_arguments : Array(String)? = nil,
          @delete_public_keys : Array(String)? = nil,
          @public_key : String? = nil,
          @update_etl_libraries : Bool? = nil
        )
        end
      end


      struct UpdateDevEndpointResponse
        include JSON::Serializable

        def initialize
        end
      end

      # Request to update an existing Glue Identity Center configuration.

      struct UpdateGlueIdentityCenterConfigurationRequest
        include JSON::Serializable

        # A list of Identity Center scopes that define the updated permissions and access levels for the Glue
        # configuration.

        @[JSON::Field(key: "Scopes")]
        getter scopes : Array(String)?

        # Specifies whether users can run background sessions when using Identity Center authentication with
        # Glue services.

        @[JSON::Field(key: "UserBackgroundSessionsEnabled")]
        getter user_background_sessions_enabled : Bool?

        def initialize(
          @scopes : Array(String)? = nil,
          @user_background_sessions_enabled : Bool? = nil
        )
        end
      end

      # Response from updating an existing Glue Identity Center configuration.

      struct UpdateGlueIdentityCenterConfigurationResponse
        include JSON::Serializable

        def initialize
        end
      end

      # Specifies a grok classifier to update when passed to UpdateClassifier .

      struct UpdateGrokClassifierRequest
        include JSON::Serializable

        # The name of the GrokClassifier .

        @[JSON::Field(key: "Name")]
        getter name : String

        # An identifier of the data format that the classifier matches, such as Twitter, JSON, Omniture logs,
        # Amazon CloudWatch Logs, and so on.

        @[JSON::Field(key: "Classification")]
        getter classification : String?

        # Optional custom grok patterns used by this classifier.

        @[JSON::Field(key: "CustomPatterns")]
        getter custom_patterns : String?

        # The grok pattern used by this classifier.

        @[JSON::Field(key: "GrokPattern")]
        getter grok_pattern : String?

        def initialize(
          @name : String,
          @classification : String? = nil,
          @custom_patterns : String? = nil,
          @grok_pattern : String? = nil
        )
        end
      end

      # Input parameters specific to updating Apache Iceberg tables in Glue Data Catalog, containing the
      # update operations to be applied to an existing Iceberg table.

      struct UpdateIcebergInput
        include JSON::Serializable

        # The specific update operations to be applied to the Iceberg table, containing a list of updates that
        # define the new state of the table including schema, partitions, and properties.

        @[JSON::Field(key: "UpdateIcebergTableInput")]
        getter update_iceberg_table_input : Types::UpdateIcebergTableInput

        def initialize(
          @update_iceberg_table_input : Types::UpdateIcebergTableInput
        )
        end
      end

      # Contains the update operations to be applied to an existing Iceberg table inGlue Data Catalog,
      # defining the new state of the table metadata.

      struct UpdateIcebergTableInput
        include JSON::Serializable

        # The list of table update operations that specify the changes to be made to the Iceberg table,
        # including schema modifications, partition specifications, and table properties.

        @[JSON::Field(key: "Updates")]
        getter updates : Array(Types::IcebergTableUpdate)

        def initialize(
          @updates : Array(Types::IcebergTableUpdate)
        )
        end
      end


      struct UpdateIntegrationResourcePropertyRequest
        include JSON::Serializable

        # The connection ARN of the source, or the database ARN of the target.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        # The resource properties associated with the integration source.

        @[JSON::Field(key: "SourceProcessingProperties")]
        getter source_processing_properties : Types::SourceProcessingProperties?

        # The resource properties associated with the integration target.

        @[JSON::Field(key: "TargetProcessingProperties")]
        getter target_processing_properties : Types::TargetProcessingProperties?

        def initialize(
          @resource_arn : String,
          @source_processing_properties : Types::SourceProcessingProperties? = nil,
          @target_processing_properties : Types::TargetProcessingProperties? = nil
        )
        end
      end


      struct UpdateIntegrationResourcePropertyResponse
        include JSON::Serializable

        # The connection ARN of the source, or the database ARN of the target.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String?

        # The resource ARN created through this create API. The format is something like
        # arn:aws:glue:&lt;region&gt;:&lt;account_id&gt;:integrationresourceproperty/*

        @[JSON::Field(key: "ResourcePropertyArn")]
        getter resource_property_arn : String?

        # The resource properties associated with the integration source.

        @[JSON::Field(key: "SourceProcessingProperties")]
        getter source_processing_properties : Types::SourceProcessingProperties?

        # The resource properties associated with the integration target.

        @[JSON::Field(key: "TargetProcessingProperties")]
        getter target_processing_properties : Types::TargetProcessingProperties?

        def initialize(
          @resource_arn : String? = nil,
          @resource_property_arn : String? = nil,
          @source_processing_properties : Types::SourceProcessingProperties? = nil,
          @target_processing_properties : Types::TargetProcessingProperties? = nil
        )
        end
      end


      struct UpdateIntegrationTablePropertiesRequest
        include JSON::Serializable

        # The connection ARN of the source, or the database ARN of the target.

        @[JSON::Field(key: "ResourceArn")]
        getter resource_arn : String

        # The name of the table to be replicated.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # A structure for the source table configuration.

        @[JSON::Field(key: "SourceTableConfig")]
        getter source_table_config : Types::SourceTableConfig?

        # A structure for the target table configuration.

        @[JSON::Field(key: "TargetTableConfig")]
        getter target_table_config : Types::TargetTableConfig?

        def initialize(
          @resource_arn : String,
          @table_name : String,
          @source_table_config : Types::SourceTableConfig? = nil,
          @target_table_config : Types::TargetTableConfig? = nil
        )
        end
      end


      struct UpdateIntegrationTablePropertiesResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateJobFromSourceControlRequest
        include JSON::Serializable

        # The type of authentication, which can be an authentication token stored in Amazon Web Services
        # Secrets Manager, or a personal access token.

        @[JSON::Field(key: "AuthStrategy")]
        getter auth_strategy : String?

        # The value of the authorization token.

        @[JSON::Field(key: "AuthToken")]
        getter auth_token : String?

        # An optional branch in the remote repository.

        @[JSON::Field(key: "BranchName")]
        getter branch_name : String?

        # A commit ID for a commit in the remote repository.

        @[JSON::Field(key: "CommitId")]
        getter commit_id : String?

        # An optional folder in the remote repository.

        @[JSON::Field(key: "Folder")]
        getter folder : String?

        # The name of the Glue job to be synchronized to or from the remote repository.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # The provider for the remote repository. Possible values: GITHUB, AWS_CODE_COMMIT, GITLAB, BITBUCKET.

        @[JSON::Field(key: "Provider")]
        getter provider : String?

        # The name of the remote repository that contains the job artifacts. For BitBucket providers,
        # RepositoryName should include WorkspaceName . Use the format
        # &lt;WorkspaceName&gt;/&lt;RepositoryName&gt; .

        @[JSON::Field(key: "RepositoryName")]
        getter repository_name : String?

        # The owner of the remote repository that contains the job artifacts.

        @[JSON::Field(key: "RepositoryOwner")]
        getter repository_owner : String?

        def initialize(
          @auth_strategy : String? = nil,
          @auth_token : String? = nil,
          @branch_name : String? = nil,
          @commit_id : String? = nil,
          @folder : String? = nil,
          @job_name : String? = nil,
          @provider : String? = nil,
          @repository_name : String? = nil,
          @repository_owner : String? = nil
        )
        end
      end


      struct UpdateJobFromSourceControlResponse
        include JSON::Serializable

        # The name of the Glue job.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        def initialize(
          @job_name : String? = nil
        )
        end
      end


      struct UpdateJobRequest
        include JSON::Serializable

        # The name of the job definition to update.

        @[JSON::Field(key: "JobName")]
        getter job_name : String

        # Specifies the values with which to update the job definition. Unspecified configuration is removed
        # or reset to default values.

        @[JSON::Field(key: "JobUpdate")]
        getter job_update : Types::JobUpdate

        def initialize(
          @job_name : String,
          @job_update : Types::JobUpdate
        )
        end
      end


      struct UpdateJobResponse
        include JSON::Serializable

        # Returns the name of the updated job definition.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        def initialize(
          @job_name : String? = nil
        )
        end
      end

      # Specifies a JSON classifier to be updated.

      struct UpdateJsonClassifierRequest
        include JSON::Serializable

        # The name of the classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A JsonPath string defining the JSON data for the classifier to classify. Glue supports a subset of
        # JsonPath, as described in Writing JsonPath Custom Classifiers .

        @[JSON::Field(key: "JsonPath")]
        getter json_path : String?

        def initialize(
          @name : String,
          @json_path : String? = nil
        )
        end
      end


      struct UpdateMLTransformRequest
        include JSON::Serializable

        # A unique identifier that was generated when the transform was created.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String

        # A description of the transform. The default is an empty string.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # This value determines which version of Glue this machine learning transform is compatible with. Glue
        # 1.0 is recommended for most customers. If the value is not set, the Glue compatibility defaults to
        # Glue 0.9. For more information, see Glue Versions in the developer guide.

        @[JSON::Field(key: "GlueVersion")]
        getter glue_version : String?

        # The number of Glue data processing units (DPUs) that are allocated to task runs for this transform.
        # You can allocate from 2 to 100 DPUs; the default is 10. A DPU is a relative measure of processing
        # power that consists of 4 vCPUs of compute capacity and 16 GB of memory. For more information, see
        # the Glue pricing page . When the WorkerType field is set to a value other than Standard , the
        # MaxCapacity field is set automatically and becomes read-only.

        @[JSON::Field(key: "MaxCapacity")]
        getter max_capacity : Float64?

        # The maximum number of times to retry a task for this transform after a task run fails.

        @[JSON::Field(key: "MaxRetries")]
        getter max_retries : Int32?

        # The unique name that you gave the transform when you created it.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # The number of workers of a defined workerType that are allocated when this task runs.

        @[JSON::Field(key: "NumberOfWorkers")]
        getter number_of_workers : Int32?

        # The configuration parameters that are specific to the transform type (algorithm) used. Conditionally
        # dependent on the transform type.

        @[JSON::Field(key: "Parameters")]
        getter parameters : Types::TransformParameters?

        # The name or Amazon Resource Name (ARN) of the IAM role with the required permissions.

        @[JSON::Field(key: "Role")]
        getter role : String?

        # The timeout for a task run for this transform in minutes. This is the maximum time that a task run
        # for this transform can consume resources before it is terminated and enters TIMEOUT status. The
        # default is 2,880 minutes (48 hours).

        @[JSON::Field(key: "Timeout")]
        getter timeout : Int32?

        # The type of predefined worker that is allocated when this task runs. Accepts a value of Standard,
        # G.1X, or G.2X. For the Standard worker type, each worker provides 4 vCPU, 16 GB of memory and a 50GB
        # disk, and 2 executors per worker. For the G.1X worker type, each worker provides 4 vCPU, 16 GB of
        # memory and a 64GB disk, and 1 executor per worker. For the G.2X worker type, each worker provides 8
        # vCPU, 32 GB of memory and a 128GB disk, and 1 executor per worker.

        @[JSON::Field(key: "WorkerType")]
        getter worker_type : String?

        def initialize(
          @transform_id : String,
          @description : String? = nil,
          @glue_version : String? = nil,
          @max_capacity : Float64? = nil,
          @max_retries : Int32? = nil,
          @name : String? = nil,
          @number_of_workers : Int32? = nil,
          @parameters : Types::TransformParameters? = nil,
          @role : String? = nil,
          @timeout : Int32? = nil,
          @worker_type : String? = nil
        )
        end
      end


      struct UpdateMLTransformResponse
        include JSON::Serializable

        # The unique identifier for the transform that was updated.

        @[JSON::Field(key: "TransformId")]
        getter transform_id : String?

        def initialize(
          @transform_id : String? = nil
        )
        end
      end

      # Input parameters for updating open table format tables in GlueData Catalog, serving as a wrapper for
      # format-specific update operations such as Apache Iceberg.

      struct UpdateOpenTableFormatInput
        include JSON::Serializable

        # Apache Iceberg-specific update parameters that define the table modifications to be applied,
        # including schema changes, partition specifications, and table properties.

        @[JSON::Field(key: "UpdateIcebergInput")]
        getter update_iceberg_input : Types::UpdateIcebergInput?

        def initialize(
          @update_iceberg_input : Types::UpdateIcebergInput? = nil
        )
        end
      end


      struct UpdatePartitionRequest
        include JSON::Serializable

        # The name of the catalog database in which the table in question resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The new partition object to update the partition to. The Values property can't be changed. If you
        # want to change the partition key values for a partition, delete and recreate the partition.

        @[JSON::Field(key: "PartitionInput")]
        getter partition_input : Types::PartitionInput

        # List of partition key values that define the partition to update.

        @[JSON::Field(key: "PartitionValueList")]
        getter partition_value_list : Array(String)

        # The name of the table in which the partition to be updated is located.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # The ID of the Data Catalog where the partition to be updated resides. If none is provided, the
        # Amazon Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @partition_input : Types::PartitionInput,
          @partition_value_list : Array(String),
          @table_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct UpdatePartitionResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateRegistryInput
        include JSON::Serializable

        # A description of the registry. If description is not provided, this field will not be updated.

        @[JSON::Field(key: "Description")]
        getter description : String

        # This is a wrapper structure that may contain the registry name and Amazon Resource Name (ARN).

        @[JSON::Field(key: "RegistryId")]
        getter registry_id : Types::RegistryId

        def initialize(
          @description : String,
          @registry_id : Types::RegistryId
        )
        end
      end


      struct UpdateRegistryResponse
        include JSON::Serializable

        # The Amazon Resource name (ARN) of the updated registry.

        @[JSON::Field(key: "RegistryArn")]
        getter registry_arn : String?

        # The name of the updated registry.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        def initialize(
          @registry_arn : String? = nil,
          @registry_name : String? = nil
        )
        end
      end


      struct UpdateSchemaInput
        include JSON::Serializable

        # This is a wrapper structure to contain schema identity fields. The structure contains:
        # SchemaId$SchemaArn: The Amazon Resource Name (ARN) of the schema. One of SchemaArn or SchemaName has
        # to be provided. SchemaId$SchemaName: The name of the schema. One of SchemaArn or SchemaName has to
        # be provided.

        @[JSON::Field(key: "SchemaId")]
        getter schema_id : Types::SchemaId

        # The new compatibility setting for the schema.

        @[JSON::Field(key: "Compatibility")]
        getter compatibility : String?

        # The new description for the schema.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # Version number required for check pointing. One of VersionNumber or Compatibility has to be
        # provided.

        @[JSON::Field(key: "SchemaVersionNumber")]
        getter schema_version_number : Types::SchemaVersionNumber?

        def initialize(
          @schema_id : Types::SchemaId,
          @compatibility : String? = nil,
          @description : String? = nil,
          @schema_version_number : Types::SchemaVersionNumber? = nil
        )
        end
      end


      struct UpdateSchemaResponse
        include JSON::Serializable

        # The name of the registry that contains the schema.

        @[JSON::Field(key: "RegistryName")]
        getter registry_name : String?

        # The Amazon Resource Name (ARN) of the schema.

        @[JSON::Field(key: "SchemaArn")]
        getter schema_arn : String?

        # The name of the schema.

        @[JSON::Field(key: "SchemaName")]
        getter schema_name : String?

        def initialize(
          @registry_name : String? = nil,
          @schema_arn : String? = nil,
          @schema_name : String? = nil
        )
        end
      end


      struct UpdateSourceControlFromJobRequest
        include JSON::Serializable

        # The type of authentication, which can be an authentication token stored in Amazon Web Services
        # Secrets Manager, or a personal access token.

        @[JSON::Field(key: "AuthStrategy")]
        getter auth_strategy : String?

        # The value of the authorization token.

        @[JSON::Field(key: "AuthToken")]
        getter auth_token : String?

        # An optional branch in the remote repository.

        @[JSON::Field(key: "BranchName")]
        getter branch_name : String?

        # A commit ID for a commit in the remote repository.

        @[JSON::Field(key: "CommitId")]
        getter commit_id : String?

        # An optional folder in the remote repository.

        @[JSON::Field(key: "Folder")]
        getter folder : String?

        # The name of the Glue job to be synchronized to or from the remote repository.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        # The provider for the remote repository. Possible values: GITHUB, AWS_CODE_COMMIT, GITLAB, BITBUCKET.

        @[JSON::Field(key: "Provider")]
        getter provider : String?

        # The name of the remote repository that contains the job artifacts. For BitBucket providers,
        # RepositoryName should include WorkspaceName . Use the format
        # &lt;WorkspaceName&gt;/&lt;RepositoryName&gt; .

        @[JSON::Field(key: "RepositoryName")]
        getter repository_name : String?

        # The owner of the remote repository that contains the job artifacts.

        @[JSON::Field(key: "RepositoryOwner")]
        getter repository_owner : String?

        def initialize(
          @auth_strategy : String? = nil,
          @auth_token : String? = nil,
          @branch_name : String? = nil,
          @commit_id : String? = nil,
          @folder : String? = nil,
          @job_name : String? = nil,
          @provider : String? = nil,
          @repository_name : String? = nil,
          @repository_owner : String? = nil
        )
        end
      end


      struct UpdateSourceControlFromJobResponse
        include JSON::Serializable

        # The name of the Glue job.

        @[JSON::Field(key: "JobName")]
        getter job_name : String?

        def initialize(
          @job_name : String? = nil
        )
        end
      end


      struct UpdateTableOptimizerRequest
        include JSON::Serializable

        # The Catalog ID of the table.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String

        # The name of the database in the catalog in which the table resides.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The name of the table.

        @[JSON::Field(key: "TableName")]
        getter table_name : String

        # A TableOptimizerConfiguration object representing the configuration of a table optimizer.

        @[JSON::Field(key: "TableOptimizerConfiguration")]
        getter table_optimizer_configuration : Types::TableOptimizerConfiguration

        # The type of table optimizer.

        @[JSON::Field(key: "Type")]
        getter type : String

        def initialize(
          @catalog_id : String,
          @database_name : String,
          @table_name : String,
          @table_optimizer_configuration : Types::TableOptimizerConfiguration,
          @type : String
        )
        end
      end


      struct UpdateTableOptimizerResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateTableRequest
        include JSON::Serializable

        # The name of the catalog database in which the table resides. For Hive compatibility, this name is
        # entirely lowercase.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # The ID of the Data Catalog where the table resides. If none is provided, the Amazon Web Services
        # account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # A flag that can be set to true to ignore matching storage descriptor and subobject matching
        # requirements.

        @[JSON::Field(key: "Force")]
        getter force : Bool?

        # The unique identifier for the table within the specified database that will be created in the Glue
        # Data Catalog.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # By default, UpdateTable always creates an archived version of the table before updating it. However,
        # if skipArchive is set to true, UpdateTable does not create the archived version.

        @[JSON::Field(key: "SkipArchive")]
        getter skip_archive : Bool?

        # An updated TableInput object to define the metadata table in the catalog.

        @[JSON::Field(key: "TableInput")]
        getter table_input : Types::TableInput?

        # The transaction ID at which to update the table contents.

        @[JSON::Field(key: "TransactionId")]
        getter transaction_id : String?

        # Input parameters for updating open table format tables in GlueData Catalog, serving as a wrapper for
        # format-specific update operations such as Apache Iceberg.

        @[JSON::Field(key: "UpdateOpenTableFormatInput")]
        getter update_open_table_format_input : Types::UpdateOpenTableFormatInput?

        # The version ID at which to update the table contents.

        @[JSON::Field(key: "VersionId")]
        getter version_id : String?

        # The operation to be performed when updating the view.

        @[JSON::Field(key: "ViewUpdateAction")]
        getter view_update_action : String?

        def initialize(
          @database_name : String,
          @catalog_id : String? = nil,
          @force : Bool? = nil,
          @name : String? = nil,
          @skip_archive : Bool? = nil,
          @table_input : Types::TableInput? = nil,
          @transaction_id : String? = nil,
          @update_open_table_format_input : Types::UpdateOpenTableFormatInput? = nil,
          @version_id : String? = nil,
          @view_update_action : String? = nil
        )
        end
      end


      struct UpdateTableResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateTriggerRequest
        include JSON::Serializable

        # The name of the trigger to update.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The new values with which to update the trigger.

        @[JSON::Field(key: "TriggerUpdate")]
        getter trigger_update : Types::TriggerUpdate

        def initialize(
          @name : String,
          @trigger_update : Types::TriggerUpdate
        )
        end
      end


      struct UpdateTriggerResponse
        include JSON::Serializable

        # The resulting trigger definition.

        @[JSON::Field(key: "Trigger")]
        getter trigger : Types::Trigger?

        def initialize(
          @trigger : Types::Trigger? = nil
        )
        end
      end


      struct UpdateUsageProfileRequest
        include JSON::Serializable

        # A ProfileConfiguration object specifying the job and session values for the profile.

        @[JSON::Field(key: "Configuration")]
        getter configuration : Types::ProfileConfiguration

        # The name of the usage profile.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A description of the usage profile.

        @[JSON::Field(key: "Description")]
        getter description : String?

        def initialize(
          @configuration : Types::ProfileConfiguration,
          @name : String,
          @description : String? = nil
        )
        end
      end


      struct UpdateUsageProfileResponse
        include JSON::Serializable

        # The name of the usage profile that was updated.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end


      struct UpdateUserDefinedFunctionRequest
        include JSON::Serializable

        # The name of the catalog database where the function to be updated is located.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String

        # A FunctionInput object that redefines the function in the Data Catalog.

        @[JSON::Field(key: "FunctionInput")]
        getter function_input : Types::UserDefinedFunctionInput

        # The name of the function.

        @[JSON::Field(key: "FunctionName")]
        getter function_name : String

        # The ID of the Data Catalog where the function to be updated is located. If none is provided, the
        # Amazon Web Services account ID is used by default.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        def initialize(
          @database_name : String,
          @function_input : Types::UserDefinedFunctionInput,
          @function_name : String,
          @catalog_id : String? = nil
        )
        end
      end


      struct UpdateUserDefinedFunctionResponse
        include JSON::Serializable

        def initialize
        end
      end


      struct UpdateWorkflowRequest
        include JSON::Serializable

        # Name of the workflow to be updated.

        @[JSON::Field(key: "Name")]
        getter name : String

        # A collection of properties to be used as part of each execution of the workflow. Run properties may
        # be logged. Do not pass plaintext secrets as properties. Retrieve secrets from a Glue Connection,
        # Amazon Web Services Secrets Manager or other secret management mechanism if you intend to use them
        # within the workflow run.

        @[JSON::Field(key: "DefaultRunProperties")]
        getter default_run_properties : Hash(String, String)?

        # The description of the workflow.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in
        # some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs.
        # If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.

        @[JSON::Field(key: "MaxConcurrentRuns")]
        getter max_concurrent_runs : Int32?

        def initialize(
          @name : String,
          @default_run_properties : Hash(String, String)? = nil,
          @description : String? = nil,
          @max_concurrent_runs : Int32? = nil
        )
        end
      end


      struct UpdateWorkflowResponse
        include JSON::Serializable

        # The name of the workflow which was specified in input.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @name : String? = nil
        )
        end
      end

      # Specifies an XML classifier to be updated.

      struct UpdateXMLClassifierRequest
        include JSON::Serializable

        # The name of the classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        # An identifier of the data format that the classifier matches.

        @[JSON::Field(key: "Classification")]
        getter classification : String?

        # The XML tag designating the element that contains each record in an XML document being parsed. This
        # cannot identify a self-closing element (closed by /&gt; ). An empty row element that contains only
        # attributes can be parsed as long as it ends with a closing tag (for example, &lt;row item_a="A"
        # item_b="B"&gt;&lt;/row&gt; is okay, but &lt;row item_a="A" item_b="B" /&gt; is not).

        @[JSON::Field(key: "RowTag")]
        getter row_tag : String?

        def initialize(
          @name : String,
          @classification : String? = nil,
          @row_tag : String? = nil
        )
        end
      end

      # The options to configure an upsert operation when writing to a Redshift target .

      struct UpsertRedshiftTargetOptions
        include JSON::Serializable

        # The name of the connection to use to write to Redshift.

        @[JSON::Field(key: "ConnectionName")]
        getter connection_name : String?

        # The physical location of the Redshift table.

        @[JSON::Field(key: "TableLocation")]
        getter table_location : String?

        # The keys used to determine whether to perform an update or insert.

        @[JSON::Field(key: "UpsertKeys")]
        getter upsert_keys : Array(String)?

        def initialize(
          @connection_name : String? = nil,
          @table_location : String? = nil,
          @upsert_keys : Array(String)? = nil
        )
        end
      end

      # Describes an Glue usage profile.

      struct UsageProfileDefinition
        include JSON::Serializable

        # The date and time when the usage profile was created.

        @[JSON::Field(key: "CreatedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_on : Time?

        # A description of the usage profile.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The date and time when the usage profile was last modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The name of the usage profile.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @created_on : Time? = nil,
          @description : String? = nil,
          @last_modified_on : Time? = nil,
          @name : String? = nil
        )
        end
      end

      # Represents the equivalent of a Hive user-defined function ( UDF ) definition.

      struct UserDefinedFunction
        include JSON::Serializable

        # The ID of the Data Catalog in which the function resides.

        @[JSON::Field(key: "CatalogId")]
        getter catalog_id : String?

        # The Java class that contains the function code.

        @[JSON::Field(key: "ClassName")]
        getter class_name : String?

        # The time at which the function was created.

        @[JSON::Field(key: "CreateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter create_time : Time?

        # The name of the catalog database that contains the function.

        @[JSON::Field(key: "DatabaseName")]
        getter database_name : String?

        # The name of the function.

        @[JSON::Field(key: "FunctionName")]
        getter function_name : String?

        # The type of the function.

        @[JSON::Field(key: "FunctionType")]
        getter function_type : String?

        # The owner of the function.

        @[JSON::Field(key: "OwnerName")]
        getter owner_name : String?

        # The owner type.

        @[JSON::Field(key: "OwnerType")]
        getter owner_type : String?

        # The resource URIs for the function.

        @[JSON::Field(key: "ResourceUris")]
        getter resource_uris : Array(Types::ResourceUri)?

        def initialize(
          @catalog_id : String? = nil,
          @class_name : String? = nil,
          @create_time : Time? = nil,
          @database_name : String? = nil,
          @function_name : String? = nil,
          @function_type : String? = nil,
          @owner_name : String? = nil,
          @owner_type : String? = nil,
          @resource_uris : Array(Types::ResourceUri)? = nil
        )
        end
      end

      # A structure used to create or update a user-defined function.

      struct UserDefinedFunctionInput
        include JSON::Serializable

        # The Java class that contains the function code.

        @[JSON::Field(key: "ClassName")]
        getter class_name : String?

        # The name of the function.

        @[JSON::Field(key: "FunctionName")]
        getter function_name : String?

        # The type of the function.

        @[JSON::Field(key: "FunctionType")]
        getter function_type : String?

        # The owner of the function.

        @[JSON::Field(key: "OwnerName")]
        getter owner_name : String?

        # The owner type.

        @[JSON::Field(key: "OwnerType")]
        getter owner_type : String?

        # The resource URIs for the function.

        @[JSON::Field(key: "ResourceUris")]
        getter resource_uris : Array(Types::ResourceUri)?

        def initialize(
          @class_name : String? = nil,
          @function_name : String? = nil,
          @function_type : String? = nil,
          @owner_name : String? = nil,
          @owner_type : String? = nil,
          @resource_uris : Array(Types::ResourceUri)? = nil
        )
        end
      end

      # A value could not be validated.

      struct ValidationException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # There was a version conflict.

      struct VersionMismatchException
        include JSON::Serializable

        # A message describing the problem.

        @[JSON::Field(key: "Message")]
        getter message : String?

        def initialize(
          @message : String? = nil
        )
        end
      end

      # A structure containing details for representations.

      struct ViewDefinition
        include JSON::Serializable

        # The definer of a view in SQL.

        @[JSON::Field(key: "Definer")]
        getter definer : String?

        # You can set this flag as true to instruct the engine not to push user-provided operations into the
        # logical plan of the view during query planning. However, setting this flag does not guarantee that
        # the engine will comply. Refer to the engine's documentation to understand the guarantees provided,
        # if any.

        @[JSON::Field(key: "IsProtected")]
        getter is_protected : Bool?

        # Sets the method used for the most recent refresh.

        @[JSON::Field(key: "LastRefreshType")]
        getter last_refresh_type : String?

        # Auto refresh interval in seconds for the materialized view. If not specified, the view will not
        # automatically refresh.

        @[JSON::Field(key: "RefreshSeconds")]
        getter refresh_seconds : Int64?

        # A list of representations.

        @[JSON::Field(key: "Representations")]
        getter representations : Array(Types::ViewRepresentation)?

        # List of the Apache Iceberg table versions referenced by the materialized view.

        @[JSON::Field(key: "SubObjectVersionIds")]
        getter sub_object_version_ids : Array(Int64)?

        # A list of table Amazon Resource Names (ARNs).

        @[JSON::Field(key: "SubObjects")]
        getter sub_objects : Array(String)?

        # The ID value that identifies this view's version. For materialized views, the version ID is the
        # Apache Iceberg table's snapshot ID.

        @[JSON::Field(key: "ViewVersionId")]
        getter view_version_id : Int64?

        # The version ID of the Apache Iceberg table.

        @[JSON::Field(key: "ViewVersionToken")]
        getter view_version_token : String?

        def initialize(
          @definer : String? = nil,
          @is_protected : Bool? = nil,
          @last_refresh_type : String? = nil,
          @refresh_seconds : Int64? = nil,
          @representations : Array(Types::ViewRepresentation)? = nil,
          @sub_object_version_ids : Array(Int64)? = nil,
          @sub_objects : Array(String)? = nil,
          @view_version_id : Int64? = nil,
          @view_version_token : String? = nil
        )
        end
      end

      # A structure containing details for creating or updating an Glue view.

      struct ViewDefinitionInput
        include JSON::Serializable

        # The definer of a view in SQL.

        @[JSON::Field(key: "Definer")]
        getter definer : String?

        # You can set this flag as true to instruct the engine not to push user-provided operations into the
        # logical plan of the view during query planning. However, setting this flag does not guarantee that
        # the engine will comply. Refer to the engine's documentation to understand the guarantees provided,
        # if any.

        @[JSON::Field(key: "IsProtected")]
        getter is_protected : Bool?

        # The type of the materialized view's last refresh. Valid values: Full , Incremental .

        @[JSON::Field(key: "LastRefreshType")]
        getter last_refresh_type : String?

        # Auto refresh interval in seconds for the materialized view. If not specified, the view will not
        # automatically refresh.

        @[JSON::Field(key: "RefreshSeconds")]
        getter refresh_seconds : Int64?

        # A list of structures that contains the dialect of the view, and the query that defines the view.

        @[JSON::Field(key: "Representations")]
        getter representations : Array(Types::ViewRepresentationInput)?

        # List of the Apache Iceberg table versions referenced by the materialized view.

        @[JSON::Field(key: "SubObjectVersionIds")]
        getter sub_object_version_ids : Array(Int64)?

        # A list of base table ARNs that make up the view.

        @[JSON::Field(key: "SubObjects")]
        getter sub_objects : Array(String)?

        # The ID value that identifies this view's version. For materialized views, the version ID is the
        # Apache Iceberg table's snapshot ID.

        @[JSON::Field(key: "ViewVersionId")]
        getter view_version_id : Int64?

        # The version ID of the Apache Iceberg table.

        @[JSON::Field(key: "ViewVersionToken")]
        getter view_version_token : String?

        def initialize(
          @definer : String? = nil,
          @is_protected : Bool? = nil,
          @last_refresh_type : String? = nil,
          @refresh_seconds : Int64? = nil,
          @representations : Array(Types::ViewRepresentationInput)? = nil,
          @sub_object_version_ids : Array(Int64)? = nil,
          @sub_objects : Array(String)? = nil,
          @view_version_id : Int64? = nil,
          @view_version_token : String? = nil
        )
        end
      end

      # A structure that contains the dialect of the view, and the query that defines the view.

      struct ViewRepresentation
        include JSON::Serializable

        # The dialect of the query engine.

        @[JSON::Field(key: "Dialect")]
        getter dialect : String?

        # The version of the dialect of the query engine. For example, 3.0.0.

        @[JSON::Field(key: "DialectVersion")]
        getter dialect_version : String?

        # Dialects marked as stale are no longer valid and must be updated before they can be queried in their
        # respective query engines.

        @[JSON::Field(key: "IsStale")]
        getter is_stale : Bool?

        # The name of the connection to be used to validate the specific representation of the view.

        @[JSON::Field(key: "ValidationConnection")]
        getter validation_connection : String?

        # The expanded SQL for the view. This SQL is used by engines while processing a query on a view.
        # Engines may perform operations during view creation to transform ViewOriginalText to
        # ViewExpandedText . For example: Fully qualified identifiers: SELECT * from table1 -&gt; SELECT *
        # from db1.table1

        @[JSON::Field(key: "ViewExpandedText")]
        getter view_expanded_text : String?

        # The SELECT query provided by the customer during CREATE VIEW DDL . This SQL is not used during a
        # query on a view ( ViewExpandedText is used instead). ViewOriginalText is used for cases like SHOW
        # CREATE VIEW where users want to see the original DDL command that created the view.

        @[JSON::Field(key: "ViewOriginalText")]
        getter view_original_text : String?

        def initialize(
          @dialect : String? = nil,
          @dialect_version : String? = nil,
          @is_stale : Bool? = nil,
          @validation_connection : String? = nil,
          @view_expanded_text : String? = nil,
          @view_original_text : String? = nil
        )
        end
      end

      # A structure containing details of a representation to update or create a Lake Formation view.

      struct ViewRepresentationInput
        include JSON::Serializable

        # A parameter that specifies the engine type of a specific representation.

        @[JSON::Field(key: "Dialect")]
        getter dialect : String?

        # A parameter that specifies the version of the engine of a specific representation.

        @[JSON::Field(key: "DialectVersion")]
        getter dialect_version : String?

        # The name of the connection to be used to validate the specific representation of the view.

        @[JSON::Field(key: "ValidationConnection")]
        getter validation_connection : String?

        # A string that represents the SQL query that describes the view with expanded resource ARNs

        @[JSON::Field(key: "ViewExpandedText")]
        getter view_expanded_text : String?

        # A string that represents the original SQL query that describes the view.

        @[JSON::Field(key: "ViewOriginalText")]
        getter view_original_text : String?

        def initialize(
          @dialect : String? = nil,
          @dialect_version : String? = nil,
          @validation_connection : String? = nil,
          @view_expanded_text : String? = nil,
          @view_original_text : String? = nil
        )
        end
      end

      # A structure that contains information for an analytical engine to validate a view, prior to
      # persisting the view metadata. Used in the case of direct UpdateTable or CreateTable API calls.

      struct ViewValidation
        include JSON::Serializable

        # The dialect of the query engine.

        @[JSON::Field(key: "Dialect")]
        getter dialect : String?

        # The version of the dialect of the query engine. For example, 3.0.0.

        @[JSON::Field(key: "DialectVersion")]
        getter dialect_version : String?

        # An error associated with the validation.

        @[JSON::Field(key: "Error")]
        getter error : Types::ErrorDetail?

        # The state of the validation.

        @[JSON::Field(key: "State")]
        getter state : String?

        # The time of the last update.

        @[JSON::Field(key: "UpdateTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter update_time : Time?

        # The SELECT query that defines the view, as provided by the customer.

        @[JSON::Field(key: "ViewValidationText")]
        getter view_validation_text : String?

        def initialize(
          @dialect : String? = nil,
          @dialect_version : String? = nil,
          @error : Types::ErrorDetail? = nil,
          @state : String? = nil,
          @update_time : Time? = nil,
          @view_validation_text : String? = nil
        )
        end
      end

      # A workflow is a collection of multiple dependent Glue jobs and crawlers that are run to complete a
      # complex ETL task. A workflow manages the execution and monitoring of all its jobs and crawlers.

      struct Workflow
        include JSON::Serializable

        # This structure indicates the details of the blueprint that this particular workflow is created from.

        @[JSON::Field(key: "BlueprintDetails")]
        getter blueprint_details : Types::BlueprintDetails?

        # The date and time when the workflow was created.

        @[JSON::Field(key: "CreatedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter created_on : Time?

        # A collection of properties to be used as part of each execution of the workflow. The run properties
        # are made available to each job in the workflow. A job can modify the properties for the next jobs in
        # the flow.

        @[JSON::Field(key: "DefaultRunProperties")]
        getter default_run_properties : Hash(String, String)?

        # A description of the workflow.

        @[JSON::Field(key: "Description")]
        getter description : String?

        # The graph representing all the Glue components that belong to the workflow as nodes and directed
        # connections between them as edges.

        @[JSON::Field(key: "Graph")]
        getter graph : Types::WorkflowGraph?

        # The date and time when the workflow was last modified.

        @[JSON::Field(key: "LastModifiedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_modified_on : Time?

        # The information about the last execution of the workflow.

        @[JSON::Field(key: "LastRun")]
        getter last_run : Types::WorkflowRun?

        # You can use this parameter to prevent unwanted multiple updates to data, to control costs, or in
        # some cases, to prevent exceeding the maximum number of concurrent runs of any of the component jobs.
        # If you leave this parameter blank, there is no limit to the number of concurrent workflow runs.

        @[JSON::Field(key: "MaxConcurrentRuns")]
        getter max_concurrent_runs : Int32?

        # The name of the workflow.

        @[JSON::Field(key: "Name")]
        getter name : String?

        def initialize(
          @blueprint_details : Types::BlueprintDetails? = nil,
          @created_on : Time? = nil,
          @default_run_properties : Hash(String, String)? = nil,
          @description : String? = nil,
          @graph : Types::WorkflowGraph? = nil,
          @last_modified_on : Time? = nil,
          @last_run : Types::WorkflowRun? = nil,
          @max_concurrent_runs : Int32? = nil,
          @name : String? = nil
        )
        end
      end

      # A workflow graph represents the complete workflow containing all the Glue components present in the
      # workflow and all the directed connections between them.

      struct WorkflowGraph
        include JSON::Serializable

        # A list of all the directed connections between the nodes belonging to the workflow.

        @[JSON::Field(key: "Edges")]
        getter edges : Array(Types::Edge)?

        # A list of the the Glue components belong to the workflow represented as nodes.

        @[JSON::Field(key: "Nodes")]
        getter nodes : Array(Types::Node)?

        def initialize(
          @edges : Array(Types::Edge)? = nil,
          @nodes : Array(Types::Node)? = nil
        )
        end
      end

      # A workflow run is an execution of a workflow providing all the runtime information.

      struct WorkflowRun
        include JSON::Serializable

        # The date and time when the workflow run completed.

        @[JSON::Field(key: "CompletedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter completed_on : Time?

        # This error message describes any error that may have occurred in starting the workflow run.
        # Currently the only error message is "Concurrent runs exceeded for workflow: foo ."

        @[JSON::Field(key: "ErrorMessage")]
        getter error_message : String?

        # The graph representing all the Glue components that belong to the workflow as nodes and directed
        # connections between them as edges.

        @[JSON::Field(key: "Graph")]
        getter graph : Types::WorkflowGraph?

        # Name of the workflow that was run.

        @[JSON::Field(key: "Name")]
        getter name : String?

        # The ID of the previous workflow run.

        @[JSON::Field(key: "PreviousRunId")]
        getter previous_run_id : String?

        # The date and time when the workflow run was started.

        @[JSON::Field(key: "StartedOn", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter started_on : Time?

        # The batch condition that started the workflow run.

        @[JSON::Field(key: "StartingEventBatchCondition")]
        getter starting_event_batch_condition : Types::StartingEventBatchCondition?

        # The statistics of the run.

        @[JSON::Field(key: "Statistics")]
        getter statistics : Types::WorkflowRunStatistics?

        # The status of the workflow run.

        @[JSON::Field(key: "Status")]
        getter status : String?

        # The ID of this workflow run.

        @[JSON::Field(key: "WorkflowRunId")]
        getter workflow_run_id : String?

        # The workflow run properties which were set during the run.

        @[JSON::Field(key: "WorkflowRunProperties")]
        getter workflow_run_properties : Hash(String, String)?

        def initialize(
          @completed_on : Time? = nil,
          @error_message : String? = nil,
          @graph : Types::WorkflowGraph? = nil,
          @name : String? = nil,
          @previous_run_id : String? = nil,
          @started_on : Time? = nil,
          @starting_event_batch_condition : Types::StartingEventBatchCondition? = nil,
          @statistics : Types::WorkflowRunStatistics? = nil,
          @status : String? = nil,
          @workflow_run_id : String? = nil,
          @workflow_run_properties : Hash(String, String)? = nil
        )
        end
      end

      # Workflow run statistics provides statistics about the workflow run.

      struct WorkflowRunStatistics
        include JSON::Serializable

        # Indicates the count of job runs in the ERROR state in the workflow run.

        @[JSON::Field(key: "ErroredActions")]
        getter errored_actions : Int32?

        # Total number of Actions that have failed.

        @[JSON::Field(key: "FailedActions")]
        getter failed_actions : Int32?

        # Total number Actions in running state.

        @[JSON::Field(key: "RunningActions")]
        getter running_actions : Int32?

        # Total number of Actions that have stopped.

        @[JSON::Field(key: "StoppedActions")]
        getter stopped_actions : Int32?

        # Total number of Actions that have succeeded.

        @[JSON::Field(key: "SucceededActions")]
        getter succeeded_actions : Int32?

        # Total number of Actions that timed out.

        @[JSON::Field(key: "TimeoutActions")]
        getter timeout_actions : Int32?

        # Total number of Actions in the workflow run.

        @[JSON::Field(key: "TotalActions")]
        getter total_actions : Int32?

        # Indicates the count of job runs in WAITING state in the workflow run.

        @[JSON::Field(key: "WaitingActions")]
        getter waiting_actions : Int32?

        def initialize(
          @errored_actions : Int32? = nil,
          @failed_actions : Int32? = nil,
          @running_actions : Int32? = nil,
          @stopped_actions : Int32? = nil,
          @succeeded_actions : Int32? = nil,
          @timeout_actions : Int32? = nil,
          @total_actions : Int32? = nil,
          @waiting_actions : Int32? = nil
        )
        end
      end

      # A classifier for XML content.

      struct XMLClassifier
        include JSON::Serializable

        # An identifier of the data format that the classifier matches.

        @[JSON::Field(key: "Classification")]
        getter classification : String

        # The name of the classifier.

        @[JSON::Field(key: "Name")]
        getter name : String

        # The time that this classifier was registered.

        @[JSON::Field(key: "CreationTime", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter creation_time : Time?

        # The time that this classifier was last updated.

        @[JSON::Field(key: "LastUpdated", converter: AwsSdk::Runtime::UnixTimestampConverter)]
        getter last_updated : Time?

        # The XML tag designating the element that contains each record in an XML document being parsed. This
        # can't identify a self-closing element (closed by /&gt; ). An empty row element that contains only
        # attributes can be parsed as long as it ends with a closing tag (for example, &lt;row item_a="A"
        # item_b="B"&gt;&lt;/row&gt; is okay, but &lt;row item_a="A" item_b="B" /&gt; is not).

        @[JSON::Field(key: "RowTag")]
        getter row_tag : String?

        # The version of this classifier.

        @[JSON::Field(key: "Version")]
        getter version : Int64?

        def initialize(
          @classification : String,
          @name : String,
          @creation_time : Time? = nil,
          @last_updated : Time? = nil,
          @row_tag : String? = nil,
          @version : Int64? = nil
        )
        end
      end
    end
  end
end
