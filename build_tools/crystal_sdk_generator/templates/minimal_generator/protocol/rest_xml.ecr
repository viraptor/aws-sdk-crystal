require "json"
require "uri"
require "xml"
require "../../runtime"

module Aws
  module <%= info.module_name %>
    module Protocol
      module RestXml
        CONTENT_TYPE = "application/xml"

        struct ShapeMember
          getter name : String
          getter shape : String
          getter location : String?
          getter location_name : String?
          getter flattened : Bool

          def initialize(
            @name : String,
            @shape : String,
            @location : String?,
            @location_name : String?,
            @flattened : Bool
          )
          end
        end

        struct Shape
          getter name : String
          getter type : String
          getter members : Array(ShapeMember)
          getter list_member : ShapeMember?
          getter flattened : Bool

          def initialize(
            @name : String,
            @type : String,
            @members : Array(ShapeMember),
            @list_member : ShapeMember?,
            @flattened : Bool
          )
          end
        end

        OPERATION_INPUT_SHAPES = {
<% operations.each do |operation| %>
<% next unless (input = operation.input) %>
          "<%= operation.name %>" => "<%= input.shape_name %>",
<% end %>
        }

        OPERATION_OUTPUT_SHAPES = {
<% operations.each do |operation| %>
<% next unless (output = operation.output) %>
          "<%= operation.name %>" => "<%= output.shape_name %>",
<% end %>
        }

        OPERATION_INPUT_ROOTS = {
<% operations.each do |operation| %>
<% next unless (input = operation.input) %>
<% root_name = trait_string(input.traits, "locationName") || input.shape_name %>
          "<%= operation.name %>" => "<%= root_name %>",
<% end %>
        }

        OPERATION_INPUT_NAMESPACES = {
<% operations.each do |operation| %>
<% next unless (input = operation.input) %>
<% namespace = xml_namespace_uri(input) %>
<% next unless namespace %>
          "<%= operation.name %>" => "<%= namespace %>",
<% end %>
        }

        SHAPES = {
<% shapes.each do |shape| %>
<% shape_type = shape_type_name(shape) %>
<% if shape.type == ShapeType::Structure %>
          "<%= shape.name %>" => Shape.new(
            "<%= shape.name %>",
            "<%= shape_type %>",
            [
<% shape.members.keys.sort.each do |member_name| %>
<% ref = shape.members[member_name] %>
<% location = trait_string(ref.traits, "location") %>
<% location_name = trait_string(ref.traits, "locationName") %>
<% flattened = trait_bool(ref.traits, "flattened") %>
              ShapeMember.new(
                "<%= member_name %>",
                "<%= ref.shape_name %>",
                <%= location ? "\"#{location}\"" : "nil" %>,
                <%= location_name ? "\"#{location_name}\"" : "nil" %>,
                <%= flattened %>
              ),
<% end %>
            ] of ShapeMember,
            nil,
            false
          ),
<% elsif shape.type == ShapeType::List %>
<% member_ref = shape.member %>
<% if member_ref %>
<% location_name = trait_string(member_ref.traits, "locationName") %>
<% flattened = trait_bool(shape.traits, "flattened") || trait_bool(member_ref.traits, "flattened") %>
          "<%= shape.name %>" => Shape.new(
            "<%= shape.name %>",
            "<%= shape_type %>",
            [] of ShapeMember,
            ShapeMember.new(
              "member",
              "<%= member_ref.shape_name %>",
              nil,
              <%= location_name ? "\"#{location_name}\"" : "nil" %>,
              <%= trait_bool(member_ref.traits, "flattened") %>
            ),
            <%= flattened %>
          ),
<% end %>
<% else %>
          "<%= shape.name %>" => Shape.new(
            "<%= shape.name %>",
            "<%= shape_type %>",
            [] of ShapeMember,
            nil,
            false
          ),
<% end %>
<% end %>
        }

        def self.build_request(operation : Model::OperationModel, input, endpoint : String) : Aws::Runtime::Http::Request
          raise ArgumentError.new("endpoint must not be empty") if endpoint.empty?
          payload = input ? JSON.parse(input.to_json).as_h : {} of String => JSON::Any
          input_shape = OPERATION_INPUT_SHAPES[operation.name]?
          raise ArgumentError.new("input shape missing for #{operation.name}") if input && input_shape.nil?
          uri = endpoint.rstrip("/") + operation.request_uri
          uri = apply_uri_labels(uri, input_shape, payload) if input_shape
          params = URI::Params.new
          headers = {"content-type" => CONTENT_TYPE}
          apply_query_params(params, input_shape, payload) if input_shape
          apply_header_params(headers, input_shape, payload) if input_shape
          query = params.to_s
          uri = "#{uri}?#{query}" unless query.empty?
          body = if input_shape
            body_payload = body_payload(input_shape, payload)
            if body_payload.empty?
              nil
            else
              root_name = OPERATION_INPUT_ROOTS[operation.name]? || input_shape
              namespace = OPERATION_INPUT_NAMESPACES[operation.name]?
              build_xml(root_name, input_shape, body_payload, namespace)
            end
          else
            nil
          end
          Aws::Runtime::Http::Request.new(operation.http_method, uri, headers, body)
        end

        def self.parse_error(response : Aws::Runtime::Http::Response) : Exception
          error_type = error_type_from_body(response.body)
          message = error_message_from_body(response.body)
          Errors.build(error_type, message)
        end

        def self.parse_response(response : Aws::Runtime::Http::Response, output_type : T.class, operation_name : String) : T forall T
          payload = {} of String => JSON::Any
          output_shape = OPERATION_OUTPUT_SHAPES[operation_name]?
          if (body = response.body)
            document = XML.parse(body)
            node = result_node(document, operation_name) || document.root
            if node && output_shape
              parsed = parse_node(node, output_shape)
              payload = parsed.as_h? || payload
            end
          end
          apply_header_values(payload, output_shape, response.headers) if output_shape
          output_type.from_json(JSON::Any.new(payload).to_json)
        rescue XML::Error
          output_type.from_json("{}")
        end

        private def self.shape(name : String) : Shape
          SHAPES[name]? || raise ArgumentError.new("shape not found: #{name}")
        end

        private def self.member_key(member : ShapeMember) : String
          member.location_name || member.name
        end

        private def self.apply_uri_labels(uri : String, input_shape : String, payload : Hash(String, JSON::Any)) : String
          result = uri
          labels = uri.scan(/\{([^\}]+)\}/).map { |match| match[1] }
          return result if labels.empty?
          shape = shape(input_shape)
          labels.each do |label|
            member = shape.members.find { |item| item.location == "uri" && member_key(item) == label }
            raise ArgumentError.new("missing uri label #{label}") unless member
            value = payload[member_key(member)]?
            raise ArgumentError.new("missing value for uri label #{label}") unless value
            member_shape = shape(member.shape)
            result = result.gsub("{#{label}}", scalar_text(member_shape.type, value))
          end
          result
        end

        private def self.apply_query_params(params : URI::Params, input_shape : String, payload : Hash(String, JSON::Any)) : Nil
          shape = shape(input_shape)
          shape.members.each do |member|
            next unless member.location == "querystring"
            key = member_key(member)
            value = payload[key]?
            next unless value
            add_param(params, key, value)
          end
        end

        private def self.apply_header_params(headers : Hash(String, String), input_shape : String, payload : Hash(String, JSON::Any)) : Nil
          shape = shape(input_shape)
          shape.members.each do |member|
            next unless member.location == "header"
            key = member_key(member)
            value = payload[key]?
            next unless value
            headers[key] = scalar_text(shape(member.shape).type, value)
          end
        end

        private def self.body_payload(input_shape : String, payload : Hash(String, JSON::Any)) : Hash(String, JSON::Any)
          shape = shape(input_shape)
          return {} of String => JSON::Any unless shape.type == "structure"
          body = {} of String => JSON::Any
          shape.members.each do |member|
            next unless member.location.nil?
            key = member_key(member)
            value = payload[key]?
            next unless value
            next if value.raw.nil?
            body[key] = value
          end
          body
        end

        private def self.build_xml(root_name : String, root_shape : String, payload : Hash(String, JSON::Any), xml_namespace : String?) : String
          XML.build do |xml|
            shape = shape(root_shape)
            if xml_namespace
              xml.element(root_name, {"xmlns" => xml_namespace}) do
                serialize_structure(xml, shape, payload)
              end
            else
              xml.element(root_name) do
                serialize_structure(xml, shape, payload)
              end
            end
          end
        end

        private def self.serialize_structure(xml : XML::Builder, shape : Shape, payload : Hash(String, JSON::Any)) : Nil
          shape.members.each do |member|
            next unless member.location.nil?
            key = member_key(member)
            value = payload[key]?
            next unless value
            serialize_member(xml, member, value)
          end
        end

        private def self.serialize_member(xml : XML::Builder, member : ShapeMember, value : JSON::Any) : Nil
          shape = shape(member.shape)
          element_name = member_key(member)
          case shape.type
          when "structure"
            xml.element(element_name) do
              serialize_structure(xml, shape, value.as_h? || {} of String => JSON::Any)
            end
          when "list"
            serialize_list(xml, element_name, shape, value, member.flattened)
          else
            xml.element(element_name) { xml.text(scalar_text(shape.type, value)) }
          end
        end

        private def self.serialize_list(xml : XML::Builder, element_name : String, shape : Shape, value : JSON::Any, member_flattened : Bool) : Nil
          items = value.as_a? || [] of JSON::Any
          list_member = shape.list_member
          return unless list_member
          member_name = list_member.location_name || "member"
          flattened = shape.flattened || member_flattened
          if flattened
            items.each do |item|
              serialize_value(xml, member_name, list_member.shape, item)
            end
          else
            xml.element(element_name) do
              items.each do |item|
                serialize_value(xml, member_name, list_member.shape, item)
              end
            end
          end
        end

        private def self.serialize_value(xml : XML::Builder, element_name : String, shape_name : String, value : JSON::Any) : Nil
          shape = shape(shape_name)
          case shape.type
          when "structure"
            xml.element(element_name) do
              serialize_structure(xml, shape, value.as_h? || {} of String => JSON::Any)
            end
          when "list"
            serialize_list(xml, element_name, shape, value, false)
          else
            xml.element(element_name) { xml.text(scalar_text(shape.type, value)) }
          end
        end

        private def self.scalar_text(shape_type : String, value : JSON::Any) : String
          case value.raw
          when Nil
            ""
          when String
            value.as_s
          when Int64
            value.as_i.to_s
          when Float64
            value.as_f.to_s
          when Bool
            value.as_bool ? "true" : "false"
          else
            value.to_json
          end
        end

        private def self.parse_node(node : XML::Node, shape_name : String) : JSON::Any
          shape = shape(shape_name)
          case shape.type
          when "structure"
            JSON::Any.new(parse_structure(node, shape))
          when "list"
            JSON::Any.new(parse_list(node, shape))
          else
            parse_scalar(shape.type, node.content)
          end
        end

        private def self.parse_structure(node : XML::Node, shape : Shape) : Hash(String, JSON::Any)
          result = {} of String => JSON::Any
          shape.members.each do |member|
            next unless member.location.nil?
            shape_ref = shape(member.shape)
            key = member_key(member)
            if shape_ref.type == "list" && (shape_ref.flattened || member.flattened)
              list_member = shape_ref.list_member
              next unless list_member
              member_name = list_member.location_name || "member"
              items = node.children.select(&.element?).select { |child| child.name == member_name }
              values = items.map { |child| parse_node(child, list_member.shape) }
              result[key] = JSON::Any.new(values)
            else
              child = node.children.find { |item| item.element? && item.name == key }
              next unless child
              result[key] = parse_node(child, member.shape)
            end
          end
          result
        end

        private def self.parse_list(node : XML::Node, shape : Shape) : Array(JSON::Any)
          member = shape.list_member
          return [] of JSON::Any unless member
          member_name = member.location_name || "member"
          items = node.children.select(&.element?).select { |child| child.name == member_name }
          items.map { |child| parse_node(child, member.shape) }
        end

        private def self.parse_scalar(shape_type : String, value : String) : JSON::Any
          case shape_type
          when "integer", "short", "byte"
            JSON::Any.new(value.to_i)
          when "long", "bigInteger"
            JSON::Any.new(value.to_i64)
          when "float", "double", "bigDecimal"
            JSON::Any.new(value.to_f)
          when "boolean"
            JSON::Any.new(value.downcase == "true")
          else
            JSON::Any.new(value)
          end
        end

        private def self.apply_header_values(payload : Hash(String, JSON::Any), output_shape : String, headers : Hash(String, String)) : Nil
          shape = shape(output_shape)
          shape.members.each do |member|
            next unless member.location == "header"
            header_name = member_key(member)
            value = header_value(headers, header_name)
            next unless value
            payload[header_name] = parse_scalar(shape(member.shape).type, value)
          end
        end

        private def self.header_value(headers : Hash(String, String), name : String) : String?
          headers[name]? || headers[name.downcase]? || headers[name.upcase]? || headers.find { |key, _| key.downcase == name.downcase }.try(&.[1])
        end

        private def self.result_node(document : XML::Node, operation_name : String) : XML::Node?
          document.xpath_node("//*[local-name()=\"#{operation_name}Result\"]") ||
            document.xpath_node("//*[local-name()=\"#{operation_name}Response\"]")
        end

        private def self.add_param(params : URI::Params, key : String, value : JSON::Any) : Nil
          case value.raw
          when Nil
          when Array
            value.as_a.each do |item|
              add_param(params, key, item)
            end
          when Hash
            params.add(key, value.to_json)
          when String
            params.add(key, value.as_s)
          when Int64
            params.add(key, value.as_i.to_s)
          when Float64
            params.add(key, value.as_f.to_s)
          when Bool
            params.add(key, value.as_bool ? "true" : "false")
          else
            params.add(key, value.to_json)
          end
        end

        private def self.error_type_from_body(body : String?) : String?
          return nil unless body
          document = XML.parse(body)
          node = document.xpath_node("//Code")
          node.try(&.content)
        rescue XML::Error
          nil
        end

        private def self.error_message_from_body(body : String?) : String?
          return nil unless body
          document = XML.parse(body)
          node = document.xpath_node("//Message")
          node.try(&.content)
        rescue XML::Error
          nil
        end
      end
    end
  end
end
